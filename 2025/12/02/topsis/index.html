<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="Topsis模型引出 问题的提出 生活中我们常常要进行评价，层次分析法，是通过构造判断矩阵，确定各指标的权重，然后对指标数值进行加权来进行打分，那还有别的方法吗？ 明星Kun想找个对象，但喜欢他的人太多，不知道怎么选，经过层层考察，留下三个候选人。    候选人 颜值 脾气（争吵次数）     A     9     10       B     8">
<meta property="og:type" content="article">
<meta property="og:title" content="Topsis算法">
<meta property="og:url" content="http://example.com/2025/12/02/Topsis/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Topsis模型引出 问题的提出 生活中我们常常要进行评价，层次分析法，是通过构造判断矩阵，确定各指标的权重，然后对指标数值进行加权来进行打分，那还有别的方法吗？ 明星Kun想找个对象，但喜欢他的人太多，不知道怎么选，经过层层考察，留下三个候选人。    候选人 颜值 脾气（争吵次数）     A     9     10       B     8">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-12-02T06:10:08.000Z">
<meta property="article:modified_time" content="2025-12-05T15:37:19.783Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/12/02/Topsis/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2025/12/02/Topsis/","path":"2025/12/02/Topsis/","title":"Topsis算法"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Topsis算法 | Hexo</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":"all","tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#topsis%E6%A8%A1%E5%9E%8B%E5%BC%95%E5%87%BA"><span class="nav-number">1.</span> <span class="nav-text">Topsis模型引出</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E7%9A%84%E6%8F%90%E5%87%BA"><span class="nav-number">1.1.</span> <span class="nav-text">问题的提出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.2.</span> <span class="nav-text">基本概念</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#topsis%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">Topsis基本原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.</span> <span class="nav-text">模型原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="nav-number">2.2.</span> <span class="nav-text">基本步骤</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#topsis-%E5%85%B8%E5%9E%8B%E4%BE%8B%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">Topsis  典型例题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%A7%8B%E7%9F%A9%E9%98%B5%E6%AD%A3%E5%90%91%E5%8C%96"><span class="nav-number">3.1.</span> <span class="nav-text">原始矩阵正向化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E5%90%91%E5%8C%96%E7%9F%A9%E9%98%B5%E6%A0%87%E5%87%86%E5%8C%96"><span class="nav-number">3.2.</span> <span class="nav-text">正向化矩阵标准化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%BE%97%E5%88%86%E5%B9%B6%E5%BD%92%E4%B8%80%E5%8C%96"><span class="nav-number">3.3.</span> <span class="nav-text">计算得分并归一化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#topsis%E6%B3%95%E7%9A%84matlab%E4%BB%A3%E7%A0%81"><span class="nav-number">4.</span> <span class="nav-text">Topsis法的Matlab代码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E4%BB%A3%E7%A0%81"><span class="nav-number">4.1.</span> <span class="nav-text">主代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#positivization%E5%87%BD%E6%95%B0"><span class="nav-number">4.2.</span> <span class="nav-text">Positivization函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0"><span class="nav-number">4.3.</span> <span class="nav-text">其他函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#topsis%E6%B3%95%E7%9A%84python%E4%BB%A3%E7%A0%81"><span class="nav-number">5.</span> <span class="nav-text">Topsis法的Python代码</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/02/Topsis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Topsis算法 | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Topsis算法
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-12-02 14:10:08" itemprop="dateCreated datePublished" datetime="2025-12-02T14:10:08+08:00">2025-12-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-12-05 23:37:19" itemprop="dateModified" datetime="2025-12-05T23:37:19+08:00">2025-12-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="topsis模型引出">Topsis模型引出</h1>
<h2 id="问题的提出">问题的提出</h2>
<p>生活中我们常常要进行评价，层次分析法，是通过构造判断矩阵，确定各指标的权重，然后对指标数值进行加权来进行打分，那还有别的方法吗？</p>
<p><strong>明星Kun想找个对象，但喜欢他的人太多，不知道怎么选，经过层层考察，留下三个候选人。</strong></p>
<table>
<thead>
<tr>
<th style="text-align: center;">候选人</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">脾气（争吵次数）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A    </td>
<td style="text-align: center;">9    </td>
<td style="text-align: center;">10    </td>
</tr>
<tr>
<td style="text-align: center;">B    </td>
<td style="text-align: center;">8    </td>
<td style="text-align: center;">7    </td>
</tr>
<tr>
<td style="text-align: center;">C    </td>
<td style="text-align: center;">6    </td>
<td style="text-align: center;">3    </td>
</tr>
</tbody>
</table>
<ul>
<li>理想情况下：
<ul>
<li>最好的对象应该是颜值9，脾气3</li>
<li>最差的对象应该是颜值6，脾气10</li>
</ul></li>
<li>那怎么衡量A、B、C和最好、最差的距离呢？
<ul>
<li>把（9，3）、（6，10）作为二维平面的一个点</li>
</ul></li>
<li>距离<strong>最好点最近</strong>或者<strong>距离最差点最远</strong>的的就是综合条件最好的</li>
</ul>
<h2 id="基本概念">基本概念</h2>
<p>C.L. Hwang和 K.Yoon于1981年首次提出 TOPSIS (Technique for Order
Preference by Similarity to an Ideal
Solution)，可翻译为逼近理想解排序法，国内常简称为<strong>优劣解距离法</strong>。</p>
<p><strong>TOPSIS法</strong>是一种常用的综合评价方法，能充分利用原始数据的信息，其结果能精确地反映各评价方案之间的差距。
TOPSIS法引入了两个基本概念：</p>
<p><strong>理想解</strong>：设想的最优的解（方案），它的各个属性值都达到各备选方案中的最好的值；
<strong>负理想解</strong>：设想的最劣的解（方案），它的各个属性值都达到各备选方案中的最坏的值。</p>
<p>方案排序的规则是把各备选方案与理想解和负理想解做比较，若其中有一个方案最接近理想解，而同时又远离负理想解，则该方案是备选方案中最好的方案。<strong>TOPSIS</strong>通过最接近理想解且最远离负理想解来<strong>确定最优选择</strong>。</p>
<h1 id="topsis基本原理">Topsis基本原理</h1>
<h2 id="模型原理">模型原理</h2>
<p><strong>TOPSIS法</strong>是一种理想目标相似性的顺序选优技术，在<strong>多目标决策分析</strong>中是一种非常有效的方法。它通过归一化后（去量纲化）的数据规范化矩阵，找出多个目标中最优目标和最劣目标（分别用理想归一解化和反理想解表示），分别计算各评价目标与理想解和反理想解的距离，获得各目标与理想解的贴近度，按理想解贴近度的大小排序，以此作为评价目标优劣的依据。贴近度取值在0～1之间，该值愈接近1，表示相应的评价目标越接近最优水平；反之，该值愈接近0，表示评价目标越接近最劣水平。</p>
<h2 id="基本步骤">基本步骤</h2>
<ul>
<li>将原始矩阵正向化
<ul>
<li>将原始矩阵正向化，就是要将所有的指标类型统一转化为<strong>极大型指标</strong>。</li>
</ul></li>
<li>正向矩阵标准化
<ul>
<li>标准化的方法有很多种，其主要目的就是去除量纲的影响，保证不同评价指标在同一数量级，且数据<strong>大小排序不变</strong>。</li>
</ul></li>
<li>计算得分并归一化
<ul>
<li> <span class="math inline">\(S_i=\frac{D_i^-}{D_i^++D_i^-}\)</span>,
其中 <span class="math inline">\(S_i\)</span> 为得分，<span
class="math inline">\(D_i^+\)</span> 为评价对象与最大值的距离，<span
class="math inline">\(D_i^-\)</span> 为评价对象与最小值的距离。</li>
</ul></li>
</ul>
<h1 id="topsis-典型例题">Topsis  典型例题</h1>
<p><strong>我们继续帮明星Kun选对象</strong></p>
<p>明星Kun考虑了一下觉得光靠颜值和脾气可能考虑的还不够全面，就又加上了身高和体重两个指标，而且他认为身高165是最好，体重在90-100斤是最好。</p>
<table>
<thead>
<tr>
<th style="text-align: center;">候选人</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">脾气（争吵次数）</th>
<th style="text-align: center;">身高</th>
<th style="text-align: center;">体重</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A    </td>
<td style="text-align: center;">9    </td>
<td style="text-align: center;">10  </td>
<td style="text-align: center;">175  </td>
<td style="text-align: center;">120  </td>
</tr>
<tr>
<td style="text-align: center;">B    </td>
<td style="text-align: center;">8    </td>
<td style="text-align: center;">7    </td>
<td style="text-align: center;">164  </td>
<td style="text-align: center;">80  </td>
</tr>
<tr>
<td style="text-align: center;">C    </td>
<td style="text-align: center;">6    </td>
<td style="text-align: center;">3    </td>
<td style="text-align: center;">157  </td>
<td style="text-align: center;">90  </td>
</tr>
</tbody>
</table>
<h2 id="原始矩阵正向化">原始矩阵正向化</h2>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;">指标名称    </th>
<th style="text-align: center;">指标特点    </th>
<th style="text-align: center;">例子    </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">极大型（效益型）指标</td>
<td style="text-align: center;">越大（多）越好    </td>
<td style="text-align: center;">颜值、成绩、GDP增速    </td>
</tr>
<tr>
<td style="text-align: center;">极小型（成本型）指标</td>
<td style="text-align: center;">越小（少）越好    </td>
<td style="text-align: center;">脾气、费用、坏品率、污染程度 </td>
</tr>
<tr>
<td style="text-align: center;">中间型指标    </td>
<td style="text-align: center;">越接近某个值越好    </td>
<td style="text-align: center;">身高、水质量评估时的PH值    </td>
</tr>
<tr>
<td style="text-align: center;">区间型指标    </td>
<td style="text-align: center;">落在某个区间最好    </td>
<td style="text-align: center;">体重、体温    </td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;">指标名称    </th>
<th style="text-align: center;">公式    </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">极大型（效益型）指标    </td>
<td style="text-align: center;">/    </td>
</tr>
<tr>
<td style="text-align: center;">极小型（成本型）指标    </td>
<td style="text-align: center;"><span class="math inline">\(\tilde{x} =
\max - x\)</span>，<span
class="math inline">\(\tilde{x}\)</span>为转化后指标，<span
class="math inline">\(\max\)</span>为指标最大值，<span
class="math inline">\(x\)</span>为指标值</td>
</tr>
<tr>
<td style="text-align: center;">中间型指标    </td>
<td style="text-align: center;"><span
class="math inline">\(\{x_i\}\)</span>是一组区间型序列，最优值是<span
class="math inline">\(x_{best}\)</span>,<span
class="math inline">\(M=\max\{|x_i-x_{best}|\},\tilde{x}_i=1-\frac{|x_i-x_{best}|}{M}\)</span></td>
</tr>
<tr>
<td style="text-align: center;">区间型指标    </td>
<td style="text-align: center;"><span
class="math inline">\(\{x_i\}\)</span>是一组区间型序列，最佳区间为<span
class="math inline">\([a,b]\)</span>，正向化公式如下：<span
class="math display">\[M=\max\{a -\min\{x_i\}, \max\{x_i\} - b\},
\tilde{x}_i = \begin{cases} 1 - \frac{a - x_i}{M}, &amp; x_i &lt; a \\
1, &amp; a \leqslant x_i \leqslant b \\ 1 -\frac{x_i - b}{M}, &amp; x_i
&gt; b \end{cases}\]</span></td>
</tr>
</tbody>
</table>
<ul>
<li>将原始矩阵正向化，就是要将所有的指标类型统一转化为<strong>极大型指标</strong>。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center;">候选人</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">脾气（争吵次数）</th>
<th style="text-align: center;">身高165</th>
<th style="text-align: center;">体重90-100</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A    </td>
<td style="text-align: center;">9    </td>
<td style="text-align: center;">10    </td>
<td style="text-align: center;">175  </td>
<td style="text-align: center;">120  </td>
</tr>
<tr>
<td style="text-align: center;">B    </td>
<td style="text-align: center;">8    </td>
<td style="text-align: center;">7    </td>
<td style="text-align: center;">164  </td>
<td style="text-align: center;">80  </td>
</tr>
<tr>
<td style="text-align: center;">C    </td>
<td style="text-align: center;">6    </td>
<td style="text-align: center;">3    </td>
<td style="text-align: center;">157  </td>
<td style="text-align: center;">90  </td>
</tr>
</tbody>
</table>
<p><span class="math display">\[\Downarrow\]</span></p>
<table>
<thead>
<tr>
<th style="text-align: center;">候选人</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">脾气（争吵次数）</th>
<th style="text-align: center;">身高</th>
<th style="text-align: center;">体重</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A    </td>
<td style="text-align: center;">9    </td>
<td style="text-align: center;">0    </td>
<td style="text-align: center;">0    </td>
<td style="text-align: center;">0    </td>
</tr>
<tr>
<td style="text-align: center;">B    </td>
<td style="text-align: center;">8    </td>
<td style="text-align: center;">3    </td>
<td style="text-align: center;">0.9  </td>
<td style="text-align: center;">0.5  </td>
</tr>
<tr>
<td style="text-align: center;">C    </td>
<td style="text-align: center;">6    </td>
<td style="text-align: center;">7    </td>
<td style="text-align: center;">0.2  </td>
<td style="text-align: center;">1    </td>
</tr>
</tbody>
</table>
<h2 id="正向化矩阵标准化">正向化矩阵标准化</h2>
<ul>
<li>标准化的目的是消除不同指标量纲的影响。
<ul>
<li>假设有 $ n $ 个要评价的对象，$ m $
个评价指标（已正向化）构成的正向化矩阵如下： <span
class="math display">\[X =
\begin{bmatrix}
x_{11} &amp; \cdots &amp; x_{1m} \\
\vdots &amp; \ddots &amp; \vdots \\
x_{n1} &amp; \cdots &amp; x_{nm}
\end{bmatrix}\]</span></li>
</ul></li>
</ul>
<p>那么，对其标准化的矩阵记为 <span
class="math inline">\(Z\)</span>，<span class="math inline">\(Z\)</span>
中的每一个元素： <span class="math inline">\(z_{ij} =
\frac{x_{ij}}{\sqrt{\sum\limits_{i=1}^{n}x_{ij}^2}}\)</span>（每一个元素/<span
class="math inline">\(\sqrt{其所在列的元素的平方和}\)</span>）</p>
<ul>
<li>标准化后，还需给不同指标加上权重，采用的权重确定方法有<strong>层次分析法</strong>、<strong>熵权法</strong>、<strong>Delphi法</strong>、<strong>对数最小二乘法</strong>等。在这里认为各个指标的权重相同。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center;">候选人</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">脾气（争吵次数）</th>
<th style="text-align: center;">身高</th>
<th style="text-align: center;">体重</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A    </td>
<td style="text-align: center;">9    </td>
<td style="text-align: center;">0    </td>
<td style="text-align: center;">0    </td>
<td style="text-align: center;">0    </td>
</tr>
<tr>
<td style="text-align: center;">B    </td>
<td style="text-align: center;">8    </td>
<td style="text-align: center;">3    </td>
<td style="text-align: center;">0.9    </td>
<td style="text-align: center;">0.5    </td>
</tr>
<tr>
<td style="text-align: center;">C    </td>
<td style="text-align: center;">6    </td>
<td style="text-align: center;">7    </td>
<td style="text-align: center;">0.2    </td>
<td style="text-align: center;">1    </td>
</tr>
</tbody>
</table>
<p><span class="math display">\[\Downarrow\]</span></p>
<table>
<thead>
<tr>
<th style="text-align: center;">候选人</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">脾气（争吵次数）</th>
<th style="text-align: center;">身高</th>
<th style="text-align: center;">体重</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A    </td>
<td style="text-align: center;">0.669</td>
<td style="text-align: center;">0    </td>
<td style="text-align: center;">0    </td>
<td style="text-align: center;">0    </td>
</tr>
<tr>
<td style="text-align: center;">B    </td>
<td style="text-align: center;">0.595</td>
<td style="text-align: center;">0.394</td>
<td style="text-align: center;">0.976</td>
<td style="text-align: center;">0.447</td>
</tr>
<tr>
<td style="text-align: center;">C    </td>
<td style="text-align: center;">0.446</td>
<td style="text-align: center;">0.919</td>
<td style="text-align: center;">0.217</td>
<td style="text-align: center;">0.894</td>
</tr>
</tbody>
</table>
<h2 id="计算得分并归一化">计算得分并归一化</h2>
<ul>
<li><p>上一步得到标准化矩阵 $ Z $   <span class="math display">\[  Z =
    \begin{bmatrix}
    z_{11} &amp; \cdots &amp; z_{1m} \\
    \vdots &amp; \ddots &amp; \vdots \\
    z_{n1} &amp; \cdots &amp; z_{nm}
    \end{bmatrix}\]</span></p></li>
<li><p>定义最大值 <span
class="math display">\[Z^{+}=(Z_1^+,Z_2^+,\cdots,Z_m^+)=(\max\{z_{11},z_{21},\cdots,z_{n1}\},\max\{z_{12},z_{22},\cdots,z_{n2}\},\cdots,\max\{z_{1m},
z_{2m},\cdots, z_{nm}\})\]</span></p></li>
<li><p>定义最小值 <span
class="math display">\[Z^{-}=(Z_1^-,Z_2^-,\cdots,Z_m^-)=(\min\{z_{11},z_{21},\cdots,z_{n1}\},\min\{z_{12},z_{22},\cdots,z_{n2}\},\cdots,\min\{z_{1m},
z_{2m},\cdots, z_{nm}\})\]</span></p></li>
<li><p>定义第 $ i(i=1,2,...,n) $ 个评价对象与最大值的距离 <span
class="math inline">\(D_i^+=\sqrt{\sum\limits_{j=1}^m(Z_j^+-z_{ij})^2}\)</span></p></li>
<li><p>定义第 $ i(i=1,2,...,n) $ 个评价对象与最小值的距离 <span
class="math inline">\(D_i^{-}=\sqrt{\sum\limits_{j=1}^m(Z_j^{-}-z_{ij})^2}\)</span></p></li>
<li><p>那么，我们可以计算得出第 $ i(i=1,2,...,n) $
个评价对象未归一化的得分：  <span class="math inline">\(S_i =
\frac{D_i^-}{D_i^++D_i^-}\)</span></p></li>
<li><p>很明显 <span class="math inline">\(0\leqslant
S_i\leqslant1\)</span>，且 $ S_i $ 越大 $ D_i^+ $
越小，即越接近最大值</p></li>
<li><p>我们可以将得分归一化并换成百分制：     <span
class="math display">\[  S_i = \frac{S_i}{\sum\limits_{i=1}^n S_i}
\times 100\]</span></p></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center;">候选人    </th>
<th style="text-align: center;">颜值    </th>
<th style="text-align: center;">脾气（争吵次数）</th>
<th style="text-align: center;">身高    </th>
<th style="text-align: center;">体重    </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A    </td>
<td style="text-align: center;">0.669    </td>
<td style="text-align: center;">0    </td>
<td style="text-align: center;">0    </td>
<td style="text-align: center;">0    </td>
</tr>
<tr>
<td style="text-align: center;">B    </td>
<td style="text-align: center;">0.595    </td>
<td style="text-align: center;">0.394    </td>
<td style="text-align: center;">0.976    </td>
<td style="text-align: center;">0.447    </td>
</tr>
<tr>
<td style="text-align: center;">C    </td>
<td style="text-align: center;">0.446    </td>
<td style="text-align: center;">0.919    </td>
<td style="text-align: center;">0.217    </td>
<td style="text-align: center;">0.894    </td>
</tr>
</tbody>
</table>
<p><span class="math display">\[\Downarrow\]</span></p>
<table>
<thead>
<tr>
<th style="text-align: center;">候选人</th>
<th style="text-align: center;">得分</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A</td>
<td style="text-align: center;">0.122</td>
</tr>
<tr>
<td style="text-align: center;">B</td>
<td style="text-align: center;">0.624</td>
</tr>
<tr>
<td style="text-align: center;">C</td>
<td style="text-align: center;">0.622</td>
</tr>
</tbody>
</table>
<p><span class="math display">\[\Downarrow\]</span></p>
<table>
<thead>
<tr>
<th style="text-align: center;">候选人</th>
<th style="text-align: center;">得分</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A</td>
<td style="text-align: center;">8.9</td>
</tr>
<tr>
<td style="text-align: center;">B</td>
<td style="text-align: center;">45.7</td>
</tr>
<tr>
<td style="text-align: center;">C</td>
<td style="text-align: center;">45.5</td>
</tr>
</tbody>
</table>
<p><strong>明星K选择了B！！！</strong></p>
<h1 id="topsis法的matlab代码">Topsis法的Matlab代码</h1>
<h2 id="主代码">主代码</h2>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">clear;clc</span><br><span class="line"><span class="comment">%%  1.判断是否需要正向化</span></span><br><span class="line"><span class="comment">% A=[9,10,175,120;8,7,164,80;6,3,157,90]</span></span><br><span class="line">X=input(<span class="string">&#x27;指标矩阵A=&#x27;</span>);    <span class="comment">%%输入判断矩阵</span></span><br><span class="line">[n,m] = <span class="built_in">size</span>(X);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;共有&#x27;</span> num2str(n) <span class="string">&#x27;个评价对象, &#x27;</span> num2str(m) <span class="string">&#x27;个评价指标&#x27;</span>]) </span><br><span class="line">Judge = input([<span class="string">&#x27;这&#x27;</span> num2str(m) <span class="string">&#x27;个指标是否需要经过正向化处理，需要请输入1 ，不需要输入0：  &#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> Judge == <span class="number">1</span></span><br><span class="line">    Position = input(<span class="string">&#x27;请输入需要正向化处理的指标所在的列，例如第2、3、6三列需要处理，那么你需要输入[2,3,6]： &#x27;</span>); <span class="comment">%[2,3,4]</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;请输入需要处理的这些列的指标类型（1：极小型， 2：中间型， 3：区间型） &#x27;</span>)</span><br><span class="line">    Type = input(<span class="string">&#x27;例如：第2列是极小型，第3列是区间型，第6列是中间型，就输入[1,3,2]：  &#x27;</span>); <span class="comment">%[1,2,3]</span></span><br><span class="line">    <span class="comment">% 注意，Position和Type是两个同维度的行向量</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">size</span>(Position,<span class="number">2</span>)  <span class="comment">%这里需要对这些列分别处理，因此我们需要知道一共要处理的次数，即</span></span><br><span class="line">        <span class="comment">% 循环的次数</span></span><br><span class="line">        X(:,Position(<span class="built_in">i</span>)) = Positivization(X(:,Position(<span class="built_in">i</span>)),Type(<span class="built_in">i</span>),Position(<span class="built_in">i</span>));</span><br><span class="line">    <span class="comment">% Positivization是我们自己定义的函数，其作用是进行正向化，其一共接收三个参数</span></span><br><span class="line">    <span class="comment">% 第一个参数是要正向化处理的那一列向量 X(:,Position(i))   回顾上一讲的知识，X(:,n)表示取第n列的全部元素</span></span><br><span class="line">    <span class="comment">% 第二个参数是对应的这一列的指标类型（1：极小型， 2：中间型， 3：区间型）</span></span><br><span class="line">    <span class="comment">% 第三个参数是告诉函数我们正在处理的是原始矩阵中的哪一列</span></span><br><span class="line">    <span class="comment">% 该函数有一个返回值，它返回正向化之后的指标，我们可以将其直接赋值给我们原始要处理的那一列向量</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;正向化后的矩阵 X = &#x27;</span>)</span><br><span class="line">    <span class="built_in">disp</span>(X)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 2.对正向化后的矩阵进行标准化</span></span><br><span class="line">Z = X ./ <span class="built_in">repmat</span>(sum(X.*X) .^ <span class="number">0.5</span>, n, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;标准化矩阵 Z = &#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(Z)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 3.计算与最大值的距离和最小值的距离，并算出得分</span></span><br><span class="line">D_P = sum([(Z - <span class="built_in">repmat</span>(<span class="built_in">max</span>(Z),n,<span class="number">1</span>)) .^ <span class="number">2</span> ],<span class="number">2</span>) .^ <span class="number">0.5</span>;   <span class="comment">% D+ 与最大值的距离向量</span></span><br><span class="line">D_N = sum([(Z - <span class="built_in">repmat</span>(<span class="built_in">min</span>(Z),n,<span class="number">1</span>)) .^ <span class="number">2</span> ],<span class="number">2</span>) .^ <span class="number">0.5</span>;   <span class="comment">% D- 与最小值的距离向量</span></span><br><span class="line">S = D_N ./ (D_P+D_N);    <span class="comment">% 未归一化的得分</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;最后的得分为：&#x27;</span>)</span><br><span class="line">stand_S = <span class="number">100</span>*S / sum(S)</span><br><span class="line">[sorted_S,index] = <span class="built_in">sort</span>(stand_S ,<span class="string">&#x27;descend&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% sort(A)若A是向量不管是列还是行向量，默认都是对A进行升序排列。sort(A)是默认的升序，而sort(A,&#x27;descend&#x27;)是降序排序。</span></span><br><span class="line"><span class="comment">% sort(A)若A是矩阵，默认对A的各列进行升序排列</span></span><br><span class="line"><span class="comment">% sort(A,dim)</span></span><br><span class="line"><span class="comment">% dim=1时等效sort(A)</span></span><br><span class="line"><span class="comment">% dim=2时表示对A中的各行元素升序排列</span></span><br><span class="line"><span class="comment">% A = [2,1,3,8]</span></span><br><span class="line"><span class="comment">% Matlab中给一维向量排序是使用sort函数：sort（A），排序是按升序进行的，其中A为待排序的向量；</span></span><br><span class="line"><span class="comment">% 若欲保留排列前的索引，则可用 [sA,index] = sort(A,&#x27;descend&#x27;) ，排序后，sA是排序好的向量，index是向量sA中对A的索引。</span></span><br><span class="line"><span class="comment">% sA  =  8     3     2     1</span></span><br><span class="line"><span class="comment">% index =  4     3     1     2</span></span><br></pre></td></tr></table></figure>
<h2 id="positivization函数">Positivization函数</h2>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% function [输出变量] = 函数名称(输入变量）  </span></span><br><span class="line"><span class="comment">% 函数的中间部分都是函数体</span></span><br><span class="line"><span class="comment">% 函数的最后要用end结尾</span></span><br><span class="line"><span class="comment">% 输出变量和输入变量可以有多个，用逗号隔开</span></span><br><span class="line"><span class="comment">% function [a,b,c]=test(d,e,f)</span></span><br><span class="line"><span class="comment">%     a=d+e;</span></span><br><span class="line"><span class="comment">%     b=e+f;</span></span><br><span class="line"><span class="comment">%     c=f+d;</span></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line"><span class="comment">% 自定义的函数要单独放在一个m文件中，不可以直接放在主函数里面（和其他大多数语言不同）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Positivization</span><span class="params">(x,type,i)</span></span></span><br><span class="line"><span class="comment">% 输入变量有三个：</span></span><br><span class="line"><span class="comment">% x：需要正向化处理的指标对应的原始列向量</span></span><br><span class="line"><span class="comment">% type： 指标的类型（1：极小型， 2：中间型， 3：区间型）</span></span><br><span class="line"><span class="comment">% i: 正在处理的是原始矩阵中的哪一列</span></span><br><span class="line"><span class="comment">% 输出变量posit_x表示：正向化后的列向量</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span> == <span class="number">1</span>  <span class="comment">%极小型</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列是极小型，正在正向化&#x27;</span>] )</span><br><span class="line">        posit_x = Min2Max(x);  <span class="comment">%调用Min2Max函数来正向化</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列极小型正向化处理完成&#x27;</span>] )</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~&#x27;</span>)</span><br><span class="line">    <span class="keyword">elseif</span> <span class="built_in">type</span> == <span class="number">2</span>  <span class="comment">%中间型</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列是中间型&#x27;</span>] )</span><br><span class="line">        best = input(<span class="string">&#x27;请输入最佳的那一个值： &#x27;</span>);</span><br><span class="line">        posit_x = Mid2Max(x,best);</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列中间型正向化处理完成&#x27;</span>] )</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~&#x27;</span>)</span><br><span class="line">    <span class="keyword">elseif</span> <span class="built_in">type</span> == <span class="number">3</span>  <span class="comment">%区间型</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列是区间型&#x27;</span>] )</span><br><span class="line">        a = input(<span class="string">&#x27;请输入区间的下界： &#x27;</span>);</span><br><span class="line">        b = input(<span class="string">&#x27;请输入区间的上界： &#x27;</span>); </span><br><span class="line">        posit_x = Inter2Max(x,a,b);</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列区间型正向化处理完成&#x27;</span>] )</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;没有这种类型的指标，请检查Type向量中是否有除了1、2、3之外的其他值&#x27;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% % 注意：代码文件仅供参考，一定不要直接用于自己的数模论文中</span></span><br></pre></td></tr></table></figure>
<h2 id="其他函数">其他函数</h2>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Min2Max</span><span class="params">(x)</span></span></span><br><span class="line">    posit_x = <span class="built_in">max</span>(x) - x;</span><br><span class="line">     <span class="comment">%posit_x = 1 ./ x;    %如果x全部都大于0，也可以这样正向化</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Mid2Max</span><span class="params">(x,best)</span></span></span><br><span class="line">    M = <span class="built_in">max</span>(<span class="built_in">abs</span>(x-best));</span><br><span class="line">    posit_x = <span class="number">1</span> - <span class="built_in">abs</span>(x-best) / M;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Inter2Max</span><span class="params">(x,a,b)</span></span></span><br><span class="line">    r_x = <span class="built_in">size</span>(x,<span class="number">1</span>);  <span class="comment">% row of x </span></span><br><span class="line">    M = <span class="built_in">max</span>([a-<span class="built_in">min</span>(x),<span class="built_in">max</span>(x)-b]);</span><br><span class="line">    posit_x = <span class="built_in">zeros</span>(r_x,<span class="number">1</span>);   <span class="comment">%zeros函数用法: zeros(3)  zeros(3,1)  ones(3)</span></span><br><span class="line">    <span class="comment">% 初始化posit_x全为0  初始化的目的是节省处理时间</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: r_x</span><br><span class="line">        <span class="keyword">if</span> x(<span class="built_in">i</span>) &lt; a</span><br><span class="line">           posit_x(<span class="built_in">i</span>) = <span class="number">1</span>-(a-x(<span class="built_in">i</span>))/M;</span><br><span class="line">        <span class="keyword">elseif</span> x(<span class="built_in">i</span>) &gt; b</span><br><span class="line">           posit_x(<span class="built_in">i</span>) = <span class="number">1</span>-(x(<span class="built_in">i</span>)-b)/M;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">           posit_x(<span class="built_in">i</span>) = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h1 id="topsis法的python代码">Topsis法的Python代码</h1>
<p><strong>Python代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  <span class="comment"># 导入numpy库，用于进行科学计算</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从用户输入中接收参评数目和指标数目，并将输入的字符串转换为数值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入参评数目：&quot;</span>)</span><br><span class="line">n = <span class="built_in">eval</span>(<span class="built_in">input</span>())  <span class="comment"># 接收参评数目</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入指标数目：&quot;</span>)</span><br><span class="line">m = <span class="built_in">eval</span>(<span class="built_in">input</span>())  <span class="comment"># 接收指标数目</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收用户输入的类型矩阵，该矩阵指示了每个指标的类型（极大型、极小型等）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入类型矩阵：1:极大型，2：极小型，3：中间型，4：区间型&quot;</span>)</span><br><span class="line">kind = <span class="built_in">input</span>().split(<span class="string">&quot; &quot;</span>)  <span class="comment"># 将输入的字符串按空格分割，形成列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收用户输入的矩阵并转换为numpy数组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入矩阵：&quot;</span>)</span><br><span class="line">A = np.zeros(shape=(n, m))  <span class="comment"># 初始化一个n行m列的全零矩阵A</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    A[i] = <span class="built_in">input</span>().split(<span class="string">&quot; &quot;</span>)  <span class="comment"># 接收每行输入的数据</span></span><br><span class="line">    A[i] = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">float</span>, A[i]))  <span class="comment"># 将接收到的字符串列表转换为浮点数列表</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入矩阵为：\n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(A))  <span class="comment"># 打印输入的矩阵A</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 极小型指标转化为极大型指标的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">minTomax</span>(<span class="params">maxx, x</span>):</span><br><span class="line">    x = <span class="built_in">list</span>(x)  <span class="comment"># 将输入的指标数据转换为列表</span></span><br><span class="line">    ans = [[(maxx-e)] <span class="keyword">for</span> e <span class="keyword">in</span> x]  <span class="comment"># 计算最大值与每个指标值的差，并将其放入新列表中</span></span><br><span class="line">    <span class="keyword">return</span> np.array(ans)  <span class="comment"># 将列表转换为numpy数组并返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 中间型指标转化为极大型指标的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">midTomax</span>(<span class="params">bestx, x</span>):</span><br><span class="line">    x = <span class="built_in">list</span>(x)  <span class="comment"># 将输入的指标数据转换为列表</span></span><br><span class="line">    h = [<span class="built_in">abs</span>(e-bestx) <span class="keyword">for</span> e <span class="keyword">in</span> x]  <span class="comment"># 计算每个指标值与最优值之间的绝对差</span></span><br><span class="line">    M = <span class="built_in">max</span>(h)  <span class="comment"># 找到最大的差值</span></span><br><span class="line">    <span class="keyword">if</span> M == <span class="number">0</span>:</span><br><span class="line">        M = <span class="number">1</span>  <span class="comment"># 防止最大差值为0的情况</span></span><br><span class="line">    ans = [[(<span class="number">1</span>-e/M)] <span class="keyword">for</span> e <span class="keyword">in</span> h]  <span class="comment"># 计算每个差值占最大差值的比例，并从1中减去，得到新指标值</span></span><br><span class="line">    <span class="keyword">return</span> np.array(ans)  <span class="comment"># 返回处理后的numpy数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 区间型指标转化为极大型指标的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">regTomax</span>(<span class="params">lowx, highx, x</span>):</span><br><span class="line">    x = <span class="built_in">list</span>(x)  <span class="comment"># 将输入的指标数据转换为列表</span></span><br><span class="line">    M = <span class="built_in">max</span>(lowx-<span class="built_in">min</span>(x), <span class="built_in">max</span>(x)-highx)  <span class="comment"># 计算指标值超出区间的最大距离</span></span><br><span class="line">    <span class="keyword">if</span> M == <span class="number">0</span>:</span><br><span class="line">        M = <span class="number">1</span>  <span class="comment"># 防止最大距离为0的情况</span></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)):</span><br><span class="line">        <span class="keyword">if</span> x[i]&lt;lowx:</span><br><span class="line">            ans.append([(<span class="number">1</span>-(lowx-x[i])/M)])  <span class="comment"># 如果指标值小于下限，则计算其与下限的距离比例</span></span><br><span class="line">        <span class="keyword">elif</span> x[i]&gt;highx:</span><br><span class="line">            ans.append([(<span class="number">1</span>-(x[i]-highx)/M)])  <span class="comment"># 如果指标值大于上限，则计算其与上限的距离比例</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans.append([<span class="number">1</span>])  <span class="comment"># 如果指标值在区间内，则直接取为1</span></span><br><span class="line">    <span class="keyword">return</span> np.array(ans)  <span class="comment"># 返回处理后的numpy数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统一指标类型，将所有指标转化为极大型指标</span></span><br><span class="line">X = np.zeros(shape=(n, <span class="number">1</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    <span class="keyword">if</span> kind[i]==<span class="string">&quot;1&quot;</span>:  <span class="comment"># 如果当前指标为极大型，则直接使用原值</span></span><br><span class="line">        v = np.array(A[:, i])</span><br><span class="line">    <span class="keyword">elif</span> kind[i]==<span class="string">&quot;2&quot;</span>:  <span class="comment"># 如果当前指标为极小型，调用minTomax函数转换</span></span><br><span class="line">        maxA = <span class="built_in">max</span>(A[:, i])</span><br><span class="line">        v = minTomax(maxA, A[:, i])</span><br><span class="line">    <span class="keyword">elif</span> kind[i]==<span class="string">&quot;3&quot;</span>:  <span class="comment"># 如果当前指标为中间型，调用midTomax函数转换</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;类型三：请输入最优值：&quot;</span>)</span><br><span class="line">        bestA = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">        v = midTomax(bestA, A[:, i])</span><br><span class="line">    <span class="keyword">elif</span> kind[i]==<span class="string">&quot;4&quot;</span>:  <span class="comment"># 如果当前指标为区间型，调用regTomax函数转换</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;类型四：请输入区间[a, b]值a：&quot;</span>)</span><br><span class="line">        lowA = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;类型四：请输入区间[a, b]值b：&quot;</span>)</span><br><span class="line">        highA = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">        v = regTomax(lowA, highA, A[:, i])</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">0</span>:</span><br><span class="line">        X = v.reshape(-<span class="number">1</span>, <span class="number">1</span>)  <span class="comment"># 如果是第一个指标，直接替换X数组</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        X = np.hstack([X, v.reshape(-<span class="number">1</span>, <span class="number">1</span>)])  <span class="comment"># 如果不是第一个指标，则将新指标列拼接到X数组上</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;统一指标后矩阵为：\n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(X))  <span class="comment"># 打印处理后的矩阵X</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对统一指标后的矩阵X进行标准化处理</span></span><br><span class="line">X = X.astype(<span class="string">&#x27;float&#x27;</span>)  <span class="comment"># 确保X矩阵的数据类型为浮点数</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    X[:, j] = X[:, j]/np.sqrt(<span class="built_in">sum</span>(X[:, j]**<span class="number">2</span>))  <span class="comment"># 对每一列数据进行归一化处理，即除以该列的欧几里得范数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;标准化矩阵为：\n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(X))  <span class="comment"># 打印标准化后的矩阵X</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大值最小值距离的计算</span></span><br><span class="line">x_max = np.<span class="built_in">max</span>(X, axis=<span class="number">0</span>)  <span class="comment"># 计算标准化矩阵每列的最大值</span></span><br><span class="line">x_min = np.<span class="built_in">min</span>(X, axis=<span class="number">0</span>)  <span class="comment"># 计算标准化矩阵每列的最小值</span></span><br><span class="line">d_z = np.sqrt(np.<span class="built_in">sum</span>(np.square((X - np.tile(x_max, (n, <span class="number">1</span>)))), axis=<span class="number">1</span>))  <span class="comment"># 计算每个参评对象与最优情况的距离d+</span></span><br><span class="line">d_f = np.sqrt(np.<span class="built_in">sum</span>(np.square((X - np.tile(x_min, (n, <span class="number">1</span>)))), axis=<span class="number">1</span>))  <span class="comment"># 计算每个参评对象与最劣情况的距离d-</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;每个指标的最大值:&#x27;</span>, x_max)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;每个指标的最小值:&#x27;</span>, x_min)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;d+向量:&#x27;</span>, d_z)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;d-向量:&#x27;</span>, d_f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每个参评对象的得分排名</span></span><br><span class="line">s = d_f/(d_z+d_f)  <span class="comment"># 根据d+和d-计算得分s，其中s接近于1则表示较优，接近于0则表示较劣</span></span><br><span class="line">Score = <span class="number">100</span>*s/<span class="built_in">sum</span>(s)  <span class="comment"># 将得分s转换为百分制，便于比较</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Score)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;第<span class="subst">&#123;i+<span class="number">1</span>&#125;</span>个标准化后百分制得分为：<span class="subst">&#123;Score[i]&#125;</span>&quot;</span>)  <span class="comment"># 打印每个参评对象的得分</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p align="right">
<strong>内容编辑：云舒宇，侯邵华，杜灯</strong>
</p>
<p align="right">
<strong>内容审核：王颖</strong><span
class="math inline">\(\qquad\qquad\qquad\quad\)</span>
</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/10/15/AnalyticHierarchyProcess/" rel="prev" title="层次分析算法">
                  <i class="fa fa-angle-left"></i> 层次分析算法
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2026/01/17/GreyRelationalAnalysis/" rel="next" title="灰色关联分析算法">
                  灰色关联分析算法 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">John Doe</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
