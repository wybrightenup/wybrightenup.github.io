<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":"all","tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/01/19/FuzzyComprehensiveEvaluation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2026/01/19/FuzzyComprehensiveEvaluation/" class="post-title-link" itemprop="url">模糊综合评价法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2026-01-19 11:57:16" itemprop="dateCreated datePublished" datetime="2026-01-19T11:57:16+08:00">2026-01-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-02-13 11:31:33" itemprop="dateModified" datetime="2026-02-13T11:31:33+08:00">2026-02-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="模型引出">模型引出</h1>
<h2 id="模糊数学">模糊数学</h2>
<ul>
<li><p>如果我们问一个人的性别、身高、体重，可能很容易的得到答案，性别一般而言非男即女，身高和体重是可以精确测量的，这些是<strong>确定性概念</strong></p></li>
<li><p>但是如果问到大与小，长与短，美与丑等概念，就不好确定了，多大算大？多小算小？多长算长？怎么界定美丑？这种问题感觉有点儿抬杠似的，不过正是因为没有一个精确的范围，我们只能发出这样的疑问，这些就是<strong>模糊性概念</strong></p></li>
</ul>
<p>模糊是指客观事物差异的中间过渡中的“不分明性”或“亦此亦彼性”。如高个子与矮个子、年轻人与老年人、热水与凉水、环境污染严重与不严重等。在决策中，也有这种模糊的现象，如选举一个好干部，但怎样才算一个好干部？好干部与不好干部之间没有绝对分明和固定不变的界限。这些现象很难用经典的数学来描述。</p>
<p>实际中，我们处理现实的数学模型可以分成三大类：第一类是<strong>确定性数学模型</strong>，即模型的背景具有确定性，对象之间具有必然的关系。第二类是<strong>随机性的数学模型</strong>，即模型的背景具有随机性和偶然性。第三类是<strong>模糊性模型</strong>，即模型的背景及关系具有模糊性。</p>
<p>1965年，美国著名计算机与控制专家查德（L.A.Zadeh）教授提出了模糊的概念，并在国际期刊《Information
and Control》发表了第一篇用数学方法研究模糊现象的论文“Fuzzy
Sets”（模糊集合），开创了模糊数学的新领域。</p>
<h1 id="模型原理">模型原理</h1>
<h2 id="经典集合基本概念">经典集合基本概念</h2>
<ul>
<li><p>集合：具有<strong>相同属性的事物</strong>的集体，例如：自然数集、实数集、颜色等<br />
</p></li>
<li><p>集合的基本属性：<br />
1）<strong>互斥性</strong>：若 <span class="math inline">\(a\in A,b\in
A\)</span> 则 <span class="math inline">\(a\neq b\)</span><br />
2）<strong>确定性</strong>：<span class="math inline">\(a\in A, a\notin
A\)</span> 且仅有之一发生（非此即彼）<br />
</p></li>
<li><p>数学上对于经典集合的刻画，特征函数：<span
class="math inline">\(f_A:U\rightarrow\{0,1\}\)</span><br />
<span class="math inline">\(U\)</span>:论域<br />
<span class="math inline">\(f_A\)</span>表示集合<span
class="math inline">\(A\)</span>的特征函数</p>
<p>比如，<span
class="math inline">\(A\)</span>为全班成绩及格的集合，<span
class="math inline">\(U\)</span>为全班成绩的集合，则<span
class="math inline">\(\forall x\in U\)</span>，<span
class="math inline">\(f_A(x)=\begin{cases}
1, &amp; x \in A \\
0, &amp; x \notin A
\end{cases}\)</span></p></li>
</ul>
<h2 id="模糊集合和隶属函数">模糊集合和隶属函数</h2>
<ul>
<li>模糊集合：用来描述模糊性概念的集合（美、丑、高、矮、年轻、年长）<br />
</li>
<li>与经典集合相比，模糊集合<strong>承认亦此亦彼</strong><br />
</li>
<li>数学上对于模糊集合的刻画：</li>
</ul>
<p><strong>隶属函数</strong>：<span class="math inline">\(\mu_A: X
\rightarrow [0,1]\)</span>，（注意这里是一个区间）<span
class="math inline">\(x \rightarrow\mu_A(x)\)</span><br />
确定 $ X $ 上的一个模糊集合 <span
class="math inline">\(A\)</span>，<span
class="math inline">\(\mu_A\)</span> 叫做 <span
class="math inline">\(A\)</span> 的隶属函数，<span
class="math inline">\(\mu_A(x)\)</span> 叫做 <span
class="math inline">\(x\)</span> 对模糊集<span
class="math inline">\(A\)</span>的隶属度。<br />
记为：<br />
<span class="math display">\[A=\{(x,\mu_A(x))|x \in X\}\]</span><br />
显然，模糊集合<span
class="math inline">\(A\)</span>完全由隶属函数来刻画， <span
class="math inline">\(\mu_A(x)=0.5\)</span> 最具模糊性。</p>
<ul>
<li><p>举一个简单的例子，我们要衡量“年轻”的概念 <span
class="math inline">\(A=\text{“年轻”}\)</span>，<span
class="math inline">\(X=(0,150)\)</span> 表示年龄的集合。<br />
在这里我们不好直接在 0-150
之间画个线把年轻和不年轻区分开，我们应该给一个隶属函数来进行描述。</p></li>
<li><p>定义隶属函数</p></li>
</ul>
<p><span class="math display">\[\mu_A(x) =
\begin{cases}
1, &amp; 0 &lt; x &lt; 20 \\
\frac{40 - x}{20}, &amp; 20 \leqslant x \leqslant 40 \\
0, &amp; 40 &lt; x &lt; 150
\end{cases}\]</span></p>
<p>对于 $ X $ 中的每一个元素，均对应 $ A $ 中的一个隶属度，隶属度介于
<span class="math inline">\([0,1]\)</span>，越大表示越属于这个集合</p>
<ul>
<li><p>上面的隶属函数，只是为了方便理解随意构造出来的，并不等同于真实的调查结果，但是依然反映了构造者的主观想法。事实上，隶属函数也不是唯一的，不同的人，不同大小的样本，得出的隶属函数很可能是不同的。</p></li>
<li><p>简单来说，我理解的隶属度，就是元素属于某个模糊集合的程度，而隶属函数就是用来确定隶属度的函数。</p></li>
</ul>
<h2 id="模糊集合的表示方法">模糊集合的表示方法</h2>
<ul>
<li><p>当论域<span class="math inline">\(X\)</span>为有限集时，记 <span
class="math inline">\(X=\{x_1,x_2,\ldots,x_n\}\)</span>，则<span
class="math inline">\(X\)</span>上的模糊集<span
class="math inline">\(A\)</span>有三种表示形式</p>
<p>1）zadeh表示法 <span class="math display">\[   A = \sum_{i=1}^{n}
\frac{\mu_A(x_i)}{x_i} = \frac{\mu_A(x_1)}{x_1} + \cdots +
\frac{\mu_A(x_n)}{x_n}\]</span> 注：“<span
class="math inline">\(\sum\)</span>”
和“+”不是求和的意思，只是概括集合的记号; <span
class="math inline">\(\frac{\mu_A
(x_i)}{x_i}\)</span>也不是分数，它表示点<span
class="math inline">\(x_i\)</span>对模糊集<span
class="math inline">\(A\)</span>的隶属度是<span
class="math inline">\(\mu_A(x_i)\)</span></p>
<p>2）序偶表示法 <span class="math display">\[   A = \{(x_1,
\mu_A(x_1)), (x_2, \mu_A(x_2)), \ldots, (x_n, \mu_A(x_n))\}\]</span></p>
<p>3）向量表示法 <span class="math display">\[   A = (\mu_A(x_1),
\mu_A(x_2), \ldots, \mu_A(x_n))\]</span></p></li>
<li><p>当论域<span class="math inline">\(X\)</span>为无限集时，则<span
class="math inline">\(X\)</span>上的模糊集<span
class="math inline">\(A\)</span>可以写成 <span
class="math display">\[   A = \int\limits_{\substack{x \in X}}
\frac{\mu_A(x)}{x};\]</span> 注：“<span
class="math inline">\(\int\)</span>”不是积分的意思，<span
class="math inline">\(\frac{\mu_A(x)}{x}\)</span>也不是分数，它是表示某个元素所对应的隶属度。</p></li>
</ul>
<h2 id="模糊集合的表示方法-1">模糊集合的表示方法</h2>
<ul>
<li>例1：设论域 <span
class="math inline">\(X=\{x_1(140),x_2(150),x_3(160),x_4(170),x_5(180),x_6(190)\}\)</span>（单位：cm）表示人的身高，<span
class="math inline">\(X\)</span> 上的一个模糊集“高个子”（<span
class="math inline">\(A\)</span>）的隶属函数定义为 $_A(x)= $</li>
</ul>
<ol type="1">
<li><p>zadeh表示法<br />
<span class="math display">\[   A = \frac{0}{x_1} + \frac{0.2}{x_2} +
\frac{0.4}{x_3} + \frac{0.6}{x_4} + \frac{0.8}{x_5} +
\frac{1}{x_6}\]</span></p></li>
<li><p>序偶表示法<br />
<span class="math display">\[   A = \{(140, 0), (150, 0.2), (160, 0.4),
(170, 0.6), (180, 0.8), (190, 1)\}\]</span></p></li>
<li><p>向量表示法<br />
<span class="math display">\[   A = (0, 0.2, 0.4, 0.6, 0.8,
1)\]</span></p></li>
</ol>
<ul>
<li>例2：设论域 $ X = [0, 1] $，模糊集 $ A $ 表示年轻，$ A $
的隶属函数定义为<br />
<span class="math display">\[   \mu_x =
  \begin{cases}
  1 &amp; 0 \leqslant x \leqslant 25 \\
  \left[ 1 + \left( \frac{x - 25}{5} \right)^2 \right]^{-1} &amp; 25
&lt; x \leqslant 100
  \end{cases}\]</span> <span class="math display">\[   A = \text{年轻} =
\int_{0}^{25} \frac{1}{x}  + \int_{25}^{100} \frac{\left[1 + \left(
\frac{x - 25}{5} \right)^2\right]^{-1}}{x} \]</span></li>
</ul>
<h2 id="模糊集合的分类">模糊集合的分类</h2>
<ul>
<li>模糊集合主要有三类，分别为<strong>偏小型、中间型和偏大型</strong>。其实也就类似于TOPSIS方法中的极大型、极小型、中间型、区间型指标。</li>
</ul>
<p>举个例子，“年轻”就是一个偏小型的模糊集合，因为岁数越小，隶属度越大，就越“年轻”；“年轻”则是一个偏大型的模糊集合，岁数越大，隶属度越大，越“年轻”；而“中年”则是一个中间型集合，岁数只有处在某个中间的范围，隶属度才越大。总结来说，就是考虑“元素”与“隶属度”的关系，再类比一下，就是考虑隶属函数的单调性。</p>
<ul>
<li>下图可以代表“年轻”、“中年”、“年轻”这三个模糊集合的隶属函数图像</li>
</ul>
<p><img src="/images/FuzzyComprehensiveEvaluation/FuzzyComprehensiveEvaluation2.png" alt="举例示意图" style="width: 100%;"></p>
<ul>
<li>不管模糊集合是哪一种类型，<strong>隶属度越大，属于这个集合的程度也越大</strong>。</li>
</ul>
<h2 id="隶属函数的确定方法">隶属函数的确定方法</h2>
<h3 id="模糊统计法">1）模糊统计法</h3>
<p>模糊统计法的原理是，找多个人对同一个模糊概念进行描述，用<strong>隶属频率</strong>去定义隶属度。</p>
<p>例如我们想知道30岁相对于“年轻”的隶属度，那就找<span
class="math inline">\(n\)</span>个人问一问，如果其中有<span
class="math inline">\(m\)</span>个人认为30岁属于“年轻”的范畴，那<span
class="math inline">\(m/n\)</span>就可以用来作为30岁相对于“年轻”的隶属度。<span
class="math inline">\(n\)</span>越大时，越符合实际情况，也就越准确。</p>
<p>这个方法比较符合实际情况，但是往往通过发放问卷或者其他手段进行调查，数学建模比赛时，时间有限，所以仅做介绍，基本不予采用。</p>
<h3 id="借助已有的客观尺度">2）借助已有的客观尺度</h3>
<p>对于某些模糊集合，我们可以用<strong>已经有的指标</strong>去作为元素的隶属度。</p>
<p>例如“小康家庭”这个模糊集合，就可以用“恩格尔系数（食品支出总额/家庭总支出）”衡量相应的隶属度。显而易见，家庭越接近小康水平，其恩格尔系数应该越低，那么“1<span
class="math inline">\(-\)</span>恩格尔系数”就越大，我们便可以把“1<span
class="math inline">\(-\)</span>恩格尔系数”看作家庭相对于“小康家庭”的隶属度。</p>
<p>对于“质量稳定”这一模糊集合，我们可以使用正品率衡量隶属度。</p>
<p>注意：隶属度是在[0,1]之间的。如果找的指标不在，可以进行归一化处理。</p>
<h3 id="指派法">3）指派法</h3>
<p>指派法是一个主观性比较强的方法，即凭<strong>主观意愿</strong>，在确定模糊集合的所属分类后，给它<strong>指派一个隶属函数</strong>，得到元素的隶属度。这是比赛中最常用的方法之一，只需进行选择，便可得到隶属函数。下边是常用的模糊分布：</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;">类型</th>
<th style="text-align: center;">偏小型</th>
<th style="text-align: center;">中间型</th>
<th style="text-align: center;">偏大型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>矩阵型</strong></td>
<td style="text-align: center;"><span class="math display">\[\mu_A =
\begin{cases} 1, &amp; x \leqslant a \\ 0, &amp; x &gt; a
\end{cases}\]</span></td>
<td style="text-align: center;"><span class="math display">\[\mu_A =
\begin{cases} 1, &amp; a \leqslant x \leqslant b \\ 0, &amp; x &lt; a
\text{或} x &gt; b \end{cases}\]</span></td>
<td style="text-align: center;"><span class="math display">\[\mu_A =
\begin{cases} 1, &amp; x \geqslant a \\ 0, &amp; x &lt; a
\end{cases}\]</span></td>
</tr>
<tr>
<td style="text-align: center;"><strong>梯形型</strong></td>
<td style="text-align: center;"><span class="math display">\[\mu_A =
\begin{cases} 1, &amp; x \leqslant a \\ \frac{b-x}{b-a}, &amp; a
\leqslant x \leqslant b \\ 0, &amp; x &gt; b \end{cases}\]</span></td>
<td style="text-align: center;"><span class="math display">\[\mu_A =
\begin{cases} \frac{x-a}{b-a}, &amp; a \leqslant x \leqslant b \\ 1,
&amp; b \leqslant x \leqslant c \\ \frac{d-x}{d-c}, &amp; c \leqslant x
\leqslant d \\ 0, &amp; x &lt; a, x \geqslant d
\end{cases}\]</span></td>
<td style="text-align: center;"><span class="math display">\[\mu_A =
\begin{cases} 0, &amp; x &lt; a \\ \frac{x-a}{b-a}, &amp; a \leqslant x
\leqslant b \\ 1, &amp; x &gt; b \end{cases}\]</span></td>
</tr>
<tr>
<td style="text-align: center;"><strong><span
class="math inline">\(k\)</span>次抛物型</strong></td>
<td style="text-align: center;"><span class="math display">\[\mu_A =
\begin{cases} 1, &amp; x \leqslant a \\ \left( \frac{b-x}{b-a}
\right)^k, &amp; a \leqslant x \leqslant b \\ 0, &amp; x &gt; b
\end{cases}\]</span></td>
<td style="text-align: center;"><span class="math display">\[\mu_A =
\begin{cases} \left( \frac{x-a}{b-a} \right)^k, &amp; a \leqslant x
\leqslant b \\ \left( \frac{d-x}{d-c} \right)^k, &amp; c \leqslant x
\leqslant d \\ 0, &amp; x &lt; a, x \geqslant d
\end{cases}\]</span></td>
<td style="text-align: center;"><span class="math display">\[\mu_A =
\begin{cases} 0, &amp; x &lt; a \\ \left( \frac{x-a}{b-a} \right)^k,
&amp; a \leqslant x \leqslant b \\ 1, &amp; x &gt; b
\end{cases}\]</span></td>
</tr>
<tr>
<td style="text-align: center;"><strong><span
class="math inline">\(\Gamma\)</span>型</strong></td>
<td style="text-align: center;"><span class="math display">\[\mu_A =
\begin{cases} 1, &amp; x \leqslant a \\ e^{-k(x-a)}, &amp; x &gt; a
\end{cases}\]</span></td>
<td style="text-align: center;"><span class="math display">\[\mu_A =
\begin{cases} e^{k(x-a)}, &amp; x &lt; a \\ 1, &amp; a \leqslant x
\leqslant b \\ e^{-k(x-a)}, &amp; x &gt; b \end{cases}\]</span></td>
<td style="text-align: center;"><span class="math display">\[\mu_A =
\begin{cases} 0, &amp; x &lt; a \\ 1 - e^{-k(x-a)}, &amp; x \geqslant a
\end{cases}\]</span></td>
</tr>
<tr>
<td style="text-align: center;"><strong>正态型</strong></td>
<td style="text-align: center;"><span class="math display">\[\mu_A =
\begin{cases} 1, &amp; x \leqslant a \\ \exp\left\{ -\left(
\frac{x-a}{\sigma} \right)^2 \right\}, &amp; x &gt; a
\end{cases}\]</span></td>
<td style="text-align: center;"><span class="math display">\[\mu_A =
\exp\left\{ -\left( \frac{x-a}{\sigma} \right)^2 \right\}\]</span></td>
<td style="text-align: center;"><span class="math display">\[\mu_A =
\begin{cases} 0, &amp; x \leqslant a \\ 1 - \exp\left\{ -\left(
\frac{x-a}{\sigma} \right)^2 \right\}, &amp; x &gt; a
\end{cases}\]</span></td>
</tr>
<tr>
<td style="text-align: center;"><strong>柯西型</strong></td>
<td style="text-align: center;"><span class="math display">\[\mu_A =
\begin{cases} 1, &amp; x \leqslant a \\ \frac{1}{1 + \alpha
(x-a)^{\beta}}, &amp; x &gt; a \end{cases}\]</span> <span
class="math display">\[(\alpha &gt; 0, \beta &gt; 0)\]</span></td>
<td style="text-align: center;"><span class="math display">\[\mu_A =
\frac{1}{1 + \alpha (x-a)^{\beta}}\]</span> <span
class="math display">\[(\alpha &gt; 0, \beta
\text{为正偶数})\]</span></td>
<td style="text-align: center;"><span class="math display">\[\mu_A =
\begin{cases} 0, &amp; x \leqslant a \\ \frac{1}{1 + \alpha
(x-a)^{-\beta}}, &amp; x &gt; a \end{cases}\]</span> <span
class="math display">\[(\alpha &gt; 0, \beta &gt; 0)\]</span></td>
</tr>
</tbody>
</table>
<p>可以看出，对于偏小型模糊集合，隶属函数总体上递减，也就是元素的某个特征越大，隶属度越小；对于偏大型集合，隶属函数总体上递增，也就是元素的某个特征越大，隶属度越大；对于中间型集合，隶属函数总体上先递增后递减，中间一部分或是某个点取到最大值。</p>
<p>以上就是确定隶属函数的几种方法了。还有一些其他的方法，比如德尔菲法、二元对比排序法、综合加权法等等，有兴趣可以自己查阅。</p>
<h2 id="评价问题概述">评价问题概述</h2>
<ul>
<li>模糊评价问题是要把论域中的对象对应评语集中一个指定的评语或者将方案作为评语集并选择一个最优的方案。</li>
<li>在模糊综合评价中，引入三个集合：
<ul>
<li>①因素集（评价指标集） <span
class="math inline">\(U=\{u_1,u_2,\cdots,u_n\}\)</span></li>
<li>②评语集（评价的结果） <span
class="math inline">\(V=\{v_1,v_2,\cdots,v_n\}\)</span></li>
<li>③权重集（指标的权重） <span
class="math inline">\(A=\{a_1,a_2,\cdots,a_n\}\)</span></li>
</ul></li>
<li>例：评价一名学生的表现
<ul>
<li>$ U = $ {专业排名，课外实践，志愿服务，竞赛成绩}</li>
<li>$ V = $ {优，良，差}<br />
</li>
<li><span class="math inline">\(A=\{0.4,0.2,0.1,0.3\}\)</span></li>
</ul></li>
<li>模糊综合评价模型就是给定对象，用因素集的指标进行评价，从评语集中找到一个最适合它的评语。如果评语集中是方案的话，就是选出一个最恰当的方案。那这种<strong>合适”</strong>用什么来衡量呢？显而易见嘛，就是<strong>隶属度</strong>，隶属于某个模糊集合的程度。</li>
</ul>
<h1 id="典型例题">典型例题</h1>
<h2 id="一级模糊综合评价模型">一级模糊综合评价模型</h2>
<h3 id="例1在对企业员工进行考核时">例1：在对企业员工进行考核时</h3>
<p>在指标个数较少的考核中，可以运用一级模糊综合评判。</p>
<ul>
<li><p>1）确定因素集：评判的因素构成的评价指标体系集合称为因素集。</p>
<p>对员工的表现，需要从多个方面进行综合评判，如员工的工作业绩、工作态度、沟通能力、政治表现等。</p>
<p>记为 <span
class="math inline">\(U=\{u_1,u_2,\cdots,u_n\}\)</span></p>
<p>这里取因素集 <span
class="math inline">\(U=\{政治表现u_1,工作能力u_2,工作态度u_3,工作成绩u_4\}\)</span></p></li>
<li><p>2）确定评语集：由各种不同决策构成的集合称为评语集。</p>
<p>评价往往有不同的等级，对员工评价可能有好、较好、中等、较差、很差等</p>
<p>记为 <span
class="math inline">\(V=\{v_1,v_2,\cdots,v_m\}\)</span></p>
<p>这里取评语集 <span
class="math inline">\(V=\{优秀v_1,良好v_2,一般v_3,较差v_4,差v_5\}\)</span></p></li>
<li><p>3）确定各因素的权重：因素集中各因素的评价中作用不同，需要确定权重，它是<span
class="math inline">\(U\)</span>上的模糊向量判断权重的方法很多，如Delphi法等，也可以用我们学习过的层次分析法和熵权法来确定权重。</p>
<p>记为 $ A = [a_1, a_2, ..., a_n] $ 这里取 $ A = [0.25, 0.2, 0.25, 0.3]
$</p></li>
<li><p>4）确定模糊综合判断矩阵。</p>
<p>对指标<span
class="math inline">\(u_i\)</span>来说，对各个评语的隶属度为<span
class="math inline">\(V\)</span>上的模糊子集，对指标<span
class="math inline">\(u_i\)</span>的评判记为 记为 <span
class="math inline">\(R_i = [r_{i1}, r_{i2}, \ldots,
r_{im}]\)</span></p>
<p>各指标的模糊综合判断矩阵为 <span class="math display">\[  R =
  \begin{bmatrix}
  r_{11} &amp; r_{12} &amp; \cdots &amp; r_{1m} \\
  r_{21} &amp; r_{22} &amp; \cdots &amp; r_{2m} \\
  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
  r_{n1} &amp; r_{n2} &amp; \cdots &amp; r_{nm}
  \end{bmatrix}\]</span></p>
<p>这是一个从<span class="math inline">\(U\)</span>到<span
class="math inline">\(V\)</span>的模糊关系矩阵。</p></li>
</ul>
<p>对员工的评定如果由模糊统计法来确定：</p>
<ul>
<li><p>1）<span class="math inline">\(u_1\)</span>比如由群众打分确定
<span class="math display">\[  r_1 = [0.1, 0.5, 0.4, 0, 0]\]</span></p>
<p>上式表示，参与打分的群众中，10%的人认为该员工政治表现优秀，50%的人认为其政治表现良好等</p></li>
<li><p>2）$ u_2, u_3 $ 由部门领导打分来确定 <span
class="math display">\[    r_2 = [0.2, 0.5, 0.2, 0.1, 0] \quad r_3 =
[0.2, 0.5, 0.3, 0, 0]\]</span></p></li>
<li><p>3）$ u_4 $ 由单位考核组成员打分来确定 <span
class="math display">\[    r_4 = [0.2, 0.6, 0.2, 0, 0]\]</span> 形成以 $
R_i $ 为第 $ i $ 行构成评价矩阵（模糊综合判断矩阵） <span
class="math display">\[    R =
  \begin{bmatrix}
  0.1 &amp; 0.5 &amp; 0.4 &amp; 0 &amp;0 \\
  0.2 &amp; 0.5 &amp; 0.2 &amp; 0.1 &amp;0\\
  0.2 &amp; 0.5 &amp; 0.3 &amp; 0  &amp;0\\
  0.2 &amp; 0.6 &amp; 0.2 &amp; 0  &amp;0
  \end{bmatrix}\]</span></p></li>
<li><p>5）模糊综合评判，进行矩阵合成运算： <span
class="math display">\[    B = A \cdot R = [0.25, 0.2, 0.25,
0.3]\cdot\begin{bmatrix}
  0.1 &amp; 0.5 &amp; 0.4 &amp; 0 &amp;0\\
  0.2 &amp; 0.5 &amp; 0.2 &amp; 0.1 &amp;0\\
  0.2 &amp; 0.5 &amp; 0.3 &amp; 0  &amp;0\\
  0.2 &amp; 0.6 &amp; 0.2 &amp; 0  &amp;0
  \end{bmatrix} =
  \begin{bmatrix}
  0.175, 0.53, 0.275, 0.02, 0
  \end{bmatrix}\]</span>
取数值最大的评语作为综合评判结果，则评判结果为“良好”。</p></li>
</ul>
<h3
id="例2某露天煤矿有五个边坡设计方案">例2：某露天煤矿有五个边坡设计方案</h3>
<p>其各项参数根据分析计算结果得到边坡设计方案如下表：</p>
<table>
<thead>
<tr>
<th style="text-align: center;">项目</th>
<th style="text-align: center;">方案1</th>
<th style="text-align: center;">方案2</th>
<th style="text-align: center;">方案3</th>
<th style="text-align: center;">方案4</th>
<th style="text-align: center;">方案5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">可采矿量/万吨</td>
<td style="text-align: center;">4700</td>
<td style="text-align: center;">6700</td>
<td style="text-align: center;">5900</td>
<td style="text-align: center;">8800</td>
<td style="text-align: center;">7600</td>
</tr>
<tr>
<td style="text-align: center;">基建投资/万元</td>
<td style="text-align: center;">5000</td>
<td style="text-align: center;">5500</td>
<td style="text-align: center;">5300</td>
<td style="text-align: center;">6800</td>
<td style="text-align: center;">6000</td>
</tr>
<tr>
<td style="text-align: center;">采矿成本/（元/吨）</td>
<td style="text-align: center;">4.0</td>
<td style="text-align: center;">6.1</td>
<td style="text-align: center;">5.5</td>
<td style="text-align: center;">7.0</td>
<td style="text-align: center;">6.8</td>
</tr>
<tr>
<td style="text-align: center;">不稳定费用/万元</td>
<td style="text-align: center;">30</td>
<td style="text-align: center;">50</td>
<td style="text-align: center;">40</td>
<td style="text-align: center;">200</td>
<td style="text-align: center;">160</td>
</tr>
<tr>
<td style="text-align: center;">净现值/万元</td>
<td style="text-align: center;">1500</td>
<td style="text-align: center;">700</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">50</td>
<td style="text-align: center;">100</td>
</tr>
</tbody>
</table>
<ul>
<li><p>据勘探，该矿探明储量8800吨，开采总投资不超过8000万元，试做出各方案的优劣排序，选出最佳方案</p>
<p>1）首先确定可采矿量的隶属函数
因为勘探的储量为8800吨，故可用资源的利用函数作为隶属函数 <span
class="math display">\[\mu_A(x) = \frac{x}{8800}\]</span></p>
<p>2）基建投资的隶属函数<br />
投资约束是8000万元，所以<br />
<span class="math display">\[\mu_{B}(x) = 1 -
\frac{x}{8000}\]</span></p>
<p>3）采矿成本的隶属函数<br />
根据专家意见，采矿成本 $ a_1 $ 元/吨为低成本，$ a_2 = 8.0 $
元/吨为高成本，故<br />
<span class="math display">\[\mu_{e}(x) =
\begin{cases}
1, &amp; 0 \leqslant x \leqslant a_1 \\
\frac{a_2 - x}{a_2 - a_1}, &amp; a_1 \leqslant x \leqslant a_2 \\
0, &amp; a_2 &lt; x
\end{cases}\]</span></p>
<p>4）不稳定费用的隶属函数<br />
<span class="math display">\[\mu_{D}(x) = 1 - \frac{x}{200}\]</span></p>
<p>5）净现值的隶属函数<br />
取上限15（百万元），下限0.5（百万元），采用线性隶属函数</p>
<p><span class="math display">\[\mu_E(x) = \frac{x - 50}{1500 - 50} =
\frac{x - 50}{1450}\]</span></p>
<p>6）根据各个隶属函数计算出5个方案所对应的不同隶属度</p>
<table>
<thead>
<tr>
<th style="text-align: center;">项目</th>
<th style="text-align: center;">方案1</th>
<th style="text-align: center;">方案2</th>
<th style="text-align: center;">方案3</th>
<th style="text-align: center;">方案4</th>
<th style="text-align: center;">方案5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">可采矿量/万吨</td>
<td style="text-align: center;">0.5341</td>
<td style="text-align: center;">0.7614</td>
<td style="text-align: center;">0.6705</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0.8636</td>
</tr>
<tr>
<td style="text-align: center;">基建投资/万元</td>
<td style="text-align: center;">0.3750</td>
<td style="text-align: center;">0.3125</td>
<td style="text-align: center;">0.3375</td>
<td style="text-align: center;">0.15</td>
<td style="text-align: center;">0.25</td>
</tr>
<tr>
<td style="text-align: center;">采矿成本/（元/吨）</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0.76</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0.4</td>
<td style="text-align: center;">0.48</td>
</tr>
<tr>
<td style="text-align: center;">不稳定费用/万元</td>
<td style="text-align: center;">0.85</td>
<td style="text-align: center;">0.75</td>
<td style="text-align: center;">0.8</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0.2</td>
</tr>
<tr>
<td style="text-align: center;">净现值/万元</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0.4480</td>
<td style="text-align: center;">0.6552</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0.0345</td>
</tr>
</tbody>
</table>
<p>确定单因素评判矩阵<br />
<span class="math display">\[R =
\begin{bmatrix}
0.5341 &amp; 0.7614 &amp; 0.6705 &amp; 1.0000 &amp; 0.8636 \\
0.3750 &amp; 0.3125 &amp; 0.3375 &amp; 0.1500 &amp; 0.2500 \\
1.0000 &amp; 0.7600 &amp; 1.0000 &amp; 0.4000 &amp; 0.4800 \\
1.0000 &amp; 0.4480 &amp; 0.6552 &amp; 0.0000 &amp; 0.0345
\end{bmatrix}\]</span></p>
<p>根据专家评价，该因素在决策中的权重为 $ A = (0.25, 0.20, 0.20, 0.10,
0.25) $<br />
注：没有专家可以用熵权法、层次分析法等</p>
<p>7）综合评价<br />
<span class="math display">\[B = A \cdot R = (0.7435, 0.5919, 0.6789,
0.3600, 0.3905)\]</span></p>
<p>由此可知：方案1最佳，方案3次之，方案4最差</p></li>
</ul>
<h2 id="多层次模糊综合评价模型">多层次模糊综合评价模型</h2>
<p>1）给出被评价的对象集合 <span
class="math inline">\(X=\{x_1,x_2,\cdots,x_k\}\)</span></p>
<p>2）确定因素集（亦称指标体系）<span
class="math inline">\(U=\{u_1,u_2,\cdots,u_n\}\)</span></p>
<p>若因素众多，往往将 <span
class="math inline">\(U=\{u_1,u_2,\cdots,u_n\}\)</span> 按某些属性分成 $
s $ 个子集<br />
<span class="math display">\[U_i = \{u_1^{(i)}, u_2^{(i)}, ...,
u_{n_i}^{(i)}\}, i = 1, 2, ..., s \]</span><br />
且满足条件：</p>
<p>① <span class="math inline">\(\sum\limits_{i=1}^{s} n_i = n;
\qquad\)</span>② <span
class="math inline">\(\bigcup\limits_{i=1}^{s}U_i=U;\qquad\)</span>③
<span class="math inline">\(U_i\cap U_j=\varnothing,i\neq j\)</span></p>
<p>3）确定评语集 <span
class="math inline">\(V=\{v_1,v_2,\cdots,v_m\}\)</span></p>
<p>4）由因素集 $ U_i $ 与评语集 <span
class="math inline">\(V\)</span>，可获得一个评价矩阵<br />
<span class="math display">\[R_i =
\begin{bmatrix}
r_{11}^{(i)} &amp; r_{12}^{(i)} &amp; ... &amp; r_{1m}^{(i)} \\
... &amp; ... &amp; ... &amp; ... \\
r_{n_i1}^{(i)} &amp; r_{n_i2}^{(i)} &amp; ... &amp; r_{n_im}^{(i)}
\end{bmatrix}\]</span></p>
<p>5）对每一个 $ U_i $，分别作出综合决策。</p>
<p>设 $ U_i $ 中的各因素权重分配（模糊权向量）为 $ A_i = (a_1^{(i)},
a_2^{(i)}, ..., a_{n_i}^{(i)}) $，其中 <span
class="math inline">\(\sum\limits_{t=1}^{n_i}a_t^{(i)}=1\)</span>。</p>
<p>若 $ R_i $ 为单因素矩阵，则得到一级评价向量为：</p>
<p><span class="math display">\[B_i = A_i \cdot R_i = (b_{i1}, b_{i2},
..., b_{im}), \quad i = 1, 2, ..., s\]</span></p>
<p>6）将每个 $ U_i $ 视为一个元素，记 <span
class="math inline">\(U=\{U_1,U_2,...,U_s\}\)</span>，于是 $ U $
又是单因素集，$ U $ 的单因素判断矩阵为</p>
<p><span class="math display">\[ R = \begin{bmatrix} B_1 \\ B_2 \\
\vdots \\ B_s \end{bmatrix} = \begin{bmatrix} b_{11} &amp; b_{12} &amp;
\cdots &amp; b_{1m} \\ \vdots &amp; \vdots &amp; \vdots &amp; \vdots \\
b_{s1} &amp; b_{s2} &amp; \cdots &amp; b_{sm} \end{bmatrix}
\]</span></p>
<p>每个 $ U_i $ 作为 $ U $ 的一部分，反映了 $ U $
的某种属性，可以按他们的重要性给出权重分配</p>
<p><span class="math display">\[A = (a_1, a_2, ..., a_s)\]</span></p>
<p>于是得到二级模糊综合评价模型为：</p>
<p><span class="math display">\[B = A \cdot R = (b_1, b_2, ...,
b_m)\]</span></p>
<p>若每个子因素 $ U_i (i = 1, 2, ..., s) $ 仍有较多因素，则可将 $ U_i $
再划分，于是有三级或更高级模型</p>
<h3
id="例对某陶瓷厂生产的6种产品的销售前景进行评判">例：对某陶瓷厂生产的6种产品的销售前景进行评判</h3>
<p><strong>1）影响评判对象因素集的选取</strong></p>
<p>从产品情况、销售能力、市场需求三个方面考虑，根据专家评判法，得到评判对象因素集及子因素组成下图，因素后面数据表示权重
<img src="/images/FuzzyComprehensiveEvaluation/多层次模糊综合评价.png" alt="多层次模糊综合评价图" style="width: 100%;"></p>
<p><strong>2）备择集 <span
class="math inline">\(V=\{1,2,3,4,5,6\}\)</span>
代表6种不同的陶瓷产品</strong></p>
<p><strong>3）一级模糊综合评价</strong></p>
<p>“运行费用”下属的三级指标是定量指标，有具体数据，对这些数据归一化即求出各种产品的该指标与总指标的比重，得到单因素隶属度；由于其他因素均为定性指标，通过市场调查，把消费者的满意度作为单因素的隶属度，6种产品的<strong>单因素隶属度</strong>如下表：</p>
<table style="width:100%;">
<colgroup>
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;">因素</th>
<th style="text-align: center;">产品1</th>
<th style="text-align: center;">产品2</th>
<th style="text-align: center;">产品3</th>
<th style="text-align: center;">产品4</th>
<th style="text-align: center;">产品5</th>
<th style="text-align: center;">产品6</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">$ u_{11} $ 产品品牌</td>
<td style="text-align: center;">0.12</td>
<td style="text-align: center;">0.18</td>
<td style="text-align: center;">0.17</td>
<td style="text-align: center;">0.23</td>
<td style="text-align: center;">0.13</td>
<td style="text-align: center;">0.17</td>
</tr>
<tr>
<td style="text-align: center;">$ u_{12} $ 产品质量</td>
<td style="text-align: center;">0.15</td>
<td style="text-align: center;">0.13</td>
<td style="text-align: center;">0.18</td>
<td style="text-align: center;">0.25</td>
<td style="text-align: center;">0.12</td>
<td style="text-align: center;">0.17</td>
</tr>
<tr>
<td style="text-align: center;">$ u_{13} $ 性价比</td>
<td style="text-align: center;">0.14</td>
<td style="text-align: center;">0.13</td>
<td style="text-align: center;">0.16</td>
<td style="text-align: center;">0.18</td>
<td style="text-align: center;">0.2</td>
<td style="text-align: center;">0.19</td>
</tr>
<tr>
<td style="text-align: center;">$ u_{14} $ 产品款式</td>
<td style="text-align: center;">0.12</td>
<td style="text-align: center;">0.14</td>
<td style="text-align: center;">0.15</td>
<td style="text-align: center;">0.17</td>
<td style="text-align: center;">0.19</td>
<td style="text-align: center;">0.23</td>
</tr>
<tr>
<td style="text-align: center;">$ u_{15} $ 产品包装</td>
<td style="text-align: center;">0.16</td>
<td style="text-align: center;">0.12</td>
<td style="text-align: center;">0.13</td>
<td style="text-align: center;">0.25</td>
<td style="text-align: center;">0.18</td>
<td style="text-align: center;">0.16</td>
</tr>
<tr>
<td style="text-align: center;">$ u_{21} $ 店铺信用度</td>
<td style="text-align: center;">0.13</td>
<td style="text-align: center;">0.15</td>
<td style="text-align: center;">0.14</td>
<td style="text-align: center;">0.18</td>
<td style="text-align: center;">0.16</td>
<td style="text-align: center;">0.24</td>
</tr>
<tr>
<td style="text-align: center;">$ u_{22} $ 售后服务</td>
<td style="text-align: center;">0.12</td>
<td style="text-align: center;">0.16</td>
<td style="text-align: center;">0.13</td>
<td style="text-align: center;">0.17</td>
<td style="text-align: center;">0.19</td>
<td style="text-align: center;">0.23</td>
</tr>
</tbody>
</table>
<table style="width:100%;">
<colgroup>
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;">因素</th>
<th style="text-align: center;">产品1</th>
<th style="text-align: center;">产品2</th>
<th style="text-align: center;">产品3</th>
<th style="text-align: center;">产品4</th>
<th style="text-align: center;">产品5</th>
<th style="text-align: center;">产品6</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">$ u_{231} $ 材料费</td>
<td style="text-align: center;">0.18</td>
<td style="text-align: center;">0.14</td>
<td style="text-align: center;">0.18</td>
<td style="text-align: center;">0.14</td>
<td style="text-align: center;">0.13</td>
<td style="text-align: center;">0.23</td>
</tr>
<tr>
<td style="text-align: center;">$ u_{232} $ 运输费用</td>
<td style="text-align: center;">0.15</td>
<td style="text-align: center;">0.2</td>
<td style="text-align: center;">0.15</td>
<td style="text-align: center;">0.25</td>
<td style="text-align: center;">0.1</td>
<td style="text-align: center;">0.15</td>
</tr>
<tr>
<td style="text-align: center;">$ u_{233} $ 设备维修费用</td>
<td style="text-align: center;">0.25</td>
<td style="text-align: center;">0.12</td>
<td style="text-align: center;">0.13</td>
<td style="text-align: center;">0.12</td>
<td style="text-align: center;">0.18</td>
<td style="text-align: center;">0.2</td>
</tr>
<tr>
<td style="text-align: center;">$ u_{234} $ 设备折旧费用</td>
<td style="text-align: center;">0.16</td>
<td style="text-align: center;">0.15</td>
<td style="text-align: center;">0.21</td>
<td style="text-align: center;">0.11</td>
<td style="text-align: center;">0.2</td>
<td style="text-align: center;">0.17</td>
</tr>
<tr>
<td style="text-align: center;">$ u_{235} $ 人员工资</td>
<td style="text-align: center;">0.23</td>
<td style="text-align: center;">0.18</td>
<td style="text-align: center;">0.17</td>
<td style="text-align: center;">0.16</td>
<td style="text-align: center;">0.15</td>
<td style="text-align: center;">0.11</td>
</tr>
<tr>
<td style="text-align: center;">$ u_{236} $ 电耗费用</td>
<td style="text-align: center;">0.19</td>
<td style="text-align: center;">0.13</td>
<td style="text-align: center;">0.12</td>
<td style="text-align: center;">0.12</td>
<td style="text-align: center;">0.11</td>
<td style="text-align: center;">0.33</td>
</tr>
<tr>
<td style="text-align: center;">$ u_{237} $ 水耗费用</td>
<td style="text-align: center;">0.17</td>
<td style="text-align: center;">0.16</td>
<td style="text-align: center;">0.15</td>
<td style="text-align: center;">0.08</td>
<td style="text-align: center;">0.25</td>
<td style="text-align: center;">0.19</td>
</tr>
<tr>
<td style="text-align: center;">$ u_{24} $ 销售人员能力</td>
<td style="text-align: center;">0.14</td>
<td style="text-align: center;">0.13</td>
<td style="text-align: center;">0.15</td>
<td style="text-align: center;">0.16</td>
<td style="text-align: center;">0.18</td>
<td style="text-align: center;">0.24</td>
</tr>
<tr>
<td style="text-align: center;">$ u_{25} $ 广告宣传</td>
<td style="text-align: center;">0.16</td>
<td style="text-align: center;">0.15</td>
<td style="text-align: center;">0.15</td>
<td style="text-align: center;">0.17</td>
<td style="text-align: center;">0.18</td>
<td style="text-align: center;">0.19</td>
</tr>
<tr>
<td style="text-align: center;">$ u_{31} $ 行业需求</td>
<td style="text-align: center;">0.15</td>
<td style="text-align: center;">0.14</td>
<td style="text-align: center;">0.13</td>
<td style="text-align: center;">0.18</td>
<td style="text-align: center;">0.14</td>
<td style="text-align: center;">0.26</td>
</tr>
<tr>
<td style="text-align: center;">$ u_{32} $ 家庭需求</td>
<td style="text-align: center;">0.16</td>
<td style="text-align: center;">0.15</td>
<td style="text-align: center;">0.18</td>
<td style="text-align: center;">0.14</td>
<td style="text-align: center;">0.16</td>
<td style="text-align: center;">0.21</td>
</tr>
</tbody>
</table>
<p>影响运行费用的各因素的单因素评价矩阵为：</p>
<p><span class="math display">\[R_{23} =
\begin{bmatrix}
0.18 &amp; 0.14 &amp; 0.18 &amp; 0.14 &amp; 0.13 &amp; 0.23 \\
0.15 &amp; 0.20 &amp; 0.15 &amp; 0.25 &amp; 0.10 &amp; 0.15 \\
0.25 &amp; 0.12 &amp; 0.13 &amp; 0.12 &amp; 0.18 &amp; 0.20 \\
0.16 &amp; 0.15 &amp; 0.21 &amp; 0.11 &amp; 0.20 &amp; 0.17 \\
0.23 &amp; 0.18 &amp; 0.17 &amp; 0.16 &amp; 0.15 &amp; 0.11 \\
0.19 &amp; 0.13 &amp; 0.12 &amp; 0.12 &amp; 0.11 &amp; 0.33 \\
0.17 &amp; 0.16 &amp; 0.15 &amp; 0.08 &amp; 0.25 &amp; 0.19
\end{bmatrix}\]</span></p>
<p>权重分配为： <span class="math display">\[A_{23} = [0.20 \quad 0.15
\quad 0.10 \quad 0.10 \quad 0.20 \quad 0.15 \quad 0.10]\]</span>
则运行费用的一级评判为： <span class="math display">\[B_{23} = A_{23}
R_{23} = [0.1910 \quad 0.1565 \quad 0.1595 \quad 0.1465 \quad 0.1505
\quad 0.1960]\]</span></p>
<p><strong>4）二级模糊综合评判</strong></p>
<p>对产品情况、销售能力、市场需求下属的单因素指标进行二级评判，产品情况的二级评判如下：</p>
<p><span class="math display">\[R_1 =
\begin{bmatrix}
0.12 &amp; 0.18 &amp; 0.17 &amp; 0.23 &amp; 0.13 &amp; 0.17 \\
0.15 &amp; 0.13 &amp; 0.18 &amp; 0.25 &amp; 0.12 &amp; 0.17 \\
0.14 &amp; 0.13 &amp; 0.16 &amp; 0.18 &amp; 0.20 &amp; 0.19 \\
0.12 &amp; 0.14 &amp; 0.15 &amp; 0.17 &amp; 0.19 &amp; 0.23 \\
0.16 &amp; 0.12 &amp; 0.13 &amp; 0.25 &amp; 0.18 &amp; 0.16
\end{bmatrix}\]</span></p>
<p><span class="math display">\[A_1 =
\begin{bmatrix}
0.15 &amp; 0.40 &amp; 0.25 &amp; 0.10 &amp; 0.10
\end{bmatrix}\]</span></p>
<p><span class="math display">\[B_1 = A_1 \cdot R_1 =
\begin{bmatrix}
0.1410 &amp; 0.1375 &amp; 0.1655 &amp; 0.2215 &amp; 0.1545 &amp; 0.1800
\end{bmatrix}\]</span></p>
<p>将运行费用的一级评判结果作为二级评判的单因素评价值，即评判矩阵的第三行，则销售能力二级评判如下：</p>
<p><span class="math display">\[R_2 =
\begin{bmatrix}
0.13 &amp; 0.15 &amp; 0.14 &amp; 0.18 &amp; 0.16 &amp; 0.24 \\
0.12 &amp; 0.16 &amp; 0.13 &amp; 0.17 &amp; 0.19 &amp; 0.23 \\
0.1910 &amp; 0.1565 &amp; 0.1595 &amp; 0.1465 &amp; 0.1505 &amp; 0.1960
\\
0.14 &amp; 0.13 &amp; 0.15 &amp; 0.16 &amp; 0.18 &amp; 0.24 \\
0.16 &amp; 0.15 &amp; 0.15 &amp; 0.17 &amp; 0.18 &amp; 0.19
\end{bmatrix}\]</span></p>
<p><span class="math display">\[A_2 =
\begin{bmatrix}
0.20 &amp; 0.15 &amp; 0.25 &amp; 0.25 &amp; 0.15
\end{bmatrix}\]</span></p>
<p><span class="math display">\[B_2 = A_2 \cdot R_2 =
\begin{bmatrix}
0.1508 &amp; 0.1481 &amp; 0.1474 &amp; 0.1636 &amp; 0.1701 &amp; 0.2200
\end{bmatrix}\]</span></p>
<p>市场需求的二级评判：</p>
<p><span class="math display">\[R_3 = \begin{bmatrix} 0.15 &amp; 0.14
&amp; 0.13 &amp; 0.18 &amp; 0.14 &amp; 0.26 \\ 0.16 &amp; 0.15 &amp;
0.18 &amp; 0.14 &amp; 0.16 &amp; 0.21 \end{bmatrix}\]</span></p>
<p><span class="math display">\[A_3 = \begin{bmatrix} 0.55 &amp; 0.45
\end{bmatrix}\]</span></p>
<p><span class="math display">\[B_3 = A_3 \cdot R_3 = \begin{bmatrix}
0.1545 &amp; 0.1445 &amp; 0.1525 &amp; 0.1620 &amp; 0.1490 &amp; 0.2375
\end{bmatrix}\]</span></p>
<p><strong>5）三级模糊综合评价</strong></p>
<p>将二级评判结果 $ B_1, B_2, B_3 $
作为行，组成三级评判的单因素评判矩阵</p>
<p><span class="math display">\[R = \begin{bmatrix} B_1 \\ B_2 \\ B_3
\end{bmatrix}\]</span></p>
<p>权重及 <span
class="math inline">\(A=\begin{bmatrix}0.40&amp;0.30&amp;0.30\end{bmatrix}\)</span></p>
<p><span class="math display">\[B = A \cdot R = \begin{bmatrix} 0.1480
&amp; 0.1428 &amp; 0.1562 &amp; 0.1863 &amp; 0.1575 &amp; 0.2093
\end{bmatrix}\]</span></p>
<p>由结果可知，产品6得分最高，可加大投资，产品1、2得分较低，应减少投资</p>
<h1 id="matlab代码">Matlab代码</h1>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">% 1、一级模糊综合评判</span><br><span class="line">% 影响运行费用的各因素的单因素评价矩阵为：</span><br><span class="line">R23=[0.18 0.14 0.18 0.14 0.13 0.23;</span><br><span class="line">     0.15 0.20 0.15 0.25 0.10 0.15;</span><br><span class="line">     0.25 0.12 0.13 0.12 0.18 0.20;</span><br><span class="line">     0.16 0.15 0.21 0.11 0.20 0.17;</span><br><span class="line">     0.23 0.18 0.17 0.16 0.15 0.11;</span><br><span class="line">     0.19 0.13 0.12 0.12 0.11 0.33;</span><br><span class="line">     0.17 0.16 0.15 0.08 0.25 0.19];</span><br><span class="line">% 权重分配为</span><br><span class="line">A23=[0.20 0.15 0.10 0.10 0.20 0.15 0.10];</span><br><span class="line">% 评价结果</span><br><span class="line">B23=A23*R23</span><br><span class="line"></span><br><span class="line">% 2、二级模糊综合评判</span><br><span class="line">% 产品情况的二级评判如下：</span><br><span class="line">R1=[0.12 0.18 0.17 0.23 0.13 0.17;</span><br><span class="line">    0.15 0.13 0.18 0.25 0.12 0.17;</span><br><span class="line">    0.14 0.13 0.16 0.18 0.20 0.19;</span><br><span class="line">    0.12 0.14 0.15 0.17 0.19 0.23;</span><br><span class="line">    0.16 0.12 0.13 0.25 0.18 0.16];</span><br><span class="line">A1=[0.15 0.40 0.25 0.10 0.10];</span><br><span class="line">B1=A1*R1</span><br><span class="line">% 销售能力二级评判如下：</span><br><span class="line">R2=[0.13 0.15 0.14 0.18 0.16 0.25;</span><br><span class="line">    0.12 0.16 0.13 0.17 0.19 0.23;</span><br><span class="line">    B23;</span><br><span class="line">    0.14 0.13 0.15 0.16 0.18 0.24;</span><br><span class="line">    0.16 0.15 0.15 0.17 0.18 0.19];</span><br><span class="line">A2=[0.2 0.15 0.25 0.25 0.15];</span><br><span class="line">B2=A2*R2</span><br><span class="line"></span><br><span class="line">% 市场需求的二级评判</span><br><span class="line">R3=[0.15 0.14 0.13 0.18 0.14 0.26;</span><br><span class="line">    0.16 0.15 0.18 0.14 0.16 0.21];</span><br><span class="line">A3=[0.55 0.45];</span><br><span class="line">B3=A3*R3</span><br><span class="line"></span><br><span class="line">% 3、三级模糊综合评判</span><br><span class="line">R=[B1;B2;B3]</span><br><span class="line">A=[0.4 0.3 0.3]</span><br><span class="line">B=A*R</span><br></pre></td></tr></table></figure>
<h1 id="python代码">Python代码</h1>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># 1、一级模糊综合评判</span><br><span class="line"># 影响运行费用的各因素的单因素评价矩阵为：</span><br><span class="line">R23 = np.array([</span><br><span class="line">     [0.18, 0.14, 0.18, 0.14, 0.13, 0.23],</span><br><span class="line">     [0.15, 0.20, 0.15, 0.25, 0.10, 0.15],</span><br><span class="line">     [0.25, 0.12, 0.13, 0.12, 0.18, 0.20],</span><br><span class="line">     [0.16, 0.15, 0.21, 0.11, 0.20, 0.17],</span><br><span class="line">     [0.23, 0.18, 0.17, 0.16, 0.15, 0.11],</span><br><span class="line">     [0.19, 0.13, 0.12, 0.12, 0.11, 0.33],</span><br><span class="line">     [0.17, 0.16, 0.15, 0.08, 0.25, 0.19]])</span><br><span class="line"># 权重分配为</span><br><span class="line">A23 = np.array([0.20, 0.15, 0.10, 0.10, 0.20, 0.15, 0.10])</span><br><span class="line"># 评价结果</span><br><span class="line"># np.dot是Numpy库中的一个函数，用于计算两个数组的点积。对于一维数组，它计算的是这两个数组的内积。</span><br><span class="line"># 对于二维数组（矩阵），它计算的是矩阵乘法。</span><br><span class="line">B23 = np.dot(A23, R23)</span><br><span class="line"></span><br><span class="line"># 2、二级模糊综合评判</span><br><span class="line"># 产品情况的二级评判如下：</span><br><span class="line">R1 = np.array([</span><br><span class="line">    [0.12, 0.18, 0.17, 0.23, 0.13, 0.17],</span><br><span class="line">    [0.15, 0.13, 0.18, 0.25, 0.12, 0.17],</span><br><span class="line">    [0.14, 0.13, 0.16, 0.18, 0.20, 0.19],</span><br><span class="line">    [0.12, 0.14, 0.15, 0.17, 0.19, 0.23],</span><br><span class="line">    [0.16, 0.12, 0.13, 0.25, 0.18, 0.16]])</span><br><span class="line">A1 = np.array([0.15, 0.40, 0.25, 0.10, 0.10])</span><br><span class="line">B1 = np.dot(A1, R1)</span><br><span class="line"># 销售能力二级评判如下：</span><br><span class="line">R2 = np.array([</span><br><span class="line">    [0.13, 0.15, 0.14, 0.18, 0.16, 0.25],</span><br><span class="line">    [0.12, 0.16, 0.13, 0.17, 0.19, 0.23],</span><br><span class="line">    B23,</span><br><span class="line">    [0.14, 0.13, 0.15, 0.16, 0.18, 0.24],</span><br><span class="line">    [0.16, 0.15, 0.15, 0.17, 0.18, 0.19]])</span><br><span class="line">A2 = np.array([0.2, 0.15, 0.25, 0.25, 0.15])</span><br><span class="line">B2 = np.dot(A2, R2)</span><br><span class="line"></span><br><span class="line"># 市场需求的二级评判</span><br><span class="line">R3 = np.array([</span><br><span class="line">    [0.15, 0.14, 0.13, 0.18, 0.14, 0.26],</span><br><span class="line">    [0.16, 0.15, 0.18, 0.14, 0.16, 0.21]])</span><br><span class="line">A3 = np.array([0.55, 0.45])</span><br><span class="line">B3 = np.dot(A3, R3)</span><br><span class="line"></span><br><span class="line"># 3、三级模糊综合评判</span><br><span class="line">R = np.array([B1, B2, B3])</span><br><span class="line">A = np.array([0.4, 0.3, 0.3])</span><br><span class="line">B = np.dot(A, R)</span><br><span class="line"></span><br><span class="line">print(B)</span><br></pre></td></tr></table></figure>
<p align="right">
<strong>内容编辑：杜灯</strong>
</p>
<p align="right">
<strong>内容审核：王颖</strong>
</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/01/17/GreyRelationalAnalysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2026/01/17/GreyRelationalAnalysis/" class="post-title-link" itemprop="url">灰色关联分析算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2026-01-17 15:36:04 / Modified: 18:38:12" itemprop="dateCreated datePublished" datetime="2026-01-17T15:36:04+08:00">2026-01-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="模型引出">模型引出</h1>
<h2 id="什么是灰色系统">什么是灰色系统？</h2>
<ul>
<li><strong>灰色系统理论</strong>是1982年由邓聚龙创立的一门边缘性学科（interdisciplinary）。灰色系统用颜色深浅<strong>反映信息量的多少</strong>。说一个系统是黑色的，就是说这个系统是黑洞洞的，信息量太少；说一个系统是白色的，就是说这个系统是清楚的，信息量充足。这种处于黑白之间的系统，或说信息不完全的系统，称为灰色系统或简称灰系统。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">白</th>
<th style="text-align: center;">黑</th>
<th style="text-align: center;">灰</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">从表象看</td>
<td style="text-align: center;">明朗</td>
<td style="text-align: center;">暗</td>
<td style="text-align: center;">若明若暗</td>
</tr>
<tr>
<td style="text-align: center;">从过程看</td>
<td style="text-align: center;">新</td>
<td style="text-align: center;">旧</td>
<td style="text-align: center;">新旧交替</td>
</tr>
<tr>
<td style="text-align: center;">从性质看</td>
<td style="text-align: center;">纯</td>
<td style="text-align: center;">不纯</td>
<td style="text-align: center;">多种成分</td>
</tr>
<tr>
<td style="text-align: center;">从信息看</td>
<td style="text-align: center;">完全</td>
<td style="text-align: center;">不完全</td>
<td style="text-align: center;">部分完全</td>
</tr>
<tr>
<td style="text-align: center;">从结果看</td>
<td style="text-align: center;">唯一的解</td>
<td style="text-align: center;">无数的解</td>
<td style="text-align: center;">非唯一性</td>
</tr>
<tr>
<td style="text-align: center;">从态度看</td>
<td style="text-align: center;">肯定</td>
<td style="text-align: center;">否定</td>
<td style="text-align: center;">扬弃</td>
</tr>
<tr>
<td style="text-align: center;">从方法看</td>
<td style="text-align: center;">严厉</td>
<td style="text-align: center;">放纵</td>
<td style="text-align: center;">宽容</td>
</tr>
</tbody>
</table>
<p>“信息不完全”是灰的基本含义，一般指： 1. 系统因素不完全明确 2.
因素关系不完全清楚 3. 系统的结构不完全知道 4.
系统的作用原理不完全明了</p>
<h2 id="什么是关联分析">什么是关联分析？</h2>
<ul>
<li><p>所谓关联分析，就是<strong>系统地分析因素</strong>。回答的问题是：某个包含多种因素的系统中，哪些因素是主要的，哪些是次要的；哪些因素影响大，哪些因素影响小；哪些因素是明显的，哪些因素是潜在的；哪些是需要发展的，哪些是需要抑制的等等。</p></li>
<li><p>现有因素分析的量化方法，大都是数理统计法如回归分析、方差分析、主要成分分析等，这些方法都有下述弱点：
（1）要求大量数据，数据量少难以找到统计规律；
（2）要求分布是典型的（线性的、指数的或对数的），即使是典型的并非都能处理；
（3）计算工作量大，一般需要计算机帮助；
（4）有时可能出现反常情况，如正相关则断为负相关，以至正确现象受到歪曲和颠倒。</p></li>
<li><p>尤其是我国统计数据十分有限，而且现有数据灰度较大，许多数据都出现几次大起大落，没有典型的分布规律。因此，采用数理统计方法往往难以奏效。</p></li>
</ul>
<h1 id="模型原理">模型原理</h1>
<h2 id="灰色关联分析">灰色关联分析</h2>
<ul>
<li><p><strong>灰色关联度分析</strong>（Grey Relational
Analysis，GRA），是一种多因素统计分析的方法。灰色关联分析方法弥补了采用数理统计方法作系统分析所导致的缺憾。它对<strong>样本量的多少和样本有无规律都同样适用</strong>，而且计算量小、十分方便，更不会出现量化结果与定性分析结果不符的情况。</p></li>
<li><p>灰色关联分析的基本思想是<strong>根据序列曲线几何形状的相似程度</strong>来判断其联系是否紧密。曲线越接近，相应序列之间的关联度就越大，反之就越小。</p></li>
<li><p>对一个抽象的系统或现象进行分析，首先要选定反映<strong>系统行为特征的数据序列</strong>，称为找系统行为的映射量，用映射量来间接地表征系统行为。例如，用国民平均接受教育的年数来反映教育发达程度，用刑事案件的发案率来反映社会治安面貌和社会秩序，用医院挂号次数来反映国民的健康水平等。有了系统行为特征数据和相关因素的数据，即可作出各个序列的图形，从直观上进行分析。</p></li>
</ul>
<h4
id="曲线几何形态越相似rightarrow发展变化态势就越接近rightarrow其关联程度就越大">曲线几何形态越相似<span
class="math inline">\(\Rightarrow\)</span>发展变化态势就越接近<span
class="math inline">\(\Rightarrow\)</span>其关联程度就越大</h4>
<h2 id="关联分析步骤">关联分析步骤</h2>
<ol type="1">
<li>母序列（又称参考序列、母指标）<br />
能反映系统行为特征的数据序列，类似于因变量 <span
class="math inline">\(Y\)</span>，记为 <span
class="math inline">\(Y=[y_1,y_2,\cdots,y_n]^T\)</span><br />
</li>
<li>子序列（又称比较序列、子指标）<br />
影响系统行为的因素组成的数据序列，类似于自变量 $ X $，记为</li>
</ol>
<p><span class="math display">\[X_{mn} =
\begin{bmatrix}
x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1m} \\
x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2m} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
x_{n1} &amp; x_{n2} &amp; \cdots &amp; x_{nm}
\end{bmatrix}\]</span></p>
<ol start="3" type="1">
<li>数据预处理<br />
由于不同要素具有不同量纲和数据范围，因此我们要对他们进行预处理去量纲，将他们统一到近似的范围内，先求出每个指标的均值，再用指标中的元素除以其均值</li>
</ol>
<p><span class="math display">\[\tilde{y}_k = \frac{y_k}{\bar{y_i}},
\bar{y}_i = \frac{1}{n}\sum_{k=1}^n y_k\]</span></p>
<p><span class="math display">\[\tilde{x}_{ki} =
\frac{x_{ki}}{\bar{x_i}}, \bar{x}_i = \frac{1}{n}\sum_{k=1}^n x_{ki}
(i=1, 2, \cdots, m)\]</span></p>
<ol start="4" type="1">
<li>计算灰色关联系数</li>
</ol>
<p>计算子序列中各个指标与母序列的关联系数</p>
<p>记为：<br />
<span class="math display">\[a = \min_{i} \min_{k} |x_0(k) - x_i(k)|,
\quad b = \max_{i} \max_{k} |x_0(k) - x_i(k)|\]</span></p>
<p>为两极最小差和最大差</p>
<p>构造：<br />
<span class="math display">\[\xi_i(k) = y(x_0(k), x_i(k)) = \frac{a +
\rho b}{|x_0(k) - x_i(k)| + \rho b}\]</span></p>
<p>其中 <span class="math inline">\(\rho\)</span> 为分辨系数，一般取
0.5。</p>
<ol start="5" type="1">
<li>计算关联度</li>
</ol>
<p><span class="math display">\[r_i = \frac{1}{n} \sum_{k=1}^{n}
\xi_i(k) = \frac{1}{n} \sum_{k=1}^{n} y(x_0(k), x_i(k))\]</span></p>
<h1 id="典型例题">典型例题</h1>
<h2 id="灰色关联分析例题">灰色关联分析例题</h2>
<p>已知某地国民生产总值，工业和农业生产总值，原始数据的形式及来源见下表，分析工业农业哪个对国民生产总值影响大。</p>
<table>
<thead>
<tr>
<th style="text-align: center;">项目名称</th>
<th style="text-align: center;">2016年</th>
<th style="text-align: center;">2017年</th>
<th style="text-align: center;">2018年</th>
<th style="text-align: center;">2019年</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">国民生产总值</td>
<td style="text-align: center;">55</td>
<td style="text-align: center;">65</td>
<td style="text-align: center;">75</td>
<td style="text-align: center;">100</td>
</tr>
<tr>
<td style="text-align: center;">工业产值</td>
<td style="text-align: center;">24</td>
<td style="text-align: center;">38</td>
<td style="text-align: center;">40</td>
<td style="text-align: center;">50</td>
</tr>
<tr>
<td style="text-align: center;">农业产值</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">22</td>
<td style="text-align: center;">18</td>
<td style="text-align: center;">20</td>
</tr>
</tbody>
</table>
<ol type="1">
<li>定义母序列及子序列如下：</li>
</ol>
<table style="width:100%;">
<colgroup>
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;">项目名称</th>
<th style="text-align: center;">2016年</th>
<th style="text-align: center;">2017年</th>
<th style="text-align: center;">2018年</th>
<th style="text-align: center;">2019年</th>
<th style="text-align: center;">项目代号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">国民生产总值</td>
<td style="text-align: center;">55</td>
<td style="text-align: center;">65</td>
<td style="text-align: center;">75</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;"><span
class="math display">\[X_0\]</span>(母序列)</td>
</tr>
<tr>
<td style="text-align: center;">工业产值</td>
<td style="text-align: center;">24</td>
<td style="text-align: center;">38</td>
<td style="text-align: center;">40</td>
<td style="text-align: center;">50</td>
<td style="text-align: center;"><span
class="math display">\[X_1\]</span>(子序列)</td>
</tr>
<tr>
<td style="text-align: center;">农业产值</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">22</td>
<td style="text-align: center;">18</td>
<td style="text-align: center;">20</td>
<td style="text-align: center;"><span
class="math display">\[X_2\]</span>(子序列)</td>
</tr>
</tbody>
</table>
<ol start="2" type="1">
<li>数据预处理 对数据进行均值化<br />
<span class="math display">\[\tilde{y}_k = \frac{y_k}{\bar{y}_i},
\bar{y}_i = \frac{1}{n} \sum_{k=1}^n y_k, \tilde x_{ki} =
\frac{x_{ki}}{\bar{x_i}}, \bar x_i = \frac{1}{n} \sum_{k=1}^n x_{ki}
(i=1,2,\cdots,m)\]</span></li>
</ol>
<table style="width:100%;">
<colgroup>
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;">项目名称</th>
<th style="text-align: center;">2016年</th>
<th style="text-align: center;">2017年</th>
<th style="text-align: center;">2018年</th>
<th style="text-align: center;">2019年</th>
<th style="text-align: center;">项目代号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">国民生产总值</td>
<td style="text-align: center;">0.75</td>
<td style="text-align: center;">0.88</td>
<td style="text-align: center;">1.02</td>
<td style="text-align: center;">1.36</td>
<td style="text-align: center;">(母序列)</td>
</tr>
<tr>
<td style="text-align: center;">工业产值</td>
<td style="text-align: center;">0.63</td>
<td style="text-align: center;">1.00</td>
<td style="text-align: center;">1.05</td>
<td style="text-align: center;">1.32</td>
<td style="text-align: center;">(子序列)</td>
</tr>
<tr>
<td style="text-align: center;">农业产值</td>
<td style="text-align: center;">0.57</td>
<td style="text-align: center;">1.26</td>
<td style="text-align: center;">1.03</td>
<td style="text-align: center;">1.14</td>
<td style="text-align: center;">(子序列)</td>
</tr>
</tbody>
</table>
<ol start="3" type="1">
<li>求关联系数</li>
</ol>
<table style="width:100%;">
<colgroup>
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;"><span
class="math inline">\(k\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(X_0\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(X_1\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(X_2\)</span></th>
<th style="text-align: center;"><span class="math inline">\(\vert
x_0(k)-x_1(k)\vert\)</span></th>
<th style="text-align: center;"><span class="math inline">\(\vert
x_0(k)-x_2(k)\vert\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0.75</td>
<td style="text-align: center;">0.63</td>
<td style="text-align: center;">0.57</td>
<td style="text-align: center;">0.12</td>
<td style="text-align: center;">0.18</td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;">0.88</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1.26</td>
<td style="text-align: center;">0.12</td>
<td style="text-align: center;">0.38</td>
</tr>
<tr>
<td style="text-align: center;">3</td>
<td style="text-align: center;">1.02</td>
<td style="text-align: center;">1.05</td>
<td style="text-align: center;">1.03</td>
<td style="text-align: center;">0.03</td>
<td style="text-align: center;">0.01</td>
</tr>
<tr>
<td style="text-align: center;">4</td>
<td style="text-align: center;">1.36</td>
<td style="text-align: center;">1.32</td>
<td style="text-align: center;">1.14</td>
<td style="text-align: center;">0.04</td>
<td style="text-align: center;">0.22</td>
</tr>
</tbody>
</table>
<p><span
class="math inline">\(a=\min\limits_i\min\limits_k|x_0(k)-x_i(k)|,b=\max\limits_i\max\limits_k|x_0(k)-x_i(k)|,\xi_i(k)=y(x_0(k),
x_i(k))=\frac{a+\rho b}{|x_0(k)-x_i(k)|+\rho b}\)</span> <span
class="math display">\[a = 0.01 \quad b = 0.38\]</span></p>
<p><span class="math display">\[\xi_i(k) = y(x_0(k), x_i(k)) =
\frac{0.01 + 0.5 \times 0.38}{|x_0(k) - x_i(k)| + 0.5 \times
0.38}\]</span></p>
<p><span class="math display">\[= \frac{0.2}{|x_0(k) - x_i(k)| +
0.19}\]</span></p>
<ol start="4" type="1">
<li>求关联度</li>
</ol>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;"><span
class="math inline">\(k\)</span></th>
<th style="text-align: center;"><span class="math inline">\(\vert
x_0(k)-x_1(k)\vert\)</span></th>
<th style="text-align: center;"><span class="math inline">\(\vert
x_0(k)-x_2(k)\vert\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(\xi_1\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(\xi_2\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0.12</td>
<td style="text-align: center;">0.18</td>
<td style="text-align: center;">0.645</td>
<td style="text-align: center;">0.541</td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;">0.12</td>
<td style="text-align: center;">0.38</td>
<td style="text-align: center;">0.645</td>
<td style="text-align: center;">0.351</td>
</tr>
<tr>
<td style="text-align: center;">3</td>
<td style="text-align: center;">0.03</td>
<td style="text-align: center;">0.01</td>
<td style="text-align: center;">0.909</td>
<td style="text-align: center;">1.000</td>
</tr>
<tr>
<td style="text-align: center;">4</td>
<td style="text-align: center;">0.04</td>
<td style="text-align: center;">0.22</td>
<td style="text-align: center;">0.870</td>
<td style="text-align: center;">0.488</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: center;">$ k $</th>
<th style="text-align: center;"><span
class="math inline">\(\xi_1\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(\xi_2\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0.645</td>
<td style="text-align: center;">0.541</td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;">0.645</td>
<td style="text-align: center;">0.351</td>
</tr>
<tr>
<td style="text-align: center;">3</td>
<td style="text-align: center;">0.909</td>
<td style="text-align: center;">1.000</td>
</tr>
<tr>
<td style="text-align: center;">4</td>
<td style="text-align: center;">0.870</td>
<td style="text-align: center;">0.488</td>
</tr>
<tr>
<td style="text-align: center;"><strong><span
class="math inline">\(r\)</span></strong></td>
<td style="text-align: center;"><strong>0.767</strong></td>
<td style="text-align: center;"><strong>0.595</strong></td>
</tr>
</tbody>
</table>
<p><span class="math display">\[r_i = \frac{1}{n} \sum_{k=1}^{n}
\xi_i(k) = \frac{1}{n} \sum_{k=1}^{n} y(x_0(k), x_i(k))\]</span></p>
<p><span class="math display">\[r_1 &gt; r_2 \quad
\text{工业产值关联度更大}\]</span></p>
<h2 id="灰色关联评价例题">灰色关联评价例题</h2>
<p>我们来换个方法给明星K选对象，还是A、B、C三位候选人（K觉得身高165是最好，体重在90-100斤是最好）</p>
<table>
<thead>
<tr>
<th style="text-align: center;">候选人</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">脾气（争吵次数）</th>
<th style="text-align: center;">身高</th>
<th style="text-align: center;">体重</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A</td>
<td style="text-align: center;">9</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">175</td>
<td style="text-align: center;">120</td>
</tr>
<tr>
<td style="text-align: center;">B</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">164</td>
<td style="text-align: center;">80</td>
</tr>
<tr>
<td style="text-align: center;">C</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">157</td>
<td style="text-align: center;">90</td>
</tr>
</tbody>
</table>
<ol type="1">
<li>数据正向化处理（可看Topsis一节）</li>
</ol>
<p>将原始矩阵正向化，就是要将所有的指标类型统一转化为极大型指标。</p>
<p><span class="math display">\[X_{mn} =
\begin{bmatrix}
x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1m} \\
x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2m} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
x_{n1} &amp; x_{n2} &amp; \cdots &amp; x_{nm}
\end{bmatrix}\]</span></p>
<table>
<thead>
<tr>
<th style="text-align: center;">候选人</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">脾气（争吵次数）</th>
<th style="text-align: center;">身高</th>
<th style="text-align: center;">体重</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A</td>
<td style="text-align: center;">9</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">B</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">0.9</td>
<td style="text-align: center;">0.5</td>
</tr>
<tr>
<td style="text-align: center;">C</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">0.2</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<ol start="2" type="1">
<li>正向化后数据预处理（可看Topsis一节）</li>
</ol>
<p>每个指标的元素除以该指标元素的平均值</p>
<p><span class="math display">\[Z_{nm} =
\begin{bmatrix}
z_{11} &amp; z_{12} &amp; \cdots &amp; z_{1m} \\
z_{21} &amp; z_{22} &amp; \cdots &amp; z_{2m} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
z_{n1} &amp; z_{n2} &amp; \cdots &amp; z_{nm}
\end{bmatrix}\]</span></p>
<table>
<thead>
<tr>
<th style="text-align: center;">候选人</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">脾气（争吵次数）</th>
<th style="text-align: center;">身高</th>
<th style="text-align: center;">体重</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A</td>
<td style="text-align: center;">1.17</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">0.00</td>
</tr>
<tr>
<td style="text-align: center;">B</td>
<td style="text-align: center;">1.04</td>
<td style="text-align: center;">0.90</td>
<td style="text-align: center;">2.45</td>
<td style="text-align: center;">1.00</td>
</tr>
<tr>
<td style="text-align: center;">C</td>
<td style="text-align: center;">0.78</td>
<td style="text-align: center;">2.10</td>
<td style="text-align: center;">0.55</td>
<td style="text-align: center;">2.00</td>
</tr>
</tbody>
</table>
<ol start="3" type="1">
<li>构造母序列</li>
</ol>
<p><span class="math display">\[Y = [y_1, y_2, \cdots,
y_n]^T\]</span></p>
<p>其中 <span
class="math inline">\(y_i=\max(z_{i1},z_{i2},\cdots,z_{im})\)</span></p>
<table>
<thead>
<tr>
<th style="text-align: center;">候选人</th>
<th style="text-align: center;">Y</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">脾气（争吵次数）</th>
<th style="text-align: center;">身高</th>
<th style="text-align: center;">体重</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A</td>
<td style="text-align: center;">1.17</td>
<td style="text-align: center;">1.17</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">0.00</td>
</tr>
<tr>
<td style="text-align: center;">B</td>
<td style="text-align: center;">2.45</td>
<td style="text-align: center;">1.04</td>
<td style="text-align: center;">0.90</td>
<td style="text-align: center;">2.45</td>
<td style="text-align: center;">1.00</td>
</tr>
<tr>
<td style="text-align: center;">C</td>
<td style="text-align: center;">2.10</td>
<td style="text-align: center;">0.78</td>
<td style="text-align: center;">2.10</td>
<td style="text-align: center;">0.55</td>
<td style="text-align: center;">2.00</td>
</tr>
</tbody>
</table>
<ol start="4" type="1">
<li>计算关联系数</li>
</ol>
<p>记差值矩阵为 $ K $ <span class="math display">\[K_{nm} =
\begin{bmatrix}
k_{11} &amp; k_{12} &amp; \cdots &amp; k_{1m} \\
k_{21} &amp; k_{22} &amp; \cdots &amp; k_{2m} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
k_{n1} &amp; k_{n2} &amp; \cdots &amp; k_{nm}
\end{bmatrix}\]</span>=<span class="math display">\[\begin{bmatrix}
|z_{11}-y_{1}| &amp; |z_{2}-y_{1}| &amp; \cdots &amp; |z_{1m}-y_{1}| \\
|z_{21}-y_{2}| &amp; |z_{22}-y_{2}| &amp; \cdots &amp; |z_{2m}-y_{2}| \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
|z_{n1}-y_{n}| &amp; |z_{n2}-y_{n}| &amp; \cdots &amp; |z_{nm}-z_{n}|
\end{bmatrix}\]</span> <span
class="math display">\[a=\min\limits_i\min\limits_k|x_0(k)-x_i(k)|,b=\max\limits_i\max\limits_k|x_0(k)-x_i(k)|.\]</span></p>
<table style="width:100%;">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;">候选人</th>
<th style="text-align: center;">$ Y $</th>
<th style="text-align: center;">$ Z_1 $</th>
<th style="text-align: center;">$ Z_2 $</th>
<th style="text-align: center;">$ Z_3 $</th>
<th style="text-align: center;">$ Z_4 $</th>
<th style="text-align: center;"><span class="math inline">\(|z_{k1} -
y_k|\)</span></th>
<th style="text-align: center;"><span class="math inline">\(|z_{k2} -
y_k|\)</span></th>
<th style="text-align: center;"><span class="math inline">\(|z_{k3} -
y_k|\)</span></th>
<th style="text-align: center;"><span class="math inline">\(|z_{k4} -
y_k|\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A</td>
<td style="text-align: center;">1.17</td>
<td style="text-align: center;">1.17</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">1.17</td>
<td style="text-align: center;">1.17</td>
<td style="text-align: center;">1.17</td>
</tr>
<tr>
<td style="text-align: center;">B</td>
<td style="text-align: center;">2.45</td>
<td style="text-align: center;">1.04</td>
<td style="text-align: center;">0.90</td>
<td style="text-align: center;">2.45</td>
<td style="text-align: center;">1.00</td>
<td style="text-align: center;">1.41</td>
<td style="text-align: center;">1.55</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">1.45</td>
</tr>
<tr>
<td style="text-align: center;">C</td>
<td style="text-align: center;">2.10</td>
<td style="text-align: center;">0.78</td>
<td style="text-align: center;">2.10</td>
<td style="text-align: center;">0.55</td>
<td style="text-align: center;">2.00</td>
<td style="text-align: center;">1.32</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">1.55</td>
<td style="text-align: center;">0.10</td>
</tr>
</tbody>
</table>
<p>易得 $ a = 0, b = 1.55 $</p>
<p><span class="math display">\[\xi_i(k) = y(x_0(k), x_i(k)) = \frac{0 +
0.5 \times 1.55}{|x_0(k) - x_i(k)| + 0.5 \times 1.55} =
\frac{0.775}{|x_0(k) - x_i(k)| + 0.775}\]</span></p>
<table style="width:100%;">
<colgroup>
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;">候选人</th>
<th style="text-align: center;"><span class="math inline">\(\vert
z_{k1}-y_k \vert\)</span></th>
<th style="text-align: center;"><span class="math inline">\(\vert
z_{k2}-y_k \vert\)</span></th>
<th style="text-align: center;"><span class="math inline">\(\vert
z_{k3}-y_k \vert\)</span></th>
<th style="text-align: center;"><span class="math inline">\(\vert
z_{k4}-y_k \vert\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(\xi_1\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(\xi_2\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(\xi_3\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(\xi_4\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">1.17</td>
<td style="text-align: center;">1.17</td>
<td style="text-align: center;">1.17</td>
<td style="text-align: center;">1.000</td>
<td style="text-align: center;">0.398</td>
<td style="text-align: center;">0.398</td>
<td style="text-align: center;">0.398</td>
</tr>
<tr>
<td style="text-align: center;">B</td>
<td style="text-align: center;">1.41</td>
<td style="text-align: center;">1.55</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">1.45</td>
<td style="text-align: center;">0.355</td>
<td style="text-align: center;">0.333</td>
<td style="text-align: center;">1.000</td>
<td style="text-align: center;">0.348</td>
</tr>
<tr>
<td style="text-align: center;">C</td>
<td style="text-align: center;">1.32</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">1.55</td>
<td style="text-align: center;">0.10</td>
<td style="text-align: center;">0.370</td>
<td style="text-align: center;">1.000</td>
<td style="text-align: center;">0.333</td>
<td style="text-align: center;">0.886</td>
</tr>
</tbody>
</table>
<ol start="5" type="1">
<li>计算关联度<br />
<span class="math display">\[r_i = \frac{1}{n} \sum_{k=1}^n \xi_i(k) =
\frac{1}{n} \sum_{k=1}^n y(x_0(k), x_i(k))\]</span></li>
</ol>
<table>
<thead>
<tr>
<th style="text-align: center;">候选人</th>
<th style="text-align: center;"><span
class="math inline">\(\xi_1\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(\xi_2\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(\xi_3\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(\xi_4\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A</td>
<td style="text-align: center;">1.000</td>
<td style="text-align: center;">0.398</td>
<td style="text-align: center;">0.398</td>
<td style="text-align: center;">0.398</td>
</tr>
<tr>
<td style="text-align: center;">B</td>
<td style="text-align: center;">0.355</td>
<td style="text-align: center;">0.333</td>
<td style="text-align: center;">1.000</td>
<td style="text-align: center;">0.348</td>
</tr>
<tr>
<td style="text-align: center;">C</td>
<td style="text-align: center;">0.370</td>
<td style="text-align: center;">1.000</td>
<td style="text-align: center;">0.333</td>
<td style="text-align: center;">0.886</td>
</tr>
<tr>
<td style="text-align: center;"><strong><span
class="math inline">\(r\)</span></strong></td>
<td style="text-align: center;"><strong>0.575</strong></td>
<td style="text-align: center;"><strong>0.577</strong></td>
<td style="text-align: center;"><strong>0.577</strong></td>
<td style="text-align: center;"><strong>0.544</strong></td>
</tr>
</tbody>
</table>
<ol start="6" type="1">
<li>计算指标权重<br />
<span class="math display">\[w_i = \frac{r_i}{\sum\limits_{k=1}^m r_k}
(i=1,2,\cdots,m)\]</span></li>
</ol>
<table>
<thead>
<tr>
<th style="text-align: center;">候选人</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">脾气（争吵次数）</th>
<th style="text-align: center;">身高</th>
<th style="text-align: center;">体重</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span
class="math inline">\(r\)</span></td>
<td style="text-align: center;">0.575</td>
<td style="text-align: center;">0.577</td>
<td style="text-align: center;">0.577</td>
<td style="text-align: center;">0.544</td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(w\)</span></td>
<td style="text-align: center;">0.253</td>
<td style="text-align: center;">0.254</td>
<td style="text-align: center;">0.254</td>
<td style="text-align: center;">0.239</td>
</tr>
</tbody>
</table>
<ol start="7" type="1">
<li>计算得分并归一化<br />
<span class="math display">\[S_i = \sum_{k=1}^m Z_{ik}\cdot w_i, \tilde
S_i = \frac{S_i}{\sum\limits_{k=1}^m S_k} (i=1,2,\cdots,n)\]</span></li>
</ol>
<table>
<thead>
<tr>
<th style="text-align: center;">候选人</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">脾气（争吵次数）</th>
<th style="text-align: center;">身高</th>
<th style="text-align: center;">体重</th>
<th style="text-align: center;">得分</th>
<th style="text-align: center;">归一化得分</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A</td>
<td style="text-align: center;">1.17</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">0.296</td>
<td style="text-align: center;">0.099</td>
</tr>
<tr>
<td style="text-align: center;">B</td>
<td style="text-align: center;">1.04</td>
<td style="text-align: center;">0.90</td>
<td style="text-align: center;">2.45</td>
<td style="text-align: center;">1.00</td>
<td style="text-align: center;">1.353</td>
<td style="text-align: center;"><strong>0.451</strong></td>
</tr>
<tr>
<td style="text-align: center;">C</td>
<td style="text-align: center;">0.78</td>
<td style="text-align: center;">2.10</td>
<td style="text-align: center;">0.55</td>
<td style="text-align: center;">2.00</td>
<td style="text-align: center;">1.348</td>
<td style="text-align: center;">0.450</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>明星K依然选择了B</strong></li>
</ul>
<h1 id="灰色关联分析算法的matlab代码">灰色关联分析算法的Matlab代码</h1>
<h2 id="灰色关联分析例题的matlab代码">灰色关联分析例题的matlab代码</h2>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 灰色关联分析用于系统分析例题的讲解</span></span><br><span class="line">clear;clc</span><br><span class="line"><span class="comment">% A=[55 24 10;65 38 22;75 40 18;100 50 20]</span></span><br><span class="line">A=input(<span class="string">&#x27;请输入初始矩阵=&#x27;</span>)  <span class="comment">% 输入初始矩阵</span></span><br><span class="line">Mean = <span class="built_in">mean</span>(A);  <span class="comment">% 求出每一列的均值以供后续的数据预处理</span></span><br><span class="line">A = A ./ <span class="built_in">repmat</span>(Mean,<span class="built_in">size</span>(A,<span class="number">1</span>),<span class="number">1</span>);  <span class="comment">%size(A,1)=6, repmat(Mean,6,1)可以将矩阵进行复制，复制为和A同等大小，然后使用点除（对应元素相除），这些在第一讲层次分析法都讲过</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;预处理后的矩阵为：&#x27;</span>); <span class="built_in">disp</span>(A)</span><br><span class="line">Y = A(:,<span class="number">1</span>);  <span class="comment">% 母序列</span></span><br><span class="line">X = A(:,<span class="number">2</span>:<span class="keyword">end</span>); <span class="comment">% 子序列</span></span><br><span class="line">absX0_Xi = <span class="built_in">abs</span>(X - <span class="built_in">repmat</span>(Y,<span class="number">1</span>,<span class="built_in">size</span>(X,<span class="number">2</span>)))  <span class="comment">% 计算|X0-Xi|矩阵(在这里我们把X0定义为了Y)</span></span><br><span class="line">a = <span class="built_in">min</span>(<span class="built_in">min</span>(absX0_Xi))    <span class="comment">% 计算两级最小差a</span></span><br><span class="line">b = <span class="built_in">max</span>(<span class="built_in">max</span>(absX0_Xi))  <span class="comment">% 计算两级最大差b</span></span><br><span class="line">rho = <span class="number">0.5</span>; <span class="comment">% 分辨系数取0.5</span></span><br><span class="line"><span class="built_in">gamma</span> = (a+rho*b) ./ (absX0_Xi  + rho*b)  <span class="comment">% 计算子序列中各个指标与母序列的关联系数</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;子序列中各个指标的灰色关联度分别为：&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(<span class="built_in">mean</span>(<span class="built_in">gamma</span>))</span><br></pre></td></tr></table></figure>
<h2 id="灰色关联评价例题的matlab代码">灰色关联评价例题的matlab代码</h2>
<h3 id="主脚本">主脚本</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">clear;clc</span><br><span class="line"><span class="comment">%%  1.判断是否需要正向化</span></span><br><span class="line"><span class="comment">% A=[9 10 175 120;8 7 164 80;6 3 157 90]</span></span><br><span class="line">X=input(<span class="string">&#x27;指标矩阵A=&#x27;</span>);    <span class="comment">%%输入判断矩阵</span></span><br><span class="line">[n,m] = <span class="built_in">size</span>(X);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;共有&#x27;</span> num2str(n) <span class="string">&#x27;个评价对象, &#x27;</span> num2str(m) <span class="string">&#x27;个评价指标&#x27;</span>]) </span><br><span class="line">Judge = input([<span class="string">&#x27;这&#x27;</span> num2str(m) <span class="string">&#x27;个指标是否需要经过正向化处理，需要请输入1 ，不需要输入0：  &#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> Judge == <span class="number">1</span></span><br><span class="line">    Position = input(<span class="string">&#x27;请输入需要正向化处理的指标所在的列，例如第2、3、6三列需要处理，那么你需要输入[2,3,6]： &#x27;</span>); <span class="comment">%[2,3,4]</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;请输入需要处理的这些列的指标类型（1：极小型， 2：中间型， 3：区间型） &#x27;</span>)</span><br><span class="line">    Type = input(<span class="string">&#x27;例如：第2列是极小型，第3列是区间型，第6列是中间型，就输入[1,3,2]：  &#x27;</span>); <span class="comment">%[2,1,3]</span></span><br><span class="line">    <span class="comment">% 注意，Position和Type是两个同维度的行向量</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">size</span>(Position,<span class="number">2</span>)  <span class="comment">%这里需要对这些列分别处理，因此我们需要知道一共要处理的次数，即</span></span><br><span class="line">        <span class="comment">% 循环的次数</span></span><br><span class="line">        X(:,Position(<span class="built_in">i</span>)) = Positivization(X(:,Position(<span class="built_in">i</span>)),Type(<span class="built_in">i</span>),Position(<span class="built_in">i</span>));</span><br><span class="line">    <span class="comment">% Positivization是我们自己定义的函数，其作用是进行正向化，其一共接收三个参数</span></span><br><span class="line">    <span class="comment">% 第一个参数是要正向化处理的那一列向量 X(:,Position(i))   回顾上一讲的知识，X(:,n)表示取第n列的全部元素</span></span><br><span class="line">    <span class="comment">% 第二个参数是对应的这一列的指标类型（1：极小型， 2：中间型， 3：区间型）</span></span><br><span class="line">    <span class="comment">% 第三个参数是告诉函数我们正在处理的是原始矩阵中的哪一列</span></span><br><span class="line">    <span class="comment">% 该函数有一个返回值，它返回正向化之后的指标，我们可以将其直接赋值给我们原始要处理的那一列向量</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;正向化后的矩阵 X = &#x27;</span>)</span><br><span class="line">    <span class="built_in">disp</span>(X)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 对正向化后的矩阵进行预处理</span></span><br><span class="line">Mean = <span class="built_in">mean</span>(X);  <span class="comment">% 求出每一列的均值以供后续的数据预处理</span></span><br><span class="line">Z = X ./ <span class="built_in">repmat</span>(Mean,<span class="built_in">size</span>(X,<span class="number">1</span>),<span class="number">1</span>);  </span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;预处理后的矩阵为：&#x27;</span>); <span class="built_in">disp</span>(Z)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 构造母序列和子序列</span></span><br><span class="line">Y = <span class="built_in">max</span>(Z,[],<span class="number">2</span>);  <span class="comment">% 母序列为虚拟的，用每一行的最大值构成的列向量表示母序列</span></span><br><span class="line">X = Z; <span class="comment">% 子序列就是预处理后的数据矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算得分</span></span><br><span class="line">absX0_Xi = <span class="built_in">abs</span>(X - <span class="built_in">repmat</span>(Y,<span class="number">1</span>,<span class="built_in">size</span>(X,<span class="number">2</span>)))  <span class="comment">% 计算|X0-Xi|矩阵</span></span><br><span class="line">a = <span class="built_in">min</span>(<span class="built_in">min</span>(absX0_Xi))    <span class="comment">% 计算两级最小差a</span></span><br><span class="line">b = <span class="built_in">max</span>(<span class="built_in">max</span>(absX0_Xi))  <span class="comment">% 计算两级最大差b</span></span><br><span class="line">rho = <span class="number">0.5</span>; <span class="comment">% 分辨系数取0.5</span></span><br><span class="line"><span class="built_in">gamma</span> = (a+rho*b) ./ (absX0_Xi  + rho*b)  <span class="comment">% 计算子序列中各个指标与母序列的关联系数</span></span><br><span class="line">weight = <span class="built_in">mean</span>(<span class="built_in">gamma</span>) / sum(<span class="built_in">mean</span>(<span class="built_in">gamma</span>));  <span class="comment">% 利用子序列中各个指标的灰色关联度计算权重</span></span><br><span class="line">score = sum(X .* <span class="built_in">repmat</span>(weight,<span class="built_in">size</span>(X,<span class="number">1</span>),<span class="number">1</span>),<span class="number">2</span>);   <span class="comment">% 未归一化的得分</span></span><br><span class="line">stand_S = score / sum(score);   <span class="comment">% 归一化后的得分</span></span><br><span class="line">[sorted_S,index] = <span class="built_in">sort</span>(stand_S ,<span class="string">&#x27;descend&#x27;</span>) <span class="comment">% 进行排序</span></span><br></pre></td></tr></table></figure>
<h4 id="主函数">主函数</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% function [输出变量] = 函数名称(输入变量)  </span></span><br><span class="line"><span class="comment">% 函数的中间部分都是函数体</span></span><br><span class="line"><span class="comment">% 函数的最后要用end结尾</span></span><br><span class="line"><span class="comment">% 输出变量和输入变量可以有多个，用逗号隔开</span></span><br><span class="line"><span class="comment">% function [a,b,c]=test(d,e,f)</span></span><br><span class="line"><span class="comment">%     a=d+e;</span></span><br><span class="line"><span class="comment">%     b=e+f;</span></span><br><span class="line"><span class="comment">%     c=f+d;</span></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line"><span class="comment">% 自定义的函数要单独放在一个m文件中，不可以直接放在主函数里面（和其他大多数语言不同）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Positivization</span><span class="params">(x,type,i)</span></span></span><br><span class="line"><span class="comment">% 输入变量有三个：</span></span><br><span class="line"><span class="comment">% x：需要正向化处理的指标对应的原始列向量</span></span><br><span class="line"><span class="comment">% type： 指标的类型（1：极小型， 2：中间型， 3：区间型）</span></span><br><span class="line"><span class="comment">% i: 正在处理的是原始矩阵中的哪一列</span></span><br><span class="line"><span class="comment">% 输出变量posit_x表示：正向化后的列向量</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span> == <span class="number">1</span>  <span class="comment">%极小型</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列是极小型，正在正向化&#x27;</span>] )</span><br><span class="line">        posit_x = Min2Max(x);  <span class="comment">%调用Min2Max函数来正向化</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列极小型正向化处理完成&#x27;</span>] )</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~&#x27;</span>)</span><br><span class="line">    <span class="keyword">elseif</span> <span class="built_in">type</span> == <span class="number">2</span>  <span class="comment">%中间型</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列是中间型&#x27;</span>] )</span><br><span class="line">        best = input(<span class="string">&#x27;请输入最佳的那一个值： &#x27;</span>);</span><br><span class="line">        posit_x = Mid2Max(x,best);</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列中间型正向化处理完成&#x27;</span>] )</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~&#x27;</span>)</span><br><span class="line">    <span class="keyword">elseif</span> <span class="built_in">type</span> == <span class="number">3</span>  <span class="comment">%区间型</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列是区间型&#x27;</span>] )</span><br><span class="line">        a = input(<span class="string">&#x27;请输入区间的下界： &#x27;</span>);</span><br><span class="line">        b = input(<span class="string">&#x27;请输入区间的上界： &#x27;</span>); </span><br><span class="line">        posit_x = Inter2Max(x,a,b);</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列区间型正向化处理完成&#x27;</span>] )</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;没有这种类型的指标，请检查Type向量中是否有除了1、2、3之外的其他值&#x27;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h5 id="子函数">子函数</h5>
<ol type="1">
<li><p>Min2Max函数 <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Min2Max</span><span class="params">(x)</span></span></span><br><span class="line">    posit_x = <span class="built_in">max</span>(x) - x;</span><br><span class="line">     <span class="comment">%posit_x = 1 ./ x;    %如果x全部都大于0，也可以这样正向化</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>Mid2Max函数 <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Mid2Max</span><span class="params">(x,best)</span></span></span><br><span class="line">    M = <span class="built_in">max</span>(<span class="built_in">abs</span>(x-best));</span><br><span class="line">    posit_x = <span class="number">1</span> - <span class="built_in">abs</span>(x-best) / M;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>Inter2Max函数 <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Inter2Max</span><span class="params">(x,a,b)</span></span></span><br><span class="line">    r_x = <span class="built_in">size</span>(x,<span class="number">1</span>);  <span class="comment">% row of x </span></span><br><span class="line">    M = <span class="built_in">max</span>([a-<span class="built_in">min</span>(x),<span class="built_in">max</span>(x)-b]);</span><br><span class="line">    posit_x = <span class="built_in">zeros</span>(r_x,<span class="number">1</span>);   <span class="comment">%zeros函数用法: zeros(3)  zeros(3,1)  ones(3)</span></span><br><span class="line">    <span class="comment">% 初始化posit_x全为0  初始化的目的是节省处理时间</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: r_x</span><br><span class="line">        <span class="keyword">if</span> x(<span class="built_in">i</span>) &lt; a</span><br><span class="line">           posit_x(<span class="built_in">i</span>) = <span class="number">1</span>-(a-x(<span class="built_in">i</span>))/M;</span><br><span class="line">        <span class="keyword">elseif</span> x(<span class="built_in">i</span>) &gt; b</span><br><span class="line">           posit_x(<span class="built_in">i</span>) = <span class="number">1</span>-(x(<span class="built_in">i</span>)-b)/M;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">           posit_x(<span class="built_in">i</span>) = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<h1 id="灰色关联分析算法的python代码">灰色关联分析算法的python代码</h1>
<h2 id="灰色关联分析例题的python代码">灰色关联分析例题的python代码</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请输入初始矩阵[[55, 24, 10], [65, 38, 22], [75, 40, 18], [100, 50, 20]]</span></span><br><span class="line">A = np.array(<span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入初始矩阵=&#x27;</span>)))  <span class="comment"># 假设输入的形式是合法的Python列表形式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求出每一列的均值以供后续的数据预处理</span></span><br><span class="line">Mean = np.mean(A, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预处理后的矩阵</span></span><br><span class="line">A_norm = A / Mean</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;预处理后的矩阵为：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(A_norm)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 母序列</span></span><br><span class="line">Y = A_norm[:, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子序列</span></span><br><span class="line">X = A_norm[:, <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算|X0-Xi|矩阵(在这里我们把X0定义为了Y)</span></span><br><span class="line">absX0_Xi = np.<span class="built_in">abs</span>(X - np.tile(Y.reshape(-<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, X.shape[<span class="number">1</span>])))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算两级最小差a</span></span><br><span class="line">a = np.<span class="built_in">min</span>(absX0_Xi)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算两级最大差b</span></span><br><span class="line">b = np.<span class="built_in">max</span>(absX0_Xi)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分辨系数取0.5</span></span><br><span class="line">rho = <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算子序列中各个指标与母序列的关联系数</span></span><br><span class="line">gamma = (a + rho * b) / (absX0_Xi + rho * b)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;子序列中各个指标的灰色关联度分别为：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.mean(gamma, axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<h2 id="灰色关联评价例题的python代码">灰色关联评价例题的python代码</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  <span class="comment"># 导入numpy库，用于进行科学计算</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从用户输入中接收参评数目和指标数目，并将输入的字符串转换为数值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入参评数目：&quot;</span>)</span><br><span class="line">n = <span class="built_in">eval</span>(<span class="built_in">input</span>())  <span class="comment"># 接收参评数目</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入指标数目：&quot;</span>)</span><br><span class="line">m = <span class="built_in">eval</span>(<span class="built_in">input</span>())  <span class="comment"># 接收指标数目</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收用户输入的类型矩阵，该矩阵指示了每个指标的类型（极大型、极小型等）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入类型矩阵：1:极大型，2：极小型，3：中间型，4：区间型&quot;</span>)</span><br><span class="line">kind = <span class="built_in">input</span>().split(<span class="string">&quot; &quot;</span>)  <span class="comment"># 将输入的字符串按空格分割，形成列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收用户输入的矩阵并转换为numpy数组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入矩阵：&quot;</span>)</span><br><span class="line">A = np.zeros(shape=(n, m))  <span class="comment"># 初始化一个n行m列的全零矩阵A</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    A[i] = <span class="built_in">input</span>().split(<span class="string">&quot; &quot;</span>)  <span class="comment"># 接收每行输入的数据</span></span><br><span class="line">    A[i] = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">float</span>, A[i]))  <span class="comment"># 将接收到的字符串列表转换为浮点数列表</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入矩阵为：\n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(A))  <span class="comment"># 打印输入的矩阵A</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 极小型指标转化为极大型指标的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">minTomax</span>(<span class="params">maxx, x</span>):</span><br><span class="line">    x = <span class="built_in">list</span>(x)  <span class="comment"># 将输入的指标数据转换为列表</span></span><br><span class="line">    ans = [[(maxx-e)] <span class="keyword">for</span> e <span class="keyword">in</span> x]  <span class="comment"># 计算最大值与每个指标值的差，并将其放入新列表中</span></span><br><span class="line">    <span class="keyword">return</span> np.array(ans)  <span class="comment"># 将列表转换为numpy数组并返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 中间型指标转化为极大型指标的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">midTomax</span>(<span class="params">bestx, x</span>):</span><br><span class="line">    x = <span class="built_in">list</span>(x)  <span class="comment"># 将输入的指标数据转换为列表</span></span><br><span class="line">    h = [<span class="built_in">abs</span>(e-bestx) <span class="keyword">for</span> e <span class="keyword">in</span> x]  <span class="comment"># 计算每个指标值与最优值之间的绝对差</span></span><br><span class="line">    M = <span class="built_in">max</span>(h)  <span class="comment"># 找到最大的差值</span></span><br><span class="line">    <span class="keyword">if</span> M == <span class="number">0</span>:</span><br><span class="line">        M = <span class="number">1</span>  <span class="comment"># 防止最大差值为0的情况</span></span><br><span class="line">    ans = [[(<span class="number">1</span>-e/M)] <span class="keyword">for</span> e <span class="keyword">in</span> h]  <span class="comment"># 计算每个差值占最大差值的比例，并从1中减去，得到新指标值</span></span><br><span class="line">    <span class="keyword">return</span> np.array(ans)  <span class="comment"># 返回处理后的numpy数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 区间型指标转化为极大型指标的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">regTomax</span>(<span class="params">lowx, highx, x</span>):</span><br><span class="line">    x = <span class="built_in">list</span>(x)  <span class="comment"># 将输入的指标数据转换为列表</span></span><br><span class="line">    M = <span class="built_in">max</span>(lowx-<span class="built_in">min</span>(x), <span class="built_in">max</span>(x)-highx)  <span class="comment"># 计算指标值超出区间的最大距离</span></span><br><span class="line">    <span class="keyword">if</span> M == <span class="number">0</span>:</span><br><span class="line">        M = <span class="number">1</span>  <span class="comment"># 防止最大距离为0的情况</span></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)):</span><br><span class="line">        <span class="keyword">if</span> x[i]&lt;lowx:</span><br><span class="line">            ans.append([(<span class="number">1</span>-(lowx-x[i])/M)])  <span class="comment"># 如果指标值小于下限，则计算其与下限的距离比例</span></span><br><span class="line">        <span class="keyword">elif</span> x[i]&gt;highx:</span><br><span class="line">            ans.append([(<span class="number">1</span>-(x[i]-highx)/M)])  <span class="comment"># 如果指标值大于上限，则计算其与上限的距离比例</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans.append([<span class="number">1</span>])  <span class="comment"># 如果指标值在区间内，则直接取为1</span></span><br><span class="line">    <span class="keyword">return</span> np.array(ans)  <span class="comment"># 返回处理后的numpy数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统一指标类型，将所有指标转化为极大型指标</span></span><br><span class="line">X = np.zeros(shape=(n, <span class="number">1</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    <span class="keyword">if</span> kind[i]==<span class="string">&quot;1&quot;</span>:  <span class="comment"># 如果当前指标为极大型，则直接使用原值</span></span><br><span class="line">        v = np.array(A[:, i])</span><br><span class="line">    <span class="keyword">elif</span> kind[i]==<span class="string">&quot;2&quot;</span>:  <span class="comment"># 如果当前指标为极小型，调用minTomax函数转换</span></span><br><span class="line">        maxA = <span class="built_in">max</span>(A[:, i])</span><br><span class="line">        v = minTomax(maxA, A[:, i])</span><br><span class="line">    <span class="keyword">elif</span> kind[i]==<span class="string">&quot;3&quot;</span>:  <span class="comment"># 如果当前指标为中间型，调用midTomax函数转换</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;类型三：请输入最优值：&quot;</span>)</span><br><span class="line">        bestA = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">        v = midTomax(bestA, A[:, i])</span><br><span class="line">    <span class="keyword">elif</span> kind[i]==<span class="string">&quot;4&quot;</span>:  <span class="comment"># 如果当前指标为区间型，调用regTomax函数转换</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;类型四：请输入区间[a, b]值a：&quot;</span>)</span><br><span class="line">        lowA = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;类型四：请输入区间[a, b]值b：&quot;</span>)</span><br><span class="line">        highA = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">        v = regTomax(lowA, highA, A[:, i])</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">0</span>:</span><br><span class="line">        X = v.reshape(-<span class="number">1</span>, <span class="number">1</span>)  <span class="comment"># 如果是第一个指标，直接替换X数组</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        X = np.hstack([X, v.reshape(-<span class="number">1</span>, <span class="number">1</span>)])  <span class="comment"># 如果不是第一个指标，则将新指标列拼接到X数组上</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;统一指标后矩阵为：\n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(X))  <span class="comment"># 打印处理后的矩阵X</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对正向化后的矩阵进行预处理</span></span><br><span class="line">Mean = np.mean(X, axis=<span class="number">0</span>)</span><br><span class="line">Z = X / Mean</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;预处理后的矩阵为：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造母序列和子序列</span></span><br><span class="line">Y = np.<span class="built_in">max</span>(Z, axis=<span class="number">1</span>)  <span class="comment"># 母序列为虚拟的，用每一行的最大值构成的列向量表示母序列</span></span><br><span class="line">X = Z  <span class="comment"># 子序列就是预处理后的数据矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算得分</span></span><br><span class="line">absX0_Xi = np.<span class="built_in">abs</span>(X - np.tile(Y.reshape(-<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, X.shape[<span class="number">1</span>])))</span><br><span class="line">a = np.<span class="built_in">min</span>(absX0_Xi)</span><br><span class="line">b = np.<span class="built_in">max</span>(absX0_Xi)</span><br><span class="line">rho = <span class="number">0.5</span>  <span class="comment"># 分辨系数取0.5</span></span><br><span class="line">gamma = (a + rho * b) / (absX0_Xi + rho * b)  <span class="comment"># 计算子序列中各个指标与母序列的关联系数</span></span><br><span class="line">weight = np.mean(gamma, axis=<span class="number">0</span>) / np.<span class="built_in">sum</span>(np.mean(gamma, axis=<span class="number">0</span>))  <span class="comment"># 利用子序列中各个指标的灰色关联度计算权重</span></span><br><span class="line">score = np.<span class="built_in">sum</span>(X * np.tile(weight, (X.shape[<span class="number">0</span>], <span class="number">1</span>)), axis=<span class="number">1</span>)   <span class="comment"># 未归一化的得分</span></span><br><span class="line">stand_S = score / np.<span class="built_in">sum</span>(score)  <span class="comment"># 归一化后的得分</span></span><br><span class="line">sorted_S = np.sort(stand_S)[::-<span class="number">1</span>]  <span class="comment"># 进行降序排序</span></span><br><span class="line">index = np.argsort(stand_S)[::-<span class="number">1</span>]  <span class="comment"># 排序后的索引</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;归一化后的得分及其索引（降序）：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(sorted_S)</span><br><span class="line"><span class="built_in">print</span>(index)</span><br></pre></td></tr></table></figure>
<p align="right">
<strong>内容编辑：杜灯</strong>
</p>
<p align="right">
<strong>内容审核：王颖</strong>
</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/02/Topsis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/02/Topsis/" class="post-title-link" itemprop="url">Topsis算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-12-02 14:10:08" itemprop="dateCreated datePublished" datetime="2025-12-02T14:10:08+08:00">2025-12-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-12-05 23:37:19" itemprop="dateModified" datetime="2025-12-05T23:37:19+08:00">2025-12-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="topsis模型引出">Topsis模型引出</h1>
<h2 id="问题的提出">问题的提出</h2>
<p>生活中我们常常要进行评价，层次分析法，是通过构造判断矩阵，确定各指标的权重，然后对指标数值进行加权来进行打分，那还有别的方法吗？</p>
<p><strong>明星Kun想找个对象，但喜欢他的人太多，不知道怎么选，经过层层考察，留下三个候选人。</strong></p>
<table>
<thead>
<tr>
<th style="text-align: center;">候选人</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">脾气（争吵次数）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A    </td>
<td style="text-align: center;">9    </td>
<td style="text-align: center;">10    </td>
</tr>
<tr>
<td style="text-align: center;">B    </td>
<td style="text-align: center;">8    </td>
<td style="text-align: center;">7    </td>
</tr>
<tr>
<td style="text-align: center;">C    </td>
<td style="text-align: center;">6    </td>
<td style="text-align: center;">3    </td>
</tr>
</tbody>
</table>
<ul>
<li>理想情况下：
<ul>
<li>最好的对象应该是颜值9，脾气3</li>
<li>最差的对象应该是颜值6，脾气10</li>
</ul></li>
<li>那怎么衡量A、B、C和最好、最差的距离呢？
<ul>
<li>把（9，3）、（6，10）作为二维平面的一个点</li>
</ul></li>
<li>距离<strong>最好点最近</strong>或者<strong>距离最差点最远</strong>的的就是综合条件最好的</li>
</ul>
<h2 id="基本概念">基本概念</h2>
<p>C.L. Hwang和 K.Yoon于1981年首次提出 TOPSIS (Technique for Order
Preference by Similarity to an Ideal
Solution)，可翻译为逼近理想解排序法，国内常简称为<strong>优劣解距离法</strong>。</p>
<p><strong>TOPSIS法</strong>是一种常用的综合评价方法，能充分利用原始数据的信息，其结果能精确地反映各评价方案之间的差距。
TOPSIS法引入了两个基本概念：</p>
<p><strong>理想解</strong>：设想的最优的解（方案），它的各个属性值都达到各备选方案中的最好的值；
<strong>负理想解</strong>：设想的最劣的解（方案），它的各个属性值都达到各备选方案中的最坏的值。</p>
<p>方案排序的规则是把各备选方案与理想解和负理想解做比较，若其中有一个方案最接近理想解，而同时又远离负理想解，则该方案是备选方案中最好的方案。<strong>TOPSIS</strong>通过最接近理想解且最远离负理想解来<strong>确定最优选择</strong>。</p>
<h1 id="topsis基本原理">Topsis基本原理</h1>
<h2 id="模型原理">模型原理</h2>
<p><strong>TOPSIS法</strong>是一种理想目标相似性的顺序选优技术，在<strong>多目标决策分析</strong>中是一种非常有效的方法。它通过归一化后（去量纲化）的数据规范化矩阵，找出多个目标中最优目标和最劣目标（分别用理想归一解化和反理想解表示），分别计算各评价目标与理想解和反理想解的距离，获得各目标与理想解的贴近度，按理想解贴近度的大小排序，以此作为评价目标优劣的依据。贴近度取值在0～1之间，该值愈接近1，表示相应的评价目标越接近最优水平；反之，该值愈接近0，表示评价目标越接近最劣水平。</p>
<h2 id="基本步骤">基本步骤</h2>
<ul>
<li>将原始矩阵正向化
<ul>
<li>将原始矩阵正向化，就是要将所有的指标类型统一转化为<strong>极大型指标</strong>。</li>
</ul></li>
<li>正向矩阵标准化
<ul>
<li>标准化的方法有很多种，其主要目的就是去除量纲的影响，保证不同评价指标在同一数量级，且数据<strong>大小排序不变</strong>。</li>
</ul></li>
<li>计算得分并归一化
<ul>
<li> <span class="math inline">\(S_i=\frac{D_i^-}{D_i^++D_i^-}\)</span>,
其中 <span class="math inline">\(S_i\)</span> 为得分，<span
class="math inline">\(D_i^+\)</span> 为评价对象与最大值的距离，<span
class="math inline">\(D_i^-\)</span> 为评价对象与最小值的距离。</li>
</ul></li>
</ul>
<h1 id="topsis-典型例题">Topsis  典型例题</h1>
<p><strong>我们继续帮明星Kun选对象</strong></p>
<p>明星Kun考虑了一下觉得光靠颜值和脾气可能考虑的还不够全面，就又加上了身高和体重两个指标，而且他认为身高165是最好，体重在90-100斤是最好。</p>
<table>
<thead>
<tr>
<th style="text-align: center;">候选人</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">脾气（争吵次数）</th>
<th style="text-align: center;">身高</th>
<th style="text-align: center;">体重</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A    </td>
<td style="text-align: center;">9    </td>
<td style="text-align: center;">10  </td>
<td style="text-align: center;">175  </td>
<td style="text-align: center;">120  </td>
</tr>
<tr>
<td style="text-align: center;">B    </td>
<td style="text-align: center;">8    </td>
<td style="text-align: center;">7    </td>
<td style="text-align: center;">164  </td>
<td style="text-align: center;">80  </td>
</tr>
<tr>
<td style="text-align: center;">C    </td>
<td style="text-align: center;">6    </td>
<td style="text-align: center;">3    </td>
<td style="text-align: center;">157  </td>
<td style="text-align: center;">90  </td>
</tr>
</tbody>
</table>
<h2 id="原始矩阵正向化">原始矩阵正向化</h2>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;">指标名称    </th>
<th style="text-align: center;">指标特点    </th>
<th style="text-align: center;">例子    </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">极大型（效益型）指标</td>
<td style="text-align: center;">越大（多）越好    </td>
<td style="text-align: center;">颜值、成绩、GDP增速    </td>
</tr>
<tr>
<td style="text-align: center;">极小型（成本型）指标</td>
<td style="text-align: center;">越小（少）越好    </td>
<td style="text-align: center;">脾气、费用、坏品率、污染程度 </td>
</tr>
<tr>
<td style="text-align: center;">中间型指标    </td>
<td style="text-align: center;">越接近某个值越好    </td>
<td style="text-align: center;">身高、水质量评估时的PH值    </td>
</tr>
<tr>
<td style="text-align: center;">区间型指标    </td>
<td style="text-align: center;">落在某个区间最好    </td>
<td style="text-align: center;">体重、体温    </td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;">指标名称    </th>
<th style="text-align: center;">公式    </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">极大型（效益型）指标    </td>
<td style="text-align: center;">/    </td>
</tr>
<tr>
<td style="text-align: center;">极小型（成本型）指标    </td>
<td style="text-align: center;"><span class="math inline">\(\tilde{x} =
\max - x\)</span>，<span
class="math inline">\(\tilde{x}\)</span>为转化后指标，<span
class="math inline">\(\max\)</span>为指标最大值，<span
class="math inline">\(x\)</span>为指标值</td>
</tr>
<tr>
<td style="text-align: center;">中间型指标    </td>
<td style="text-align: center;"><span
class="math inline">\(\{x_i\}\)</span>是一组区间型序列，最优值是<span
class="math inline">\(x_{best}\)</span>,<span
class="math inline">\(M=\max\{|x_i-x_{best}|\},\tilde{x}_i=1-\frac{|x_i-x_{best}|}{M}\)</span></td>
</tr>
<tr>
<td style="text-align: center;">区间型指标    </td>
<td style="text-align: center;"><span
class="math inline">\(\{x_i\}\)</span>是一组区间型序列，最佳区间为<span
class="math inline">\([a,b]\)</span>，正向化公式如下：<span
class="math display">\[M=\max\{a -\min\{x_i\}, \max\{x_i\} - b\},
\tilde{x}_i = \begin{cases} 1 - \frac{a - x_i}{M}, &amp; x_i &lt; a \\
1, &amp; a \leqslant x_i \leqslant b \\ 1 -\frac{x_i - b}{M}, &amp; x_i
&gt; b \end{cases}\]</span></td>
</tr>
</tbody>
</table>
<ul>
<li>将原始矩阵正向化，就是要将所有的指标类型统一转化为<strong>极大型指标</strong>。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center;">候选人</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">脾气（争吵次数）</th>
<th style="text-align: center;">身高165</th>
<th style="text-align: center;">体重90-100</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A    </td>
<td style="text-align: center;">9    </td>
<td style="text-align: center;">10    </td>
<td style="text-align: center;">175  </td>
<td style="text-align: center;">120  </td>
</tr>
<tr>
<td style="text-align: center;">B    </td>
<td style="text-align: center;">8    </td>
<td style="text-align: center;">7    </td>
<td style="text-align: center;">164  </td>
<td style="text-align: center;">80  </td>
</tr>
<tr>
<td style="text-align: center;">C    </td>
<td style="text-align: center;">6    </td>
<td style="text-align: center;">3    </td>
<td style="text-align: center;">157  </td>
<td style="text-align: center;">90  </td>
</tr>
</tbody>
</table>
<p><span class="math display">\[\Downarrow\]</span></p>
<table>
<thead>
<tr>
<th style="text-align: center;">候选人</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">脾气（争吵次数）</th>
<th style="text-align: center;">身高</th>
<th style="text-align: center;">体重</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A    </td>
<td style="text-align: center;">9    </td>
<td style="text-align: center;">0    </td>
<td style="text-align: center;">0    </td>
<td style="text-align: center;">0    </td>
</tr>
<tr>
<td style="text-align: center;">B    </td>
<td style="text-align: center;">8    </td>
<td style="text-align: center;">3    </td>
<td style="text-align: center;">0.9  </td>
<td style="text-align: center;">0.5  </td>
</tr>
<tr>
<td style="text-align: center;">C    </td>
<td style="text-align: center;">6    </td>
<td style="text-align: center;">7    </td>
<td style="text-align: center;">0.2  </td>
<td style="text-align: center;">1    </td>
</tr>
</tbody>
</table>
<h2 id="正向化矩阵标准化">正向化矩阵标准化</h2>
<ul>
<li>标准化的目的是消除不同指标量纲的影响。
<ul>
<li>假设有 $ n $ 个要评价的对象，$ m $
个评价指标（已正向化）构成的正向化矩阵如下： <span
class="math display">\[X =
\begin{bmatrix}
x_{11} &amp; \cdots &amp; x_{1m} \\
\vdots &amp; \ddots &amp; \vdots \\
x_{n1} &amp; \cdots &amp; x_{nm}
\end{bmatrix}\]</span></li>
</ul></li>
</ul>
<p>那么，对其标准化的矩阵记为 <span
class="math inline">\(Z\)</span>，<span class="math inline">\(Z\)</span>
中的每一个元素： <span class="math inline">\(z_{ij} =
\frac{x_{ij}}{\sqrt{\sum\limits_{i=1}^{n}x_{ij}^2}}\)</span>（每一个元素/<span
class="math inline">\(\sqrt{其所在列的元素的平方和}\)</span>）</p>
<ul>
<li>标准化后，还需给不同指标加上权重，采用的权重确定方法有<strong>层次分析法</strong>、<strong>熵权法</strong>、<strong>Delphi法</strong>、<strong>对数最小二乘法</strong>等。在这里认为各个指标的权重相同。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center;">候选人</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">脾气（争吵次数）</th>
<th style="text-align: center;">身高</th>
<th style="text-align: center;">体重</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A    </td>
<td style="text-align: center;">9    </td>
<td style="text-align: center;">0    </td>
<td style="text-align: center;">0    </td>
<td style="text-align: center;">0    </td>
</tr>
<tr>
<td style="text-align: center;">B    </td>
<td style="text-align: center;">8    </td>
<td style="text-align: center;">3    </td>
<td style="text-align: center;">0.9    </td>
<td style="text-align: center;">0.5    </td>
</tr>
<tr>
<td style="text-align: center;">C    </td>
<td style="text-align: center;">6    </td>
<td style="text-align: center;">7    </td>
<td style="text-align: center;">0.2    </td>
<td style="text-align: center;">1    </td>
</tr>
</tbody>
</table>
<p><span class="math display">\[\Downarrow\]</span></p>
<table>
<thead>
<tr>
<th style="text-align: center;">候选人</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">脾气（争吵次数）</th>
<th style="text-align: center;">身高</th>
<th style="text-align: center;">体重</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A    </td>
<td style="text-align: center;">0.669</td>
<td style="text-align: center;">0    </td>
<td style="text-align: center;">0    </td>
<td style="text-align: center;">0    </td>
</tr>
<tr>
<td style="text-align: center;">B    </td>
<td style="text-align: center;">0.595</td>
<td style="text-align: center;">0.394</td>
<td style="text-align: center;">0.976</td>
<td style="text-align: center;">0.447</td>
</tr>
<tr>
<td style="text-align: center;">C    </td>
<td style="text-align: center;">0.446</td>
<td style="text-align: center;">0.919</td>
<td style="text-align: center;">0.217</td>
<td style="text-align: center;">0.894</td>
</tr>
</tbody>
</table>
<h2 id="计算得分并归一化">计算得分并归一化</h2>
<ul>
<li><p>上一步得到标准化矩阵 $ Z $   <span class="math display">\[  Z =
    \begin{bmatrix}
    z_{11} &amp; \cdots &amp; z_{1m} \\
    \vdots &amp; \ddots &amp; \vdots \\
    z_{n1} &amp; \cdots &amp; z_{nm}
    \end{bmatrix}\]</span></p></li>
<li><p>定义最大值 <span
class="math display">\[Z^{+}=(Z_1^+,Z_2^+,\cdots,Z_m^+)=(\max\{z_{11},z_{21},\cdots,z_{n1}\},\max\{z_{12},z_{22},\cdots,z_{n2}\},\cdots,\max\{z_{1m},
z_{2m},\cdots, z_{nm}\})\]</span></p></li>
<li><p>定义最小值 <span
class="math display">\[Z^{-}=(Z_1^-,Z_2^-,\cdots,Z_m^-)=(\min\{z_{11},z_{21},\cdots,z_{n1}\},\min\{z_{12},z_{22},\cdots,z_{n2}\},\cdots,\min\{z_{1m},
z_{2m},\cdots, z_{nm}\})\]</span></p></li>
<li><p>定义第 $ i(i=1,2,...,n) $ 个评价对象与最大值的距离 <span
class="math inline">\(D_i^+=\sqrt{\sum\limits_{j=1}^m(Z_j^+-z_{ij})^2}\)</span></p></li>
<li><p>定义第 $ i(i=1,2,...,n) $ 个评价对象与最小值的距离 <span
class="math inline">\(D_i^{-}=\sqrt{\sum\limits_{j=1}^m(Z_j^{-}-z_{ij})^2}\)</span></p></li>
<li><p>那么，我们可以计算得出第 $ i(i=1,2,...,n) $
个评价对象未归一化的得分：  <span class="math inline">\(S_i =
\frac{D_i^-}{D_i^++D_i^-}\)</span></p></li>
<li><p>很明显 <span class="math inline">\(0\leqslant
S_i\leqslant1\)</span>，且 $ S_i $ 越大 $ D_i^+ $
越小，即越接近最大值</p></li>
<li><p>我们可以将得分归一化并换成百分制：     <span
class="math display">\[  S_i = \frac{S_i}{\sum\limits_{i=1}^n S_i}
\times 100\]</span></p></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center;">候选人    </th>
<th style="text-align: center;">颜值    </th>
<th style="text-align: center;">脾气（争吵次数）</th>
<th style="text-align: center;">身高    </th>
<th style="text-align: center;">体重    </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A    </td>
<td style="text-align: center;">0.669    </td>
<td style="text-align: center;">0    </td>
<td style="text-align: center;">0    </td>
<td style="text-align: center;">0    </td>
</tr>
<tr>
<td style="text-align: center;">B    </td>
<td style="text-align: center;">0.595    </td>
<td style="text-align: center;">0.394    </td>
<td style="text-align: center;">0.976    </td>
<td style="text-align: center;">0.447    </td>
</tr>
<tr>
<td style="text-align: center;">C    </td>
<td style="text-align: center;">0.446    </td>
<td style="text-align: center;">0.919    </td>
<td style="text-align: center;">0.217    </td>
<td style="text-align: center;">0.894    </td>
</tr>
</tbody>
</table>
<p><span class="math display">\[\Downarrow\]</span></p>
<table>
<thead>
<tr>
<th style="text-align: center;">候选人</th>
<th style="text-align: center;">得分</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A</td>
<td style="text-align: center;">0.122</td>
</tr>
<tr>
<td style="text-align: center;">B</td>
<td style="text-align: center;">0.624</td>
</tr>
<tr>
<td style="text-align: center;">C</td>
<td style="text-align: center;">0.622</td>
</tr>
</tbody>
</table>
<p><span class="math display">\[\Downarrow\]</span></p>
<table>
<thead>
<tr>
<th style="text-align: center;">候选人</th>
<th style="text-align: center;">得分</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A</td>
<td style="text-align: center;">8.9</td>
</tr>
<tr>
<td style="text-align: center;">B</td>
<td style="text-align: center;">45.7</td>
</tr>
<tr>
<td style="text-align: center;">C</td>
<td style="text-align: center;">45.5</td>
</tr>
</tbody>
</table>
<p><strong>明星K选择了B！！！</strong></p>
<h1 id="topsis法的matlab代码">Topsis法的Matlab代码</h1>
<h2 id="主代码">主代码</h2>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">clear;clc</span><br><span class="line"><span class="comment">%%  1.判断是否需要正向化</span></span><br><span class="line"><span class="comment">% A=[9,10,175,120;8,7,164,80;6,3,157,90]</span></span><br><span class="line">X=input(<span class="string">&#x27;指标矩阵A=&#x27;</span>);    <span class="comment">%%输入判断矩阵</span></span><br><span class="line">[n,m] = <span class="built_in">size</span>(X);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;共有&#x27;</span> num2str(n) <span class="string">&#x27;个评价对象, &#x27;</span> num2str(m) <span class="string">&#x27;个评价指标&#x27;</span>]) </span><br><span class="line">Judge = input([<span class="string">&#x27;这&#x27;</span> num2str(m) <span class="string">&#x27;个指标是否需要经过正向化处理，需要请输入1 ，不需要输入0：  &#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> Judge == <span class="number">1</span></span><br><span class="line">    Position = input(<span class="string">&#x27;请输入需要正向化处理的指标所在的列，例如第2、3、6三列需要处理，那么你需要输入[2,3,6]： &#x27;</span>); <span class="comment">%[2,3,4]</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;请输入需要处理的这些列的指标类型（1：极小型， 2：中间型， 3：区间型） &#x27;</span>)</span><br><span class="line">    Type = input(<span class="string">&#x27;例如：第2列是极小型，第3列是区间型，第6列是中间型，就输入[1,3,2]：  &#x27;</span>); <span class="comment">%[1,2,3]</span></span><br><span class="line">    <span class="comment">% 注意，Position和Type是两个同维度的行向量</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">size</span>(Position,<span class="number">2</span>)  <span class="comment">%这里需要对这些列分别处理，因此我们需要知道一共要处理的次数，即</span></span><br><span class="line">        <span class="comment">% 循环的次数</span></span><br><span class="line">        X(:,Position(<span class="built_in">i</span>)) = Positivization(X(:,Position(<span class="built_in">i</span>)),Type(<span class="built_in">i</span>),Position(<span class="built_in">i</span>));</span><br><span class="line">    <span class="comment">% Positivization是我们自己定义的函数，其作用是进行正向化，其一共接收三个参数</span></span><br><span class="line">    <span class="comment">% 第一个参数是要正向化处理的那一列向量 X(:,Position(i))   回顾上一讲的知识，X(:,n)表示取第n列的全部元素</span></span><br><span class="line">    <span class="comment">% 第二个参数是对应的这一列的指标类型（1：极小型， 2：中间型， 3：区间型）</span></span><br><span class="line">    <span class="comment">% 第三个参数是告诉函数我们正在处理的是原始矩阵中的哪一列</span></span><br><span class="line">    <span class="comment">% 该函数有一个返回值，它返回正向化之后的指标，我们可以将其直接赋值给我们原始要处理的那一列向量</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;正向化后的矩阵 X = &#x27;</span>)</span><br><span class="line">    <span class="built_in">disp</span>(X)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 2.对正向化后的矩阵进行标准化</span></span><br><span class="line">Z = X ./ <span class="built_in">repmat</span>(sum(X.*X) .^ <span class="number">0.5</span>, n, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;标准化矩阵 Z = &#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(Z)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 3.计算与最大值的距离和最小值的距离，并算出得分</span></span><br><span class="line">D_P = sum([(Z - <span class="built_in">repmat</span>(<span class="built_in">max</span>(Z),n,<span class="number">1</span>)) .^ <span class="number">2</span> ],<span class="number">2</span>) .^ <span class="number">0.5</span>;   <span class="comment">% D+ 与最大值的距离向量</span></span><br><span class="line">D_N = sum([(Z - <span class="built_in">repmat</span>(<span class="built_in">min</span>(Z),n,<span class="number">1</span>)) .^ <span class="number">2</span> ],<span class="number">2</span>) .^ <span class="number">0.5</span>;   <span class="comment">% D- 与最小值的距离向量</span></span><br><span class="line">S = D_N ./ (D_P+D_N);    <span class="comment">% 未归一化的得分</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;最后的得分为：&#x27;</span>)</span><br><span class="line">stand_S = <span class="number">100</span>*S / sum(S)</span><br><span class="line">[sorted_S,index] = <span class="built_in">sort</span>(stand_S ,<span class="string">&#x27;descend&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% sort(A)若A是向量不管是列还是行向量，默认都是对A进行升序排列。sort(A)是默认的升序，而sort(A,&#x27;descend&#x27;)是降序排序。</span></span><br><span class="line"><span class="comment">% sort(A)若A是矩阵，默认对A的各列进行升序排列</span></span><br><span class="line"><span class="comment">% sort(A,dim)</span></span><br><span class="line"><span class="comment">% dim=1时等效sort(A)</span></span><br><span class="line"><span class="comment">% dim=2时表示对A中的各行元素升序排列</span></span><br><span class="line"><span class="comment">% A = [2,1,3,8]</span></span><br><span class="line"><span class="comment">% Matlab中给一维向量排序是使用sort函数：sort（A），排序是按升序进行的，其中A为待排序的向量；</span></span><br><span class="line"><span class="comment">% 若欲保留排列前的索引，则可用 [sA,index] = sort(A,&#x27;descend&#x27;) ，排序后，sA是排序好的向量，index是向量sA中对A的索引。</span></span><br><span class="line"><span class="comment">% sA  =  8     3     2     1</span></span><br><span class="line"><span class="comment">% index =  4     3     1     2</span></span><br></pre></td></tr></table></figure>
<h2 id="positivization函数">Positivization函数</h2>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% function [输出变量] = 函数名称(输入变量）  </span></span><br><span class="line"><span class="comment">% 函数的中间部分都是函数体</span></span><br><span class="line"><span class="comment">% 函数的最后要用end结尾</span></span><br><span class="line"><span class="comment">% 输出变量和输入变量可以有多个，用逗号隔开</span></span><br><span class="line"><span class="comment">% function [a,b,c]=test(d,e,f)</span></span><br><span class="line"><span class="comment">%     a=d+e;</span></span><br><span class="line"><span class="comment">%     b=e+f;</span></span><br><span class="line"><span class="comment">%     c=f+d;</span></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line"><span class="comment">% 自定义的函数要单独放在一个m文件中，不可以直接放在主函数里面（和其他大多数语言不同）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Positivization</span><span class="params">(x,type,i)</span></span></span><br><span class="line"><span class="comment">% 输入变量有三个：</span></span><br><span class="line"><span class="comment">% x：需要正向化处理的指标对应的原始列向量</span></span><br><span class="line"><span class="comment">% type： 指标的类型（1：极小型， 2：中间型， 3：区间型）</span></span><br><span class="line"><span class="comment">% i: 正在处理的是原始矩阵中的哪一列</span></span><br><span class="line"><span class="comment">% 输出变量posit_x表示：正向化后的列向量</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span> == <span class="number">1</span>  <span class="comment">%极小型</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列是极小型，正在正向化&#x27;</span>] )</span><br><span class="line">        posit_x = Min2Max(x);  <span class="comment">%调用Min2Max函数来正向化</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列极小型正向化处理完成&#x27;</span>] )</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~&#x27;</span>)</span><br><span class="line">    <span class="keyword">elseif</span> <span class="built_in">type</span> == <span class="number">2</span>  <span class="comment">%中间型</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列是中间型&#x27;</span>] )</span><br><span class="line">        best = input(<span class="string">&#x27;请输入最佳的那一个值： &#x27;</span>);</span><br><span class="line">        posit_x = Mid2Max(x,best);</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列中间型正向化处理完成&#x27;</span>] )</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~&#x27;</span>)</span><br><span class="line">    <span class="keyword">elseif</span> <span class="built_in">type</span> == <span class="number">3</span>  <span class="comment">%区间型</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列是区间型&#x27;</span>] )</span><br><span class="line">        a = input(<span class="string">&#x27;请输入区间的下界： &#x27;</span>);</span><br><span class="line">        b = input(<span class="string">&#x27;请输入区间的上界： &#x27;</span>); </span><br><span class="line">        posit_x = Inter2Max(x,a,b);</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列区间型正向化处理完成&#x27;</span>] )</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;没有这种类型的指标，请检查Type向量中是否有除了1、2、3之外的其他值&#x27;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% % 注意：代码文件仅供参考，一定不要直接用于自己的数模论文中</span></span><br></pre></td></tr></table></figure>
<h2 id="其他函数">其他函数</h2>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Min2Max</span><span class="params">(x)</span></span></span><br><span class="line">    posit_x = <span class="built_in">max</span>(x) - x;</span><br><span class="line">     <span class="comment">%posit_x = 1 ./ x;    %如果x全部都大于0，也可以这样正向化</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Mid2Max</span><span class="params">(x,best)</span></span></span><br><span class="line">    M = <span class="built_in">max</span>(<span class="built_in">abs</span>(x-best));</span><br><span class="line">    posit_x = <span class="number">1</span> - <span class="built_in">abs</span>(x-best) / M;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Inter2Max</span><span class="params">(x,a,b)</span></span></span><br><span class="line">    r_x = <span class="built_in">size</span>(x,<span class="number">1</span>);  <span class="comment">% row of x </span></span><br><span class="line">    M = <span class="built_in">max</span>([a-<span class="built_in">min</span>(x),<span class="built_in">max</span>(x)-b]);</span><br><span class="line">    posit_x = <span class="built_in">zeros</span>(r_x,<span class="number">1</span>);   <span class="comment">%zeros函数用法: zeros(3)  zeros(3,1)  ones(3)</span></span><br><span class="line">    <span class="comment">% 初始化posit_x全为0  初始化的目的是节省处理时间</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: r_x</span><br><span class="line">        <span class="keyword">if</span> x(<span class="built_in">i</span>) &lt; a</span><br><span class="line">           posit_x(<span class="built_in">i</span>) = <span class="number">1</span>-(a-x(<span class="built_in">i</span>))/M;</span><br><span class="line">        <span class="keyword">elseif</span> x(<span class="built_in">i</span>) &gt; b</span><br><span class="line">           posit_x(<span class="built_in">i</span>) = <span class="number">1</span>-(x(<span class="built_in">i</span>)-b)/M;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">           posit_x(<span class="built_in">i</span>) = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h1 id="topsis法的python代码">Topsis法的Python代码</h1>
<p><strong>Python代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  <span class="comment"># 导入numpy库，用于进行科学计算</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从用户输入中接收参评数目和指标数目，并将输入的字符串转换为数值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入参评数目：&quot;</span>)</span><br><span class="line">n = <span class="built_in">eval</span>(<span class="built_in">input</span>())  <span class="comment"># 接收参评数目</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入指标数目：&quot;</span>)</span><br><span class="line">m = <span class="built_in">eval</span>(<span class="built_in">input</span>())  <span class="comment"># 接收指标数目</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收用户输入的类型矩阵，该矩阵指示了每个指标的类型（极大型、极小型等）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入类型矩阵：1:极大型，2：极小型，3：中间型，4：区间型&quot;</span>)</span><br><span class="line">kind = <span class="built_in">input</span>().split(<span class="string">&quot; &quot;</span>)  <span class="comment"># 将输入的字符串按空格分割，形成列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收用户输入的矩阵并转换为numpy数组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入矩阵：&quot;</span>)</span><br><span class="line">A = np.zeros(shape=(n, m))  <span class="comment"># 初始化一个n行m列的全零矩阵A</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    A[i] = <span class="built_in">input</span>().split(<span class="string">&quot; &quot;</span>)  <span class="comment"># 接收每行输入的数据</span></span><br><span class="line">    A[i] = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">float</span>, A[i]))  <span class="comment"># 将接收到的字符串列表转换为浮点数列表</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入矩阵为：\n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(A))  <span class="comment"># 打印输入的矩阵A</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 极小型指标转化为极大型指标的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">minTomax</span>(<span class="params">maxx, x</span>):</span><br><span class="line">    x = <span class="built_in">list</span>(x)  <span class="comment"># 将输入的指标数据转换为列表</span></span><br><span class="line">    ans = [[(maxx-e)] <span class="keyword">for</span> e <span class="keyword">in</span> x]  <span class="comment"># 计算最大值与每个指标值的差，并将其放入新列表中</span></span><br><span class="line">    <span class="keyword">return</span> np.array(ans)  <span class="comment"># 将列表转换为numpy数组并返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 中间型指标转化为极大型指标的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">midTomax</span>(<span class="params">bestx, x</span>):</span><br><span class="line">    x = <span class="built_in">list</span>(x)  <span class="comment"># 将输入的指标数据转换为列表</span></span><br><span class="line">    h = [<span class="built_in">abs</span>(e-bestx) <span class="keyword">for</span> e <span class="keyword">in</span> x]  <span class="comment"># 计算每个指标值与最优值之间的绝对差</span></span><br><span class="line">    M = <span class="built_in">max</span>(h)  <span class="comment"># 找到最大的差值</span></span><br><span class="line">    <span class="keyword">if</span> M == <span class="number">0</span>:</span><br><span class="line">        M = <span class="number">1</span>  <span class="comment"># 防止最大差值为0的情况</span></span><br><span class="line">    ans = [[(<span class="number">1</span>-e/M)] <span class="keyword">for</span> e <span class="keyword">in</span> h]  <span class="comment"># 计算每个差值占最大差值的比例，并从1中减去，得到新指标值</span></span><br><span class="line">    <span class="keyword">return</span> np.array(ans)  <span class="comment"># 返回处理后的numpy数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 区间型指标转化为极大型指标的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">regTomax</span>(<span class="params">lowx, highx, x</span>):</span><br><span class="line">    x = <span class="built_in">list</span>(x)  <span class="comment"># 将输入的指标数据转换为列表</span></span><br><span class="line">    M = <span class="built_in">max</span>(lowx-<span class="built_in">min</span>(x), <span class="built_in">max</span>(x)-highx)  <span class="comment"># 计算指标值超出区间的最大距离</span></span><br><span class="line">    <span class="keyword">if</span> M == <span class="number">0</span>:</span><br><span class="line">        M = <span class="number">1</span>  <span class="comment"># 防止最大距离为0的情况</span></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)):</span><br><span class="line">        <span class="keyword">if</span> x[i]&lt;lowx:</span><br><span class="line">            ans.append([(<span class="number">1</span>-(lowx-x[i])/M)])  <span class="comment"># 如果指标值小于下限，则计算其与下限的距离比例</span></span><br><span class="line">        <span class="keyword">elif</span> x[i]&gt;highx:</span><br><span class="line">            ans.append([(<span class="number">1</span>-(x[i]-highx)/M)])  <span class="comment"># 如果指标值大于上限，则计算其与上限的距离比例</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans.append([<span class="number">1</span>])  <span class="comment"># 如果指标值在区间内，则直接取为1</span></span><br><span class="line">    <span class="keyword">return</span> np.array(ans)  <span class="comment"># 返回处理后的numpy数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统一指标类型，将所有指标转化为极大型指标</span></span><br><span class="line">X = np.zeros(shape=(n, <span class="number">1</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    <span class="keyword">if</span> kind[i]==<span class="string">&quot;1&quot;</span>:  <span class="comment"># 如果当前指标为极大型，则直接使用原值</span></span><br><span class="line">        v = np.array(A[:, i])</span><br><span class="line">    <span class="keyword">elif</span> kind[i]==<span class="string">&quot;2&quot;</span>:  <span class="comment"># 如果当前指标为极小型，调用minTomax函数转换</span></span><br><span class="line">        maxA = <span class="built_in">max</span>(A[:, i])</span><br><span class="line">        v = minTomax(maxA, A[:, i])</span><br><span class="line">    <span class="keyword">elif</span> kind[i]==<span class="string">&quot;3&quot;</span>:  <span class="comment"># 如果当前指标为中间型，调用midTomax函数转换</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;类型三：请输入最优值：&quot;</span>)</span><br><span class="line">        bestA = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">        v = midTomax(bestA, A[:, i])</span><br><span class="line">    <span class="keyword">elif</span> kind[i]==<span class="string">&quot;4&quot;</span>:  <span class="comment"># 如果当前指标为区间型，调用regTomax函数转换</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;类型四：请输入区间[a, b]值a：&quot;</span>)</span><br><span class="line">        lowA = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;类型四：请输入区间[a, b]值b：&quot;</span>)</span><br><span class="line">        highA = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">        v = regTomax(lowA, highA, A[:, i])</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">0</span>:</span><br><span class="line">        X = v.reshape(-<span class="number">1</span>, <span class="number">1</span>)  <span class="comment"># 如果是第一个指标，直接替换X数组</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        X = np.hstack([X, v.reshape(-<span class="number">1</span>, <span class="number">1</span>)])  <span class="comment"># 如果不是第一个指标，则将新指标列拼接到X数组上</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;统一指标后矩阵为：\n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(X))  <span class="comment"># 打印处理后的矩阵X</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对统一指标后的矩阵X进行标准化处理</span></span><br><span class="line">X = X.astype(<span class="string">&#x27;float&#x27;</span>)  <span class="comment"># 确保X矩阵的数据类型为浮点数</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    X[:, j] = X[:, j]/np.sqrt(<span class="built_in">sum</span>(X[:, j]**<span class="number">2</span>))  <span class="comment"># 对每一列数据进行归一化处理，即除以该列的欧几里得范数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;标准化矩阵为：\n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(X))  <span class="comment"># 打印标准化后的矩阵X</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大值最小值距离的计算</span></span><br><span class="line">x_max = np.<span class="built_in">max</span>(X, axis=<span class="number">0</span>)  <span class="comment"># 计算标准化矩阵每列的最大值</span></span><br><span class="line">x_min = np.<span class="built_in">min</span>(X, axis=<span class="number">0</span>)  <span class="comment"># 计算标准化矩阵每列的最小值</span></span><br><span class="line">d_z = np.sqrt(np.<span class="built_in">sum</span>(np.square((X - np.tile(x_max, (n, <span class="number">1</span>)))), axis=<span class="number">1</span>))  <span class="comment"># 计算每个参评对象与最优情况的距离d+</span></span><br><span class="line">d_f = np.sqrt(np.<span class="built_in">sum</span>(np.square((X - np.tile(x_min, (n, <span class="number">1</span>)))), axis=<span class="number">1</span>))  <span class="comment"># 计算每个参评对象与最劣情况的距离d-</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;每个指标的最大值:&#x27;</span>, x_max)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;每个指标的最小值:&#x27;</span>, x_min)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;d+向量:&#x27;</span>, d_z)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;d-向量:&#x27;</span>, d_f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每个参评对象的得分排名</span></span><br><span class="line">s = d_f/(d_z+d_f)  <span class="comment"># 根据d+和d-计算得分s，其中s接近于1则表示较优，接近于0则表示较劣</span></span><br><span class="line">Score = <span class="number">100</span>*s/<span class="built_in">sum</span>(s)  <span class="comment"># 将得分s转换为百分制，便于比较</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Score)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;第<span class="subst">&#123;i+<span class="number">1</span>&#125;</span>个标准化后百分制得分为：<span class="subst">&#123;Score[i]&#125;</span>&quot;</span>)  <span class="comment"># 打印每个参评对象的得分</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p align="right">
<strong>内容编辑：云舒宇，侯邵华，杜灯</strong>
</p>
<p align="right">
<strong>内容审核：王颖</strong><span
class="math inline">\(\qquad\qquad\qquad\quad\)</span>
</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/15/AnalyticHierarchyProcess/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/15/AnalyticHierarchyProcess/" class="post-title-link" itemprop="url">层次分析算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-10-15 00:00:00" itemprop="dateCreated datePublished" datetime="2025-10-15T00:00:00+08:00">2025-10-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-12-03 15:09:42" itemprop="dateModified" datetime="2025-12-03T15:09:42+08:00">2025-12-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="层次分析-模型引出">层次分析 | 模型引出</h1>
<h2 id="问题的提出">问题的提出</h2>
<p>日常生活中有很多的<strong>决策问题</strong>。决策是指在面临多种方案时需要依据一定的标准选择某一种方案。</p>
<ul>
<li>买衣服，一般要根据质量、颜色、价格、款式等方面的因素选择</li>
<li>旅游，是去风光秀丽的苏州，还是去迷人的北戴河，或者是去山水甲天下的桂林，那一般会依据景色、费用、食宿条件、旅途等因素来判断哪个地方</li>
</ul>
<p><strong>XX微博要选出一个明星作为微博之星，现在有三个候选明星A、B、C，该选择哪位明星呢？</strong></p>
<ul>
<li>考虑一个明星的成就可以看其粉丝数、颜值、作品数量、作品质量（考虑用作品来辨平均评分代替）</li>
<li>A、B、C的相关数据如下</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center;">明星</th>
<th style="text-align: center;">粉丝数</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">作品质量</th>
<th style="text-align: center;">作品数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A</td>
<td style="text-align: center;">6000w</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">6.5</td>
<td style="text-align: center;">25</td>
</tr>
<tr>
<td style="text-align: center;">B</td>
<td style="text-align: center;">3400w</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">8.1</td>
<td style="text-align: center;">46</td>
</tr>
<tr>
<td style="text-align: center;">C</td>
<td style="text-align: center;">5500w</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">7.5</td>
<td style="text-align: center;">31</td>
</tr>
</tbody>
</table>
<p><strong>直接相加？</strong> <span
class="math display">\[6000\mathrm{w}+10+25+6.5=?\]</span></p>
<ul>
<li><p>XX微博要选出一个明星作为微博之星，现在有三个候选明星A、B、C，该选择哪位明星呢？</p></li>
<li><p>怎么能让指标在同一数量级，且保证在同一指标下其差距不变？
归一化处理：指标的数组<span
class="math display">\[[a~b~c]\]</span>归一化处理得到<span
class="math display">\[a/(a+b+c),b/(a+b+c),c/(a+b+c)\]</span></p></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center;">明星</th>
<th style="text-align: center;">粉丝数</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">作品质量</th>
<th style="text-align: center;">作品数量</th>
<th style="text-align: center;">评分</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A</td>
<td style="text-align: center;">0.40</td>
<td style="text-align: center;">0.42</td>
<td style="text-align: center;">0.29</td>
<td style="text-align: center;">0.25</td>
<td style="text-align: center;">1.36</td>
</tr>
<tr>
<td style="text-align: center;">B</td>
<td style="text-align: center;">0.23</td>
<td style="text-align: center;">0.25</td>
<td style="text-align: center;">0.37</td>
<td style="text-align: center;">0.45</td>
<td style="text-align: center;">1.30</td>
</tr>
<tr>
<td style="text-align: center;">C</td>
<td style="text-align: center;">0.37</td>
<td style="text-align: center;">0.33</td>
<td style="text-align: center;">0.34</td>
<td style="text-align: center;">0.30</td>
<td style="text-align: center;">1.35</td>
</tr>
</tbody>
</table>
<p><strong>A当选？</strong></p>
<p>实际上每个指标的重要性是不同的</p>
<ul>
<li>来给每一个指标加上权重，微博公司考虑宣传效果，认为粉丝数量重要，作品数量最不重要</li>
</ul>
<table style="width:100%;">
<colgroup>
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;">明星</th>
<th style="text-align: center;">粉丝数(0.4)</th>
<th style="text-align: center;">颜值（0.3）</th>
<th style="text-align: center;">作品质量(0.2)</th>
<th style="text-align: center;">作品数量(0.1)</th>
<th style="text-align: center;">评分</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A</td>
<td style="text-align: center;">0.40*0.4</td>
<td style="text-align: center;">0.42*0.3</td>
<td style="text-align: center;">0.29*0.3</td>
<td style="text-align: center;">0.25*0.2</td>
<td style="text-align: center;">0.365</td>
</tr>
<tr>
<td style="text-align: center;">B</td>
<td style="text-align: center;">0.23*0.4</td>
<td style="text-align: center;">0.25*0.3</td>
<td style="text-align: center;">0.37*0.3</td>
<td style="text-align: center;">0.45*0.2</td>
<td style="text-align: center;">0.293</td>
</tr>
<tr>
<td style="text-align: center;">C</td>
<td style="text-align: center;">0.37*0.4</td>
<td style="text-align: center;">0.33*0.3</td>
<td style="text-align: center;">0.34*0.3</td>
<td style="text-align: center;">0.30*0.2</td>
<td style="text-align: center;">0.342</td>
</tr>
</tbody>
</table>
<p><strong>如何科学地设定权重？</strong></p>
<h2 id="基本概念">基本概念</h2>
<p>面临各种各样的方案，要进行比较、判断、评价、直至最后的决策。这个过程中都是一些主观的因素，这些因素可能由于个人情况的不同，有相应不同的比重，所以这样主观因素给数学方法的解决带来了很多的不便。</p>
<p><strong>层次分析法（Analytic Hierarchy Process，简称
AHP）是对一些较为复杂、较为模糊的问题作出决策的简易方法，它特别适用于那些难于完全定量分析的问题。它是美国运筹学家
T. L. Saaty 教授于上世纪 70
年代初期提出的一种简便、灵活而又实用的多准则决策方法。</strong></p>
<h1 id="层次分析-模型原理">层次分析 | 模型原理</h1>
<h2 id="模型原理">模型原理</h2>
<p>应用 AHP 分析决策问题时，首先要把问题
<strong>条理化、层次化</strong>，构造出一个有层次的结构模型。在这个模型下，复杂问题被分解为元素的组成部分。这些元素又按其属性及关系形成若干层次。上一层次的元素作为准则对下一层次有关元素起支配作用。这些层次可以分为三类：</p>
<ul>
<li>最高层：这一层次中只有一个元素，一般它是分析问题的
<strong>预定目标或理想结果</strong>，因此也称为目标层。</li>
<li>中间层：这一层次中包含了为实现目标所涉及的中间环节，它可以由若干个层次组成，包括所需考虑的准则、子准则，因此也称为准则层。</li>
<li>最底层：这一层次包括了为实现目标可供选择的各种措施、决策方案等，因此也称为措施层或方案层。</li>
</ul>
<h2 id="基本步骤">基本步骤</h2>
<p>运用层次分析法建模，大体上可按下面四个步骤进行：</p>
<ul>
<li>建立递阶层次结构模型</li>
<li>构造出各层次中的所有判断矩阵</li>
<li>一致性检验</li>
<li>求权重后进行评价
<img src="/images/AnalyticHierarchyProcess/层次分析图1.png" alt="图1" style="width: 100%;"></li>
</ul>
<h1 id="层次分析-典型例题">层次分析 | 典型例题</h1>
<h2 id="建立递阶层次结构模型">建立递阶层次结构模型</h2>
<p>继续来选择微博之星，其递阶层次结构模型如下：
<img src="/images/AnalyticHierarchyProcess/层次分析图2.png" alt="图1" style="width: 100%;"></p>
<h2 id="构造出各层次中的所有判断矩阵">构造出各层次中的所有判断矩阵</h2>
<ul>
<li>对指标的重要性进行<strong>两两比较</strong>，构造判断矩阵，从而科学求出权重</li>
<li>矩阵中元素 $ a_{ij} $ 的意义是，第 $ i $ 个指标相对第 $ j $
个指标的重要程度</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center;">标度</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">表示两个因素相比，具有同样重要性</td>
</tr>
<tr>
<td style="text-align: center;">3</td>
<td
style="text-align: center;">表示两个因素相比，一个因素比另一个因素<strong>稍微</strong>重要</td>
</tr>
<tr>
<td style="text-align: center;">5</td>
<td
style="text-align: center;">表示两个因素相比，一个因素比另一个因素<strong>明显</strong>重要</td>
</tr>
<tr>
<td style="text-align: center;">7</td>
<td
style="text-align: center;">表示两个因素相比，一个因素比另一个因素<strong>强烈</strong>重要</td>
</tr>
<tr>
<td style="text-align: center;">9</td>
<td
style="text-align: center;">表示两个因素相比，一个因素比另一个因素<strong>极端</strong>重要</td>
</tr>
<tr>
<td style="text-align: center;">2, 4, 6, 8</td>
<td style="text-align: center;">上述两相邻判断的中值</td>
</tr>
</tbody>
</table>
<p><strong>构造例题中的判断矩阵</strong></p>
<ul>
<li>粉丝数跟作品数量比显然明显重要，那么 <span
class="math inline">\(a_{14}=5\)</span>，反过来，作品质量相比粉丝数的重要性那就是<span
class="math inline">\(1/5,\quad a_{41}\text{为}1/5\)</span>.</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center;">明星</th>
<th style="text-align: center;">粉丝数</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">作品质量</th>
<th style="text-align: center;">作品数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A</td>
<td style="text-align: center;">6000w</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">6.5</td>
<td style="text-align: center;">25</td>
</tr>
<tr>
<td style="text-align: center;">B</td>
<td style="text-align: center;">3400w</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">8.1</td>
<td style="text-align: center;">46</td>
</tr>
<tr>
<td style="text-align: center;">C</td>
<td style="text-align: center;">5500w</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">7.5</td>
<td style="text-align: center;">31</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">粉丝数</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">作品质量</th>
<th style="text-align: center;">作品数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">粉丝数</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td style="text-align: center;">颜值</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">作品质量</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">作品数量</td>
<td style="text-align: center;">1/5</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<ul>
<li>依次对变量进行两两比较，得到完整的判断矩阵，如下表所示：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">粉丝数</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">作品质量</th>
<th style="text-align: center;">作品数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">粉丝数</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td style="text-align: center;">颜值</td>
<td style="text-align: center;">1/2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1/2</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: center;">作品质量</td>
<td style="text-align: center;">1/3</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1/2</td>
</tr>
<tr>
<td style="text-align: center;">作品数量</td>
<td style="text-align: center;">1/5</td>
<td style="text-align: center;">1/2</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<ul>
<li>因两两比较的过程中忽略了其他因素，导致最后的结果可能出现矛盾。</li>
</ul>
<p>如上表可以看出 $ a_{23} = 1/2 $ 代表在重要性上，颜值不如作品质量；$
a_{24} = 2 $
代表着颜值比作品数量重要，因此可以看出作品质量比作品数量重要，但 $
a_{34} = 1/2 $ 意味着作品质量不如作品数量重要，与上一个矛盾！</p>
<ul>
<li>所以需要一致性检验</li>
</ul>
<h2 id="一致性检验">一致性检验</h2>
<ul>
<li><span
class="math inline">\(a_{ij}=\frac{i\text{的重要程度}}{j\text{的重要程度}}\)</span>，<span
class="math inline">\(a_{ik}=\frac{i\text{的重要程度}}{k\text{的重要程度}}\)</span>,
<span
class="math inline">\(a_{kj}=\frac{k\text{的重要程度}}{j\text{的重要程度}}\)</span></li>
<li>易得 <span class="math inline">\(a_{ij}=a_{ik}a_{kj}\)</span>
且<strong>矩阵各行（列）成倍数关系</strong></li>
</ul>
<p>满足这两条的矩阵称为<strong>一致矩阵</strong>，不会出现矛盾的情况。</p>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">A</th>
<th style="text-align: center;">B</th>
<th style="text-align: center;">C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">4</td>
</tr>
<tr>
<td style="text-align: center;">B</td>
<td style="text-align: center;">1/2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: center;">C</td>
<td style="text-align: center;">1/4</td>
<td style="text-align: center;">1/2</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<ul>
<li><p>若矩阵中每个元素 $ a_{ij} &gt; 0 $ 且满足 $ a_{ij} a_{ji} = 1
$，则我们称该矩阵为<strong>正互反矩阵</strong>。<strong>在层次分析法中，我们构造的判断矩阵均是正互反矩阵。</strong></p></li>
<li><p>若正互反矩阵满足 $ a_{ik} a_{kj} = a_{ij}
$，则我们称其为<strong>一致矩阵</strong>。</p></li>
<li><p><strong>注意：</strong>
在使用判断矩阵求权重之前，必须对其进行一致性检验，以免产生矛盾。</p></li>
<li><p><strong>一致性检验原理</strong>：检验我们构造的判断矩阵和一致矩阵是否有太大差别。</p></li>
<li><p><strong>证明过程</strong> <span
class="math display">\[\begin{bmatrix}
  a_{11} &amp; \cdots &amp; a_{1n} \\
  \vdots &amp; \ddots &amp; \vdots \\
  a_{n1} &amp; \cdots &amp; a_{nn}
  \end{bmatrix}\]</span> 为一致矩阵的条件 <span
class="math display">\[\begin{cases}
  a_{ij} &gt; 0 \\
  a_{11} = a_{22} = \cdots = a_{nn} = 1 \\
  [a_{i1}, a_{i2}, \cdots, a_{in}] = k_i[a_{11}, a_{12}, \cdots, a_{1n}]
\\
  a_{ij} = a_{ik} \times a_{kj}
  \end{cases}\]</span></p></li>
<li><p>引理：<span class="math inline">\(A\)</span>为<span
class="math inline">\(n\)</span>阶方阵，且<span
class="math inline">\(r(A)=1\)</span>，则<span
class="math inline">\(A\)</span>有一个特征值为<span
class="math inline">\(tr(A)\)</span>，其余特征值均为0.</p></li>
<li><p>因为一致矩阵的各行成比例且不是零矩阵，所以一致矩阵的秩一定为1</p></li>
<li><p>由引理可知：一致矩阵有一个特征值为<span
class="math inline">\(n\)</span>，其余特征值均为0</p></li>
<li><p>易得，特征值为<span
class="math inline">\(n\)</span>时，对应的特征向量刚好为 <span
class="math display">\[k\left[ \frac{1}{a_{11}}, \frac{1}{a_{12}},
\cdots, \frac{1}{a_{1n}} \right]^T\]</span></p></li>
<li><p>引理：<span class="math inline">\(n\)</span>阶正互反矩阵<span
class="math inline">\(A\)</span>为一致矩阵时当且仅当最大特征值<span
class="math inline">\(\lambda_{\max} = n\)</span>。且当正互反矩阵<span
class="math inline">\(A\)</span>非一致时，一定满足<span
class="math inline">\(\lambda_{\max} &gt;
n\)</span>，判断矩阵越不一致时，最大特征值与<span
class="math inline">\(n\)</span>相差就越大。</p></li>
</ul>
<h3 id="一致性检验的步骤">一致性检验的步骤</h3>
<ol type="1">
<li>计算<strong>一致性指标</strong><span
class="math inline">\(CI\)</span><br />
<span
class="math display">\[CI=\frac{\lambda_{max}-n}{n-1}\]</span></li>
<li>查找对应的<strong>平均随机一致性指标</strong><span
class="math inline">\(RI\)</span></li>
</ol>
<table>
<thead>
<tr>
<th style="text-align: center;"><span
class="math inline">\(n\)</span></th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">6</th>
<th style="text-align: center;">7</th>
<th style="text-align: center;">8</th>
<th style="text-align: center;">9</th>
<th style="text-align: center;">10</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">RI</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0.52</td>
<td style="text-align: center;">0.89</td>
<td style="text-align: center;">1.12</td>
<td style="text-align: center;">1.26</td>
<td style="text-align: center;">1.36</td>
<td style="text-align: center;">1.41</td>
<td style="text-align: center;">1.46</td>
<td style="text-align: center;">1.49</td>
</tr>
</tbody>
</table>
<p>注：<span
class="math inline">\(RI\)</span>我们只需要会查表即可，不用管怎么来的。在实际运用中，<span
class="math inline">\(n\)</span>很少超过10，如果指标的个数大于10，则可考虑建立二级指标体系，或使用我们以后要学习的模糊综合评价模型。</p>
<ol start="3" type="1">
<li>计算<strong>一致性比例</strong><span
class="math inline">\(CR\)</span><br />
<span class="math display">\[CR = \frac{CI}{RI} \quad \begin{cases}
0, &amp; \text{判断矩阵为一致矩阵} \\
&lt; 0.1, &amp; \text{判断矩阵一致} \\
\geqslant 0.1, &amp; \text{判断矩阵不一致}
\end{cases}\]</span></li>
</ol>
<p>注：特征值可用matlab软件进行计算，没学过线性代数的同学也不需要担心。如果特征值中有虚数，则比较的是特征值的模长。</p>
<h3 id="对例题进行一致性检验">对例题进行一致性检验</h3>
<ul>
<li>回到刚刚微博之星</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">粉丝数</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">作品质量</th>
<th style="text-align: center;">作品数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">粉丝数</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td style="text-align: center;">颜值</td>
<td style="text-align: center;">1/2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1/2</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: center;">作品质量</td>
<td style="text-align: center;">1/3</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1/2</td>
</tr>
<tr>
<td style="text-align: center;">作品数量</td>
<td style="text-align: center;">1/5</td>
<td style="text-align: center;">1/2</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<ul>
<li>当前判断矩阵的 <span class="math inline">\(\lambda_{max} =
4.68\)</span>，<span class="math inline">\(n = 4\)</span>，求得 <span
class="math inline">\(CI = 0.227\)</span>，查表 <span
class="math inline">\(RI=0.89\)</span>，得 <span
class="math inline">\(CR = 0.255\)</span></li>
</ul>
<p><span class="math display">\[CR \geqslant 0.1\]</span></p>
<h3 id="需修改判断矩阵">需修改判断矩阵</h3>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">粉丝数</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">作品质量</th>
<th style="text-align: center;">作品数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">粉丝数</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td style="text-align: center;">颜值</td>
<td style="text-align: center;">1/2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1/2</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: center;">作品质量</td>
<td style="text-align: center;">1/3</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: center;">作品数量</td>
<td style="text-align: center;">1/5</td>
<td style="text-align: center;">1/2</td>
<td style="text-align: center;">1/2</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<ul>
<li>当前判断矩阵的 <span class="math inline">\(\lambda_{max} =
4.1128\)</span>，<span class="math inline">\(n = 4\)</span>，求得 <span
class="math inline">\(CI=0.227\)</span>，查表 <span
class="math inline">\(RI=0.89\)</span>，得 <span
class="math inline">\(CR=0.0418\)</span></li>
</ul>
<p><span class="math display">\[CR &lt; 0.1\]</span></p>
<p>通过一致性检验</p>
<h2 id="求权重">求权重</h2>
<h3 id="算术平均法求权重">算术平均法求权重</h3>
<p>第一步：将判断矩阵按照列归一化（每一个元素除以其所在列的和）</p>
<p>第二步：将归一化的各列相加（按行求和）</p>
<p>第三步：将相加后得到的向量中每个元素除以<span
class="math inline">\(n\)</span>即可得到权重向量</p>
<p>假设判断矩阵<span class="math inline">\(A = \begin{bmatrix}
a_{11} &amp; \cdots &amp; a_{1n} \\
\vdots &amp; \ddots &amp; \vdots \\
a_{n1} &amp; \cdots &amp; a_{nn}
\end{bmatrix}\)</span></p>
<p>那么算术平均法求得的权重向量 <span
class="math inline">\(w_i=\frac{1}{n}\sum\limits_{j=1}^{n}\frac{a_{ij}}{\sum\limits_{k=1}^{n}a_{kj}}\)</span>
（<span class="math inline">\(i=1,2,3,\cdots,n\)</span>）</p>
<ul>
<li><strong>用算术平均法求出微博之星的指标权重</strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">粉丝数</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">作品质量</th>
<th style="text-align: center;">作品数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">粉丝数</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td style="text-align: center;">颜值</td>
<td style="text-align: center;">1/2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1/2</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: center;">作品质量</td>
<td style="text-align: center;">1/3</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: center;">作品数量</td>
<td style="text-align: center;">1/5</td>
<td style="text-align: center;">1/2</td>
<td style="text-align: center;">1/2</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">粉丝数</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">作品质量</th>
<th style="text-align: center;">作品数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">粉丝数</td>
<td style="text-align: center;">0.492</td>
<td style="text-align: center;">0.364</td>
<td style="text-align: center;">0.600</td>
<td style="text-align: center;">0.500</td>
</tr>
<tr>
<td style="text-align: center;">颜值</td>
<td style="text-align: center;">0.246</td>
<td style="text-align: center;">0.182</td>
<td style="text-align: center;">0.100</td>
<td style="text-align: center;">0.200</td>
</tr>
<tr>
<td style="text-align: center;">作品质量</td>
<td style="text-align: center;">0.164</td>
<td style="text-align: center;">0.364</td>
<td style="text-align: center;">0.200</td>
<td style="text-align: center;">0.200</td>
</tr>
<tr>
<td style="text-align: center;">作品数量</td>
<td style="text-align: center;">0.098</td>
<td style="text-align: center;">0.091</td>
<td style="text-align: center;">0.100</td>
<td style="text-align: center;">0.100</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">权重</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">粉丝数</td>
<td style="text-align: center;">0.489</td>
</tr>
<tr>
<td style="text-align: center;">颜值</td>
<td style="text-align: center;">0.182</td>
</tr>
<tr>
<td style="text-align: center;">作品质量</td>
<td style="text-align: center;">0.232</td>
</tr>
<tr>
<td style="text-align: center;">作品数量</td>
<td style="text-align: center;">0.097</td>
</tr>
</tbody>
</table>
<h3 id="几何平均法求权重">几何平均法求权重</h3>
<p>第一步：将判断矩阵的元素按照行相乘得到一个新的列向量<br />
第二步：将新的向量的每个分量开<span
class="math inline">\(n\)</span>次方<br />
第三步：对该列向量进行归一化即可得到权重向量</p>
<p>假设判断矩阵 <span class="math inline">\(A=\begin{bmatrix} a_{11}
&amp; \cdots &amp; a_{1n} \\ \vdots &amp; \ddots &amp; \vdots \\ a_{n1}
&amp; \cdots &amp; a_{nn} \end{bmatrix}\)</span></p>
<p>那么几何平均法求得的权重向量 <span
class="math inline">\(w_i=\frac{\left(\prod\limits_{j=1}^n a_{ij}
\right)^{\frac{1}{n}}}{\sum\limits_{k=1}^{n} \left(\prod\limits_{j=1}^n
a_{kj} \right)^\frac{1}{n}},(i=1,2,\ldots,n)\)</span></p>
<ul>
<li><strong>用几何平均法求出微博之星的指标权重</strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">粉丝数</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">作品质量</th>
<th style="text-align: center;">作品数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">粉丝数</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td style="text-align: center;">颜值</td>
<td style="text-align: center;">1/2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1/2</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: center;">作品质量</td>
<td style="text-align: center;">1/3</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: center;">作品数量</td>
<td style="text-align: center;">1/5</td>
<td style="text-align: center;">1/2</td>
<td style="text-align: center;">1/2</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">行相乘后开方</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">粉丝数</td>
<td style="text-align: center;">2.34</td>
</tr>
<tr>
<td style="text-align: center;">颜值</td>
<td style="text-align: center;">0.84</td>
</tr>
<tr>
<td style="text-align: center;">作品质量</td>
<td style="text-align: center;">1.07</td>
</tr>
<tr>
<td style="text-align: center;">作品数量</td>
<td style="text-align: center;">0.47</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">权重</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">粉丝数</td>
<td style="text-align: center;">0.495</td>
</tr>
<tr>
<td style="text-align: center;">颜值</td>
<td style="text-align: center;">0.178</td>
</tr>
<tr>
<td style="text-align: center;">作品质量</td>
<td style="text-align: center;">0.227</td>
</tr>
<tr>
<td style="text-align: center;">作品数量</td>
<td style="text-align: center;">0.100</td>
</tr>
</tbody>
</table>
<h3 id="特征值法求权重">特征值法求权重</h3>
<p>一致矩阵有一个特征值 $ n $，其余特征值均为0。</p>
<p>另外，我们很容易得到，特征值为 $ n $ 时，对应的特征向量刚好为 <span
class="math inline">\(k\left[\frac{1}{a_{11}},\frac{1}{a_{12}},\cdots,\frac{1}{a_{1n}}\right]^T\)</span>
（<span class="math inline">\(k\neq 0\)</span>）</p>
<p>假如我们的判断矩阵一致性可以接受，那么我们可以仿照一致矩阵权重的求法。</p>
<p><strong>第一步：求出矩阵 $ n $
的最大特征值以及其对应的特征向量。</strong></p>
<p><strong>第二步：对求出的特征向量进行归一化即可得到我们的权重。</strong></p>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">粉丝数</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">作品质量</th>
<th style="text-align: center;">作品数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">粉丝数</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td style="text-align: center;">颜值</td>
<td style="text-align: center;">1/2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1/2</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: center;">作品质量</td>
<td style="text-align: center;">1/3</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: center;">作品数量</td>
<td style="text-align: center;">1/5</td>
<td style="text-align: center;">1/2</td>
<td style="text-align: center;">1/2</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">特征向量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">颜值</td>
<td style="text-align: center;">0.8487</td>
</tr>
<tr>
<td style="text-align: center;">作品质量</td>
<td style="text-align: center;">0.3076</td>
</tr>
<tr>
<td style="text-align: center;">作品数量</td>
<td style="text-align: center;">0.3962</td>
</tr>
<tr>
<td style="text-align: center;">作品数量</td>
<td style="text-align: center;">0.1676</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">特征向量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">颜值</td>
<td style="text-align: center;">0.493</td>
</tr>
<tr>
<td style="text-align: center;">作品质量</td>
<td style="text-align: center;">0.179</td>
</tr>
<tr>
<td style="text-align: center;">作品数量</td>
<td style="text-align: center;">0.230</td>
</tr>
<tr>
<td style="text-align: center;">作品数量</td>
<td style="text-align: center;">0.097</td>
</tr>
</tbody>
</table>
<p>最大特征值为4.1128 一致性比例<span
class="math inline">\(CR=0.1128/3=0.04\)</span> 其对应的特征向量：<span
class="math display">\[ 0.8487 \quad 0.3076 \quad 0.3962 \quad 0.1676
\]</span> 对其进行归一化得到权重：<span class="math display">\[ 0.493
\quad 0.179 \quad 0.230 \quad 0.097 \]</span></p>
<h2 id="求评分">求评分</h2>
<table>
<thead>
<tr>
<th style="text-align: center;">权重表格</th>
<th style="text-align: center;">算术平均法</th>
<th style="text-align: center;">几何平均法</th>
<th style="text-align: center;">特征值法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">粉丝数</td>
<td style="text-align: center;">0.489</td>
<td style="text-align: center;">0.495</td>
<td style="text-align: center;">0.493</td>
</tr>
<tr>
<td style="text-align: center;">颜值</td>
<td style="text-align: center;">0.182</td>
<td style="text-align: center;">0.178</td>
<td style="text-align: center;">0.179</td>
</tr>
<tr>
<td style="text-align: center;">作品质量</td>
<td style="text-align: center;">0.232</td>
<td style="text-align: center;">0.227</td>
<td style="text-align: center;">0.230</td>
</tr>
<tr>
<td style="text-align: center;">作品数量</td>
<td style="text-align: center;">0.097</td>
<td style="text-align: center;">0.100</td>
<td style="text-align: center;">0.097</td>
</tr>
</tbody>
</table>
<ul>
<li>如果选择特征值法，综合评分=0.493<span
class="math inline">\(*\)</span>粉丝数+0.179<span
class="math inline">\(*\)</span>颜值+0.230<span
class="math inline">\(*\)</span>作品质量+0.097<span
class="math inline">\(*\)</span>作品数量</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center;">明星</th>
<th style="text-align: center;">粉丝数</th>
<th style="text-align: center;">颜值</th>
<th style="text-align: center;">作品质量</th>
<th style="text-align: center;">作品数量</th>
<th style="text-align: center;">评分</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">A</td>
<td style="text-align: center;">0.40*0.493</td>
<td style="text-align: center;">0.42*0.179</td>
<td style="text-align: center;">0.29*0.23</td>
<td style="text-align: center;">0.25*0.097</td>
<td style="text-align: center;">0.363</td>
</tr>
<tr>
<td style="text-align: center;">B</td>
<td style="text-align: center;">0.23*0.493</td>
<td style="text-align: center;">0.25*0.179</td>
<td style="text-align: center;">0.37*0.23</td>
<td style="text-align: center;">0.45*0.097</td>
<td style="text-align: center;">0.287</td>
</tr>
<tr>
<td style="text-align: center;">C</td>
<td style="text-align: center;">0.37*0.493</td>
<td style="text-align: center;">0.33*0.179</td>
<td style="text-align: center;">0.34*0.23</td>
<td style="text-align: center;">0.30*0.097</td>
<td style="text-align: center;">0.349</td>
</tr>
</tbody>
</table>
<ul>
<li>A当选微博之星</li>
</ul>
<h1 id="层次分析-相关代码-matlab">层次分析 | 相关代码-Matlab</h1>
<h2 id="一致性检验代码">一致性检验代码</h2>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%A=[1 2 3 5;1/2 1 1/2 2;1/3 2 1 1/2;1/5 1/2 2 1]</span></span><br><span class="line"><span class="comment">%A=[1 2 3 5;1/2 1 1/2 2;1/3 2 1 2;1/5 1/2 1/2 1]</span></span><br><span class="line">A = input(<span class="string">&#x27;判断矩阵A=&#x27;</span>);  </span><br><span class="line"><span class="comment">%输入判断矩阵  </span></span><br><span class="line"></span><br><span class="line">[n,n] = <span class="built_in">size</span>(A);  </span><br><span class="line"><span class="comment">%获取A的行和列  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">%求出最大特征值以及对应的特征向量  </span></span><br><span class="line"></span><br><span class="line">[V,D] = eig(A);  </span><br><span class="line"><span class="comment">%V是特征向量 D是特征值构成的对角矩阵  </span></span><br><span class="line"></span><br><span class="line">Max_eig = <span class="built_in">max</span>(<span class="built_in">max</span>(D));  </span><br><span class="line"><span class="comment">%先求出每一列的最大值，再求最大值中的最大值  </span></span><br><span class="line"></span><br><span class="line">CI = (Max_eig - n) / (n<span class="number">-1</span>);  </span><br><span class="line"></span><br><span class="line">RI=[<span class="number">0</span> <span class="number">0.0001</span> <span class="number">0.52</span> <span class="number">0.89</span> <span class="number">1.12</span> <span class="number">1.26</span> <span class="number">1.36</span> <span class="number">1.41</span> <span class="number">1.46</span> <span class="number">1.49</span> <span class="number">1.52</span> <span class="number">1.54</span> <span class="number">1.56</span> <span class="number">1.58</span> <span class="number">1.59</span>];  </span><br><span class="line"></span><br><span class="line"><span class="comment">%注意：这里的RI最多支持 n = 15  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">%这里n=2时，一定是一致矩阵，所以CI = 0，我们为了避免分母为0，将这里的第二个元素改为了很接近的正数  </span></span><br><span class="line"></span><br><span class="line">CR=CI/RI(n);  </span><br><span class="line"></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;一致性指标CI=&#x27;</span>); <span class="built_in">disp</span>(CI);  </span><br><span class="line"></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;一致性比例CR=&#x27;</span>); <span class="built_in">disp</span>(CR);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> CR&lt;<span class="number">0.10</span>  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;因为CR&lt;0.10，所以该判断矩阵A的一致性可以接受！&#x27;</span>);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;注意：CR &gt;= 0.10，因此该判断矩阵A需要进行修改！&#x27;</span>);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="求权重代码">求权重代码</h2>
<ol type="1">
<li>算术平均法求权重</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%A=[1 2 3 5;1/2 1 1/2 2;1/3 2 1 2;1/5 1/2 1/2 1]</span></span><br><span class="line">A = input(<span class="string">&#x27;判断矩阵A=&#x27;</span>); <span class="comment">%输入判断矩阵  </span></span><br><span class="line">ASum = sum(A,<span class="number">1</span>); <span class="comment">%将判断矩阵每列求和  </span></span><br><span class="line">[n,n] = <span class="built_in">size</span>(A); <span class="comment">%获取A的行和列，用于对ASum复制，对应位相除归一化  </span></span><br><span class="line">Ar = <span class="built_in">repmat</span>(ASum,n,<span class="number">1</span>); <span class="comment">%复制Asum n行1列为Ar矩阵  </span></span><br><span class="line">Stand_A = A./Ar; <span class="comment">%归一化  </span></span><br><span class="line">ASumr = sum(Stand_A,<span class="number">2</span>); <span class="comment">%各列相加到同一行  </span></span><br><span class="line"><span class="built_in">disp</span>(ASumr/n); <span class="comment">%将相加后得到的向量每个元素除以n可以得到权重向量  </span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>几何平均法求权重</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">clc;  </span><br><span class="line"><span class="comment">%A=[1 2 3 5;1/2 1 1/2 2;1/3 2 1 2;1/5 1/2 1/2 1]</span></span><br><span class="line">A = input(<span class="string">&#x27;判断矩阵A=&#x27;</span>); <span class="comment">%输入判断矩阵  </span></span><br><span class="line">[n,n] = <span class="built_in">size</span>(A); <span class="comment">%获取A的行和列  </span></span><br><span class="line">prod_A = prod(A,<span class="number">2</span>); <span class="comment">%将A中每一行元素相乘得到－列向量  </span></span><br><span class="line">prod_n_A = prod_A.^(<span class="number">1</span>/n); <span class="comment">%将新的向量的每个分量开n次方等价求1/n次方  </span></span><br><span class="line">re_prod_A = prod_n_A./sum(prod_n_A); <span class="comment">%归一化处理  </span></span><br><span class="line"><span class="built_in">disp</span>(re_prod_A); <span class="comment">%展示权重结果  </span></span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>特征值法计算权重</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">clc;  </span><br><span class="line">%A=[1 2 3 5;1/2 1 1/2 2;1/3 2 1 2;1/5 1/2 1/2 1]</span><br><span class="line">A = input(&#x27;判断矩阵A=&#x27;); %输入判断矩阵  </span><br><span class="line">[n,n] = size(A); %获取A的行和列  </span><br><span class="line">%求出最大特征值以及对应的特征向量  </span><br><span class="line">[V,D] = eig(A); %V是特征向量 D是特征值构成的对角矩阵  </span><br><span class="line">Max.eig = max(max(D)); %先求出每一列的最大值，再求最大值中的最大值  </span><br><span class="line">[r,c] = find(Max.eig == D,1); %使用find()函数找出最大特征值对应的特征向量  </span><br><span class="line">%对特征向量进行归一化得到所需权重  </span><br><span class="line">disp(V(:,c)./sum(V(:,c)));</span><br></pre></td></tr></table></figure>
<h1 id="层次分析-相关代码-python">层次分析 | 相关代码-Python</h1>
<h2 id="一致性检验代码-1">一致性检验代码</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># numpy pandas matplotlib</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 定义矩阵A</span></span><br><span class="line"><span class="comment"># A = np.array([[1, 2, 3, 5], [1/2, 1, 1/2, 2], [1/3, 2, 1, 1/2], [1/5, 1/2, 2, 1]])</span></span><br><span class="line">A = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">1</span>/<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>/<span class="number">2</span>, <span class="number">2</span>], [<span class="number">1</span>/<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>/<span class="number">5</span>, <span class="number">1</span>/<span class="number">2</span>, <span class="number">1</span>/<span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">n = A.shape[<span class="number">0</span>] <span class="comment"># 获取A的行</span></span><br><span class="line"><span class="comment"># 求出最大特征值以及对应的特征向量</span></span><br><span class="line">eig_val, eig_vec = np.linalg.eig(A) <span class="comment"># eig_val是特征值，eig_vec是特征向量</span></span><br><span class="line">Max_eig = <span class="built_in">max</span>(eig_val) <span class="comment"># 求特征值的最大值</span></span><br><span class="line">CI = (Max_eig - n) / (n-<span class="number">1</span>)</span><br><span class="line">RI = [<span class="number">0</span>, <span class="number">0.0001</span>, <span class="number">0.52</span>, <span class="number">0.89</span>, <span class="number">1.12</span>, <span class="number">1.26</span>, <span class="number">1.36</span>, <span class="number">1.41</span>, <span class="number">1.46</span>, <span class="number">1.49</span>, <span class="number">1.52</span>, <span class="number">1.54</span>, <span class="number">1.56</span>, <span class="number">1.58</span>, <span class="number">1.59</span>]</span><br><span class="line"><span class="comment"># 注意，这里的RI最多支持 n = 15</span></span><br><span class="line"><span class="comment"># 这里n=2时，一定是一致矩阵，所以CI = 0，我们为了避免分母为0，将这里的第二个元素改为了很接近0的正数</span></span><br><span class="line">CR = CI / RI[n]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;一致性指标CI=&#x27;</span>, CI)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;一致性比例CR=&#x27;</span>, CR)</span><br><span class="line"><span class="keyword">if</span> CR &lt; <span class="number">0.10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;因为CR&lt;0.10，所以该判断矩阵A的一致性可以接受！&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;注意：CR &gt;= 0.10，因此该判断矩阵A需要进行修改！&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="求权重代码-1">求权重代码</h2>
<ol type="1">
<li>算术平均法求权重</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="comment"># 定义判断矩阵A  </span></span><br><span class="line">A = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">1</span>/<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>/<span class="number">2</span>, <span class="number">2</span>], [<span class="number">1</span>/<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>/<span class="number">5</span>, <span class="number">1</span>/<span class="number">2</span>, <span class="number">1</span>/<span class="number">2</span>, <span class="number">1</span>]])  </span><br><span class="line"><span class="comment"># 按列求和  </span></span><br><span class="line">ASum = np.<span class="built_in">sum</span>(A, axis=<span class="number">0</span>)  </span><br><span class="line"><span class="comment"># 获取A的行和列  </span></span><br><span class="line">n= A.shape[<span class="number">0</span>]  </span><br><span class="line"><span class="comment"># 按列归一化  </span></span><br><span class="line">Stand_A = A / ASum  </span><br><span class="line"><span class="comment"># 按行求和  </span></span><br><span class="line">ASumr = np.<span class="built_in">sum</span>(Stand_A, axis=<span class="number">1</span>)  </span><br><span class="line"><span class="comment"># 计算权重向量  </span></span><br><span class="line">weights = ASumr / n  </span><br><span class="line"><span class="built_in">print</span>(weights)</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>几何平均法求权重</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="comment"># 定义判断矩阵A  </span></span><br><span class="line">A = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">1</span>/<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>/<span class="number">2</span>, <span class="number">2</span>], [<span class="number">1</span>/<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>/<span class="number">5</span>, <span class="number">1</span>/<span class="number">2</span>, <span class="number">1</span>/<span class="number">2</span>, <span class="number">1</span>]])  </span><br><span class="line"><span class="comment"># 获取A的行和列  </span></span><br><span class="line">n= A.shape[<span class="number">0</span>]  </span><br><span class="line"><span class="comment"># 将A中每一行元素相乘得到一列向量  </span></span><br><span class="line">prod_A = np.prod(A, axis=<span class="number">1</span>)  </span><br><span class="line"><span class="comment"># 将新的向量的每个分量开n次方等价求1/n次方  </span></span><br><span class="line">prod_n_A = np.power(prod_A, <span class="number">1</span>/n)  </span><br><span class="line"><span class="comment"># 归一化处理  </span></span><br><span class="line">re_prod_A = prod_n_A / np.<span class="built_in">sum</span>(prod_n_A)  </span><br><span class="line"><span class="comment"># 展示权重结果  </span></span><br><span class="line"><span class="built_in">print</span>(re_prod_A)</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>特征值法计算权重</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="comment"># 定义判断矩阵A  </span></span><br><span class="line">A = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">1</span>/<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>/<span class="number">2</span>, <span class="number">2</span>], [<span class="number">1</span>/<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>/<span class="number">5</span>, <span class="number">1</span>/<span class="number">2</span>, <span class="number">1</span>/<span class="number">2</span>, <span class="number">1</span>]])  </span><br><span class="line"><span class="comment"># 获取A的行和列  </span></span><br><span class="line">n= A.shape[<span class="number">0</span>]  </span><br><span class="line"><span class="comment"># 求出特征值和特征向量  </span></span><br><span class="line">eig_values, eig_vectors = np.linalg.eig(A)  </span><br><span class="line"><span class="comment"># 找出最大特征值的索引  </span></span><br><span class="line">max_index = np.argmax(eig_values)  </span><br><span class="line"><span class="comment"># 找出对应的特征向量  </span></span><br><span class="line">max_vector = eig_vectors[:, max_index]  </span><br><span class="line"><span class="comment"># 对特征向量进行归一化处理，得到权重  </span></span><br><span class="line">weights = max_vector / np.<span class="built_in">sum</span>(max_vector)  </span><br><span class="line"><span class="comment"># 输出权重  </span></span><br><span class="line"><span class="built_in">print</span>(weights)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/19/AdvancedMathematics1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/19/AdvancedMathematics1/" class="post-title-link" itemprop="url">高等数学（上）知识点总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-09-19 13:54:32" itemprop="dateCreated datePublished" datetime="2025-09-19T13:54:32+08:00">2025-09-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-12-03 15:09:42" itemprop="dateModified" datetime="2025-12-03T15:09:42+08:00">2025-12-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="函数极限连续">函数、极限、连续</h1>
<h2 id="函数的概念及常见函数">函数的概念及常见函数</h2>
<h3 id="函数概念">函数概念</h3>
<p><strong>定义</strong> 设 <span class="math inline">\(x\)</span> 和
<span class="math inline">\(y\)</span> 是两个变量，<span
class="math inline">\(D\)</span> 是一个给定的数集。如果对于每个数 <span
class="math inline">\(x \in D\)</span>，变量 <span
class="math inline">\(y\)</span> 按照一定的法则总有一个确定的数值 <span
class="math inline">\(y\)</span> 和它对应，则称 <span
class="math inline">\(y\)</span> 是 <span
class="math inline">\(x\)</span> 的<strong>函数</strong>，记为   <span
class="math display">\[y=f(x), x\in D\]</span>   其中 $ x $
称为<strong>自变量</strong>，$ y $ 称为<strong>因变量</strong>，$ D $
称为函数的<strong>定义域</strong>，记作 $ D_f $，即 $ D_f = D $。</p>
<p>函数值 $ f(x) $ 的全体所构成的集合称为函数 $ f $
的<strong>值域</strong>，记作 $ R_f $ 或 <span
class="math inline">\(f(D)\)</span>，即   <span
class="math display">\[R_f = f(D) = \{y|y = f(x), x \in
D\}.\]</span></p>
<p><strong>注</strong>
函数概念有两个基本要素：定义域、对应法则（或称依赖关系）。当两个函数的定义域与对应法则完全相同时，它们就是同一函数。</p>
<p><strong>【例1】</strong> 函数   <span class="math display">\[y =
\text{sgn } x =
\begin{cases}
-1, &amp; x &lt; 0 \\
0, &amp; x = 0 \\
1, &amp; x &gt; 0
\end{cases}\]</span>   称为<strong>符号函数</strong>。</p>
<p><strong>【例2】</strong> 设 $ x $ 为任意实数，不超过 $ x $
的最大整数称为 $ x $ 的整数部分，记为 <span
class="math inline">\([x]\)</span>。函数 $ y = [x]$
称为<strong>取整函数</strong>。</p>
<p><strong>注</strong> 取整函数的基本不等式：<span
class="math inline">\(x-1\leqslant[x]\leqslant x\)</span>。</p>
<h3 id="复合函数">复合函数</h3>
<p><strong>定义</strong> 设函数 $ y = f(u) $ 的定义域为 $ D_f $，函数 $
u = g(x) $ 的定义域为 $ D_g $，值域为 $ R_g $，若 <span
class="math inline">\(D_f\cap R_g \neq\emptyset\)</span>，则称函数 $ y =
f[g(x)] $ 为函数 $ y = f(u) $ 与 $ u = g(x) $
的<strong>复合函数</strong>。它的定义域为 <span
class="math inline">\(\{x|x \in D_g, g(x) \in D_f\}\)</span>。</p>
<p><strong>注</strong> 不是任何两个函数都可以复合，如 <span
class="math inline">\(y=f(u)=\ln u, u=g(x)=\sin
x-1\)</span>，就不能复合，这是由于 <span class="math inline">\(D_f=(0,
+\infty), R_g=[-2,0], D_f\cap R_g=\emptyset\)</span>。</p>
<h3 id="反函数">反函数</h3>
<p><strong>定义</strong> 设函数 $ y = f(x) $ 的定义域为 $ D $，值域为 $
R_f $。若对任意 <span class="math inline">\(y\in
R_f\)</span>，有唯一确定的 <span class="math inline">\(x\in
D\)</span>，使得 $ y = f(x) $，则记为 $ x = f^{-1}(y) $，称其为函数 $ y
= f(x) $ 的<strong>反函数</strong>。</p>
<p><strong>注</strong></p>
<ul>
<li><p>有时也将 $ y = f(x) $ 的反函数 $ x = f^{-1}(y) $ 写成 $ y =
f^{-1}(x) $。</p></li>
<li><p>在同一直角坐标系中，$ y = f(x) $ 和 $ x = f^{-1}(y) $
的图形重合，$ y = f(x) $ 和 $ y = f^{-1}(x) $ 的图形关于直线 $ y = x $
对称。</p></li>
<li><p>$ f^{-1}[f(x)] = x $, $ f[f^{-1}(x)] = x $.</p></li>
</ul>
<h3 id="初等函数">初等函数</h3>
<p><strong>定义</strong> 幂函数, 指数函数, 对数函数,
三角函数及反三角函数统称为<strong>基本初等函数</strong>。</p>
<ul>
<li>幂函数 $ y = x^{} $ (<span
class="math inline">\(\mu\)</span>为实数)。</li>
<li>指数函数 $ y = a^x $ (<span class="math inline">\(a &gt; 0, a \neq
1\)</span>)。</li>
<li>对数函数 <span class="math inline">\(y=\log_a x\)</span> (<span
class="math inline">\(a &gt; 0, a \neq 1\)</span>)。</li>
<li>三角函数 <span class="math inline">\(y=\sin x\)</span>, <span
class="math inline">\(y=\cos x\)</span>, <span
class="math inline">\(y=\tan x\)</span>, <span
class="math inline">\(y=\cot x\)</span>, <span
class="math inline">\(y=\sec x\)</span>, <span
class="math inline">\(y=\csc x\)</span>。</li>
<li>反三角函数 <span class="math inline">\(y=\arcsin x\)</span>, <span
class="math inline">\(y=\arccos x\)</span>, <span
class="math inline">\(y=\arctan x\)</span>。</li>
</ul>
<p><strong>定义</strong>
由常数和基本初等函数经过有限次四则运算和有限次的函数复合步骤所构成并可用一个式子表示的函数,称为<strong>初等函数</strong>。</p>
<h3 id="函数的性质">函数的性质</h3>
<ol type="1">
<li><strong>单调性</strong></li>
</ol>
<p><strong>定义</strong> 设函数 $ y = f(x) $ 在某区间 I 上有定义,
如果对于区间 I 上的任意两点 $ x_1, x_2 $, 当 $ x_1 &lt; x_2 $ 时, 恒有 $
f(x_1) &lt; f(x_2) $ (或 $ f(x_1) &gt; f(x_2) $), 则称函数 $ y = f(x) $
在区间 I 上单调增加 (或单调减少)。</p>
<p>如果对于区间 I 上的任意两点 $ x_1, x_2 $, 当 $ x_1 &lt; x_2 $ 时,
恒有 $ f(x_1) f(x_2) $ (或 $ f(x_1) f(x_2) $), 则称函数 $ y = f(x) $
在区间 I 上单调不减 (或单调不增)。</p>
<p><strong>判定</strong></p>
<ul>
<li>利用定义;</li>
<li>利用导数。 设 $ f(x) $ 在区间 I 上可导,则
<ul>
<li><span class="math inline">\(f&#39;(x)&gt;0(&lt;0)\Rightarrow
f(x)\)</span> 单调增 (单调减);</li>
<li><span class="math inline">\(f&#39;(x)\geqslant 0(\leqslant
0)\Leftrightarrow f(x)\)</span> 单调不减 (单调不增)。</li>
</ul></li>
</ul>
<ol start="2" type="1">
<li><strong>奇偶性</strong></li>
</ol>
<p><strong>定义</strong> 设函数 <span
class="math inline">\(y=f(x)\)</span> 的定义域 <span
class="math inline">\(D\)</span> 关于原点对称 (即若 <span
class="math inline">\(x\in D\)</span>,  则有 <span
class="math inline">\(-x\in D\)</span>),如果对于任一 <span
class="math inline">\(x\in D\)</span>,恒有 <span
class="math display">\[f(-x) = f(x)\]</span> 则称 <span
class="math inline">\(f(x)\)</span> 为 <span
class="math inline">\(D\)</span> 上的偶函数; 如果恒有 <span
class="math display">\[f(-x)=-f(x)\]</span> 则称 <span
class="math inline">\(f(x)\)</span> 为 <span
class="math inline">\(D\)</span> 上的奇函数。</p>
<p><strong>注</strong></p>
<ul>
<li><span class="math inline">\(\sin x\)</span>, <span
class="math inline">\(\tan x\)</span>, <span
class="math inline">\(\arcsin x\)</span>, <span
class="math inline">\(\arctan x\)</span>, <span
class="math inline">\(\ln \frac{1-x}{1+x}\)</span>, <span
class="math inline">\(\ln (x+\sqrt{1+x^2})\)</span>, <span
class="math inline">\(\frac{e^x-1}{e^x+1}\)</span>, <span
class="math inline">\(f(x)-f(-x)\)</span> 都是奇函数; $ x^2, |x|, x,
f(x)+f(-x) $ 都是偶函数。</li>
<li>奇函数 $ y = f(x) $ 的图形关于原点对称, 且若 $ f(x) $ 在 $ x=0 $
处有定义, 则 $ f(0)=0 $; 偶函数的图形关于 <span
class="math inline">\(y\)</span> 轴对称。</li>
</ul>
<p><strong>判定</strong></p>
<ul>
<li>利用定义;</li>
<li>设 $ f(x) $ 可导,则
<ul>
<li>$ f(x) $ 是奇函数 $f'(x) $ 是偶函数;</li>
<li>$ f(x) $ 是偶函数 $f'(x) $ 是奇函数。</li>
</ul></li>
<li>连续的奇函数其原函数都是偶函数；连续的偶函数其原函数中有且仅有一个是奇函数。</li>
</ul>
<p><strong>注</strong> 设 $ f(x) $ 连续</p>
<ul>
<li>若 $ f(x) $ 是奇函数，则 $ _{0}^{x} f(t) t $ 是偶函数；</li>
<li>若 $ f(x) $ 是偶函数，则 $ _{0}^{x} f(t) t $ 是奇函数。</li>
</ul>
<ol start="3" type="1">
<li><strong>周期性</strong></li>
</ol>
<p><strong>定义</strong> 若存在实数 $ T &gt; 0 $，对于任意 $ x $，恒有 $
f(x + T) = f(x) $，则称 $ y = f(x) $
为<strong>周期函数</strong>。使得上述关系式成立的最小正数 $ T $ 称为 $
f(x) $ 的最小正周期，简称为函数 $ f(x) $ 的<strong>周期</strong>。</p>
<p><strong>注</strong></p>
<ul>
<li><span class="math inline">\(\sin x\)</span> 和 <span
class="math inline">\(\cos x\)</span> 以 $ 2$ 为周期，<span
class="math inline">\(\sin 2x\)</span> 和 <span
class="math inline">\(\left| \sin x \right|\)</span> 以 <span
class="math inline">\(\pi\)</span> 为周期。</li>
<li>若 $ f(x) $ 以 $ T $ 为周期，则 $ f(ax + b) $ 以 <span
class="math inline">\(\frac{T}{a} (a \neq 0)\)</span> 为周期。</li>
</ul>
<p><strong>判定</strong></p>
<ul>
<li>利用定义；</li>
<li>可导的周期函数其导函数为周期函数；</li>
<li>周期函数的原函数不一定是周期函数（如 <span
class="math inline">\(1+\cos x\)</span>）。</li>
</ul>
<p><strong>注</strong></p>
<ul>
<li>设 $ f(x) $ 连续且以 $ T $ 为周期，则 <span
class="math inline">\(F(x)=\int_{0}^{x} f(t)\mathrm{d}t\)</span> 是以
<span class="math inline">\(T\)</span> 为周期的周期函数 <span
class="math inline">\(\Leftrightarrow\int_{0}^{T}
f(x)\mathrm{d}x=0\)</span>。</li>
<li>周期函数的原函数是周期函数的充要条件是其在一个周期上的积分为零。</li>
</ul>
<ol start="4" type="1">
<li><strong>有界性</strong></li>
</ol>
<p><strong>定义</strong> 若 <span class="math inline">\(\exists M &gt;
0,  \forall x \in I, |f(x)| \leq M\)</span>, 则称 <span
class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\(I\)</span> 上有界。</p>
<p><strong>注</strong> <span class="math display">\[| \sin x | \leqslant
1, | \cos x | \leqslant 1, | \arcsin x | \leqslant \frac{\pi}{2}, |
\arctan x | &lt; \frac{\pi}{2}, | \arccos x | \leqslant
\pi.\]</span></p>
<p><strong>判定</strong></p>
<ul>
<li>利用定义；</li>
<li><span class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\([a,b]\)</span> 上连续 <span
class="math inline">\(\Rightarrow f(x)\)</span> 在 <span
class="math inline">\([a,b]\)</span> 上有界；</li>
<li><span class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\((a,b)\)</span> 上连续，且 $f(a^+) $ 和 <span
class="math inline">\(f(b^-)\)</span> 存在 <span
class="math inline">\(\Rightarrow f(x)\)</span> 在 <span
class="math inline">\((a,b)\)</span> 上有界；</li>
<li><span class="math inline">\(f&#39;(x)\)</span> 在区间 <span
class="math inline">\(I\)</span> (有限) 上有界 <span
class="math inline">\(\Rightarrow f(x)\)</span> 在 <span
class="math inline">\(I\)</span> 上有界。</li>
</ul>
<p><strong>注</strong> (3) 中的区间 <span
class="math inline">\((a,b)\)</span> 改为无穷区间 <span
class="math inline">\((-\infty,b), (a,+\infty),
(-\infty,+\infty)\)</span> 结论仍成立。</p>
<h2 id="极限">极限</h2>
<h3 id="极限的概念">极限的概念</h3>
<h4 id="数列极限">数列极限</h4>
<p><span class="math display">\[\lim\limits_{n \to \infty} x_n =
a\Leftrightarrow\forall \varepsilon &gt; 0, \exists N(\varepsilon) &gt;
0, \text{当 } n &gt; N \text{ 时，有 } |x_n - a| &lt;
\varepsilon.\]</span></p>
<p><strong>注</strong></p>
<ul>
<li><span class="math inline">\(\lim\limits_{n \to \infty} x_n =
a\)</span> 的几何意义: 对于 <span class="math inline">\(a\)</span>
点的任何 <span class="math inline">\(\varepsilon\)</span> 邻域即开区间
<span class="math inline">\((a - \varepsilon, a + \varepsilon)\)</span>,
一定存在 <span class="math inline">\(N\)</span>, 当 <span
class="math inline">\(n &gt; N\)</span> 即第 <span
class="math inline">\(N\)</span> 项以后的点 <span
class="math inline">\(x_n\)</span> 都落在开区间 <span
class="math inline">\((a - \varepsilon, a + \varepsilon)\)</span> 内,
而只有有限个(最多有 <span class="math inline">\(N\)</span>
个)在这区间之外。</li>
<li>数列 <span class="math inline">\(\{x_n\}\)</span> 的极限是否存在,
如果存在极限值等于多少, 与数列的前有限项无关。</li>
<li><span class="math inline">\(\lim\limits_{n \to \infty} x_n = a
\Leftrightarrow \lim\limits_{n \to \infty} x_{2k-1} = \lim\limits_{k \to
\infty} x_{2k} = a\)</span>.</li>
</ul>
<h4 id="函数极限">函数极限</h4>
<ol type="1">
<li><strong>自变量趋于无穷大时函数的极限</strong></li>
</ol>
<p><span class="math display">\[\lim\limits_{x \to +\infty} f(x) =
A\Leftrightarrow\forall \varepsilon &gt; 0, \exists X(\varepsilon) &gt;
0, \text{当 } x &gt; X \text{ 时，有 } |f(x) - A| &lt;
\varepsilon.\]</span> <span class="math display">\[\lim\limits_{x \to
-\infty} f(x) = A\Leftrightarrow\forall \varepsilon &gt; 0, \exists
X(\varepsilon) &gt; 0, \text{当 } x &lt; -X \text{ 时，有 } |f(x) - A|
&lt; \varepsilon.\]</span> <span class="math display">\[\lim\limits_{x
\to \infty} f(x) = A\Leftrightarrow\forall \varepsilon &gt; 0, \exists
X(\varepsilon) &gt; 0, \text{当 } |x| &gt; X \text{ 时，有 } |f(x) - A|
&lt; \varepsilon.\]</span></p>
<p><strong>注</strong> 在函数极限中 <span class="math inline">\(x \to
\infty\)</span> 是指 <span class="math inline">\(|x| \to
+\infty\)</span>, 而在数列极限中, <span class="math inline">\(n \to
\infty\)</span> 是指 <span class="math inline">\(n \to
+\infty\)</span>.</p>
<p><strong>定理</strong> <span class="math inline">\(\lim\limits_{x \to
\infty} f(x) = A \Leftrightarrow \lim\limits_{x \to +\infty} f(x) =
\lim\limits_{x \to -\infty} f(x) = A\)</span>.</p>
<ol start="2" type="1">
<li><strong>自变量趋于有限值时函数的极限</strong></li>
</ol>
<ul>
<li>极限 <span class="math inline">\(\lim\limits_{x \to
x_0}f(x)=A\)</span>：<span
class="math inline">\(\forall\varepsilon&gt;0\)</span>，<span
class="math inline">\(\exists\delta(\varepsilon)&gt;0\)</span>，当 <span
class="math inline">\(0&lt;|x-x_0|&lt;\delta\)</span> 时，有 <span
class="math inline">\(|f(x)-A|&lt;\varepsilon\)</span>。</li>
</ul>
<p><strong>注</strong> 函数 <span class="math inline">\(f(x)\)</span>
在点 <span class="math inline">\(x_0\)</span>
处的极限是否存在，如果存在极限值等于多少仅与 <span
class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\(x_0\)</span> 点的去心邻域 <span
class="math inline">\(\mathring{U}(x_0,\delta)\)</span>
内的函数值有关，而与 <span class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\(x_0\)</span>
是否有定义，如果有定义函数值等于多少无关。</p>
<ul>
<li><p>左极限：<span class="math inline">\(\lim\limits_{x\to
x_0^-}f(x)=f(x_0^-)\)</span>；</p></li>
<li><p>右极限：<span class="math inline">\(\lim\limits_{x\to
x_0^+}f(x)=f(x_0^+)\)</span>。</p></li>
</ul>
<p><strong>定理</strong> <span class="math inline">\(\lim\limits_{x\to
x_0}f(x)=A\iff\lim\limits_{x\to x_0^+}f(x)=\lim\limits_{x\to
x_0^-}f(x)=A\)</span>。</p>
<p><strong>注意</strong> 需要分左右极限求极限的问题主要有三种：</p>
<ul>
<li><p>分段函数在分界点处的极限，而在该分界点两侧函数表达式不同（这里也包括带有绝对值的函数，如
<span class="math inline">\(\lim\limits_{x\to
0}\frac{|x|}{x}\)</span>）；</p></li>
<li><p><span class="math inline">\(e^\infty\)</span> 型极限（如 <span
class="math inline">\(\lim\limits_{x\to
0}e^{\frac{1}{x}},\lim\limits_{x\to\infty}e^{x},\lim\limits_{x\to\infty}e^{-x}\)</span>）。</p></li>
</ul>
<p><span class="math inline">\(\lim\limits_{x\to
0^-}e^{\frac{1}{x}}=0,\lim\limits_{x\to
0^+}e^{\frac{1}{x}}=+\infty\)</span>，则 <span
class="math inline">\(\lim\limits_{x\to 0}e^{\frac{1}{x}}\)</span>
不存在；</p>
<p><span
class="math inline">\(\lim\limits_{x\to-\infty}e^x=0,\lim\limits_{x\to+\infty}e^x=+\infty\)</span>，则
<span class="math inline">\(\lim\limits_{x\to\infty}e^x\)</span>
不存在。</p>
<p><span
class="math inline">\(e^\infty\neq\infty,e^{+\infty}=+\infty,e^{-\infty}=0\)</span>。</p>
<ul>
<li><span class="math inline">\(\arctan\infty\)</span> 型极限（如 <span
class="math inline">\(\lim\limits_{x\to
0}\arctan\frac{1}{x},\lim\limits_{x\to\infty}\arctan x\)</span>）。</li>
</ul>
<p><span class="math inline">\(\lim\limits_{x\to
0^-}\arctan\frac{1}{x}=-\frac{\pi}{2},\lim\limits_{x\to
0^+}\arctan\frac{1}{x}=\frac{\pi}{2}\)</span>，则 <span
class="math inline">\(\lim\limits_{x\to 0}\arctan\frac{1}{x}\)</span>
不存在；</p>
<p><span class="math inline">\(\lim\limits_{x\to-\infty}\arctan
x=-\frac{\pi}{2},\lim\limits_{x\to+\infty}\arctan
x=\frac{\pi}{2}\)</span>，则 <span
class="math inline">\(\lim\limits_{x\to\infty}\arctan x\)</span>
不存在。</p>
<p><span
class="math inline">\(\arctan\infty\neq\frac{\pi}{2},\arctan(+\infty)=\frac{\pi}{2},\arctan(-\infty)=-\frac{\pi}{2}\)</span>。</p>
<h3 id="极限的性质">极限的性质</h3>
<ol type="1">
<li><p><strong>局部有界性</strong> 若极限 <span
class="math inline">\(\lim\limits_{x\to x_0}f(x)\)</span> 存在，则 <span
class="math inline">\(f(x)\)</span> 在点 <span
class="math inline">\(x_0\)</span> 某去心邻域内有界。</p></li>
<li><p><strong>保号性</strong> 设 <span
class="math inline">\(\lim\limits_{x\to x_0}f(x)=A\)</span>，则</p></li>
</ol>
<ul>
<li>若 <span class="math inline">\(A&gt;0\)</span>（或 <span
class="math inline">\(A&lt;0\)</span>）<span
class="math inline">\(\Rightarrow\exists\delta&gt;0\)</span>，当 <span
class="math inline">\(x\in\mathring{U}(x_0,\delta)\)</span> 时，<span
class="math inline">\(f(x)&gt;0\)</span>（或 <span
class="math inline">\(f(x)&lt;0\)</span>）。</li>
<li>若 <span class="math inline">\(\exists\delta&gt;0\)</span>，当 <span
class="math inline">\(x\in\mathring{U}(x_0,\delta)\)</span> 时，<span
class="math inline">\(f(x)\geqslant0\)</span>（或 <span
class="math inline">\(f(x)\leqslant0\)</span>）<span
class="math inline">\(\Rightarrow A\geqslant0\)</span>（或 <span
class="math inline">\(A\leqslant0\)</span>）。</li>
</ul>
<p><strong>注</strong> 由保号性不难得到<strong>保序性</strong>：设 <span
class="math inline">\(\lim\limits_{x\to x_0}f(x)=A,\lim\limits_{x\to
x_0}g(x)=B\)</span>，则</p>
<ul>
<li>若 <span
class="math inline">\(A&gt;B\Rightarrow\exists\delta&gt;0\)</span>，当
<span class="math inline">\(x\in\mathring{U}(x_0,\delta)\)</span>
时，<span class="math inline">\(f(x)&gt;g(x)\)</span>。</li>
<li>若 <span class="math inline">\(\exists\delta&gt;0\)</span>，当 <span
class="math inline">\(x\in\mathring{U}(x_0,\delta)\)</span> 时，<span
class="math inline">\(f(x)\geqslant g(x)\)</span><span
class="math inline">\(\Rightarrow A\geqslant B\)</span>。</li>
</ul>
<ol start="3" type="1">
<li><strong>极限值与无穷小之间的关系</strong> <span
class="math inline">\(\lim\limits_{x\to x_0}f(x)=A\iff
f(x)=A+a(x)\)</span>，其中 <span class="math inline">\(\lim\limits_{x\to
x_0}a(x)=0\)</span>。</li>
</ol>
<p><strong>注</strong> 数列极限有对应的以上三条性质。</p>
<h3 id="极限存在准则">极限存在准则</h3>
<ol type="1">
<li><p><strong>夹逼准则</strong> 若存在 <span
class="math inline">\(N\)</span>，当 <span
class="math inline">\(n&gt;N\)</span> 时，<span
class="math inline">\(x_n\leqslant y_n\leqslant z_n\)</span>，且 <span
class="math inline">\(\lim\limits_{n\to\infty}x_n=\lim\limits_{n\to\infty}z_n=a\)</span>，则
<span
class="math inline">\(\lim\limits_{n\to\infty}y_n=a\)</span>。</p></li>
<li><p><strong>单调有界准则</strong>
单调有界数列必有极限。即单调增、有上界的数列必有极限，单调减、有下界的数列必有极限。</p></li>
</ol>
<p><strong>注</strong> 函数极限有对应的以上两条准则。</p>
<h3 id="无穷小">无穷小</h3>
<ol type="1">
<li><p><strong>无穷小的概念</strong> 若 <span
class="math inline">\(f(x)\)</span> 当 <span class="math inline">\(x\to
x_0\)</span> (或 <span class="math inline">\(x\to\infty\)</span>)
时的极限为零，则称 <span class="math inline">\(f(x)\)</span> 为 <span
class="math inline">\(x\to x_0\)</span> (或 <span
class="math inline">\(x\to\infty\)</span>) 时的无穷小。</p></li>
<li><p><strong>无穷小的比较</strong> 设 <span
class="math inline">\(\lim\alpha(x)=0\)</span>，<span
class="math inline">\(\lim\beta(x)=0\)</span>。</p>
<ul>
<li><p>高阶：若 <span
class="math inline">\(\lim\frac{\beta(x)}{\alpha(x)}=0\)</span>，记为
<span class="math inline">\(\beta(x)=o(\alpha(x))\)</span>；</p></li>
<li><p>同阶：若 <span
class="math inline">\(\lim\frac{\beta(x)}{\alpha(x)}=C\neq0\)</span>；</p></li>
<li><p>等价：若 <span
class="math inline">\(\lim\frac{\beta(x)}{\alpha(x)}=1\)</span>，记为
<span class="math inline">\(\alpha(x)\sim\beta(x)\)</span>；</p></li>
<li><p>无穷小的阶：若 <span
class="math inline">\(\lim\frac{\beta(x)}{[\alpha(x)]^k}=C\neq0\)</span>，称
<span class="math inline">\(\beta(x)\)</span> 是 <span
class="math inline">\(\alpha(x)\)</span> 的 <span
class="math inline">\(k\)</span> 阶无穷小。</p></li>
</ul></li>
<li><p><strong>无穷小的性质</strong></p>
<ul>
<li><strong>有限</strong>个无穷小的和仍是无穷小；</li>
<li><strong>有限</strong>个无穷小的积仍是无穷小；</li>
<li>无穷小量与有界量的积仍是无穷小。</li>
</ul>
<p><strong>注</strong> 以上前两条中的“有限”二字不可少。</p></li>
</ol>
<h3 id="无穷大">无穷大</h3>
<ol type="1">
<li><p><strong>无穷大的概念</strong> 若 <span
class="math inline">\(\lim\limits_{x\to x_0}f(x)=\infty\)</span> (或
<span
class="math inline">\(\lim\limits_{x\to\infty}f(x)=\infty\)</span>)，则称
<span class="math inline">\(f(x)\)</span> 为 <span
class="math inline">\(x\to x_0\)</span> (或 <span
class="math inline">\(x\to\infty\)</span>) 时的无穷大。</p></li>
<li><p><strong>常用的一些无穷大的比较</strong></p>
<ul>
<li>当 <span class="math inline">\(x\to+\infty\)</span> 时，<span
class="math inline">\(\ln^n x\ll x^\beta\ll a^x\)</span> (其中 <span
class="math inline">\(a&gt;0,\beta&gt;0,a&gt;1\)</span>)。</li>
<li>当 <span class="math inline">\(n\to\infty\)</span> 时，<span
class="math inline">\(\ln^n n\ll n^\beta\ll a^n\ll n!\ll n^n\)</span>
(其中 <span
class="math inline">\(a&gt;0,\beta&gt;0,a&gt;1\)</span>)。</li>
</ul></li>
<li><p><strong>无穷大与无界变量的关系</strong> 无穷大<span
class="math inline">\(\Rightarrow\)</span>无界变量</p>
<ul>
<li>数列 <span class="math inline">\(\{x_n\}\)</span> 是无穷大量：<span
class="math inline">\(\forall M&gt;0，\exists N\)</span>，当 <span
class="math inline">\(n&gt;N\)</span> 时，恒有 <span
class="math inline">\(|x_n|&gt;M\)</span>。</li>
<li>数列 <span class="math inline">\(\{x_n\}\)</span> 是无界变量：<span
class="math inline">\(\forall M&gt;0，\exists N\)</span>，使 <span
class="math inline">\(|x_N|&gt;M\)</span>。</li>
<li>无穷大量一定是无界变量；但无界变量不一定是无穷大量。</li>
</ul>
<p>例如：数列 <span class="math inline">\(x_n=\begin{cases}
n,&amp;n为奇数\\
0,&amp;n为偶数
\end{cases}\)</span> 是无界变量，但不是无穷大。</p></li>
<li><p><strong>无穷大与无穷小的关系</strong>
在自变量的同一变化过程中，若 <span class="math inline">\(f(x)\)</span>
是无穷大，则 <span class="math inline">\(\frac{1}{f(x)}\)</span>
是无穷小；若 <span class="math inline">\(f(x)\)</span> 是无穷小，且
<span class="math inline">\(f(x)\neq0\)</span>，则 <span
class="math inline">\(\frac{1}{f(x)}\)</span> 是无穷大。</p></li>
</ol>
<h2 id="求极限">求极限</h2>
<h3 id="求极限的常用方法">求极限的常用方法</h3>
<ol type="1">
<li><strong>利用有理运算法则求极限</strong></li>
</ol>
<p>若 <span class="math inline">\(\lim f(x) = A, \lim g(x) = B\)</span>,
则 <span class="math display">\[\lim [f(x) \pm g(x)] = \lim f(x) \pm
\lim g(x) = A \pm B;\]</span> <span class="math display">\[\lim [f(x)
\cdot g(x)] = \lim f(x) \cdot \lim g(x) = A \cdot B;\]</span> <span
class="math display">\[\lim \frac{f(x)}{g(x)} = \frac{\lim f(x)}{\lim
g(x)} = \frac{A}{B} \quad (B \neq 0).\]</span></p>
<p><strong>推论</strong></p>
<ul>
<li>若 <span class="math inline">\(\lim f(x) = A \neq 0\)</span>, 则
<span class="math display">\[\lim f(x)g(x) = A \lim g(x);\]</span> <span
class="math display">\[\lim \frac{g(x)}{f(x)} = \frac{1}{A} \lim
g(x).\]</span></li>
</ul>
<p>（即：极限非零的因子的极限可先求出来）</p>
<ul>
<li><p>若 <span class="math inline">\(\lim \frac{f(x)}{g(x)}\)</span>
存在, 且 <span class="math inline">\(\lim g(x) = 0\)</span>, 则 <span
class="math inline">\(\lim f(x) = 0\)</span>;</p></li>
<li><p>若 <span class="math inline">\(\lim \frac{f(x)}{g(x)} = A \neq
0\)</span>, 且 <span class="math inline">\(\lim f(x) = 0\)</span>, 则
<span class="math inline">\(\lim g(x) = 0\)</span>.</p></li>
</ul>
<p><strong>注</strong> 若 <span class="math inline">\(\lim f(x)\)</span>
存在, <span class="math inline">\(\lim g(x)\)</span> 不存在, 则 <span
class="math inline">\(\lim [f(x) \pm g(x)]\)</span> 一定不存在; 若 <span
class="math inline">\(\lim f(x)\)</span> 和 <span
class="math inline">\(\lim g(x)\)</span> 都不存在, 则 <span
class="math inline">\(\lim [f(x) \pm g(x)]\)</span> 不一定存在.</p>
<ol start="2" type="1">
<li><strong>利用基本极限求极限</strong></li>
</ol>
<p><strong>常用的基本极限</strong> <span
class="math display">\[\lim\limits_{x \to 0} \frac{\sin x}{x} = 1; \quad
\lim\limits_{x \to 0} (1 + x)^{\frac{1}{x}} = e; \quad \lim\limits_{x
\to \infty} \left( 1 + \frac{1}{x} \right)^x = e;\]</span> <span
class="math display">\[\lim\limits_{x \to 0} \frac{a^x - 1}{x} = \ln a
\quad (a &gt; 0); \quad \lim\limits_{n \to \infty} \sqrt[n]{n} =
1;\]</span> <span class="math display">\[\lim\limits_{x \to \infty}
\frac{a_n x^n + a_{n-1} x^{n-1} + \cdots + a_1 x + a_0}{b_m x^m +
b_{m-1} x^{m-1} + \cdots + b_1 x + b_0} =
\begin{cases}
\frac{a_n}{b_m}, &amp; n = m,\\
0, &amp; n &lt; m,\\
\infty, &amp; n &gt; m;
\end{cases}\]</span> <span class="math display">\[\lim\limits_{n \to
\infty} x^n =
\begin{cases}
0, &amp; |x| &lt; 1,\\
\infty, &amp; |x| &gt; 1,\\
1, &amp; x = 1,\\
\text{不存在},&amp;x=-1;
\end{cases}
\quad \lim\limits_{n \to \infty} e^n =
\begin{cases}
0, &amp; x &lt; 0,\\
+\infty, &amp; x &gt; 0,\\
1, &amp; x = 0.
\end{cases}\]</span></p>
<ol start="3" type="1">
<li><strong>利用等价无穷小代换求极限</strong></li>
</ol>
<ol type="1">
<li><strong>常用等价无穷小</strong></li>
</ol>
<p>当 <span class="math inline">\(x\to0\)</span> 时，</p>
<ol type="i">
<li><p><span class="math inline">\(x\sim\sin x\sim\tan x\sim\arcsin
x\sim\arctan x\sim\ln(1+x)\sim e^x-1\)</span>, <span
class="math display">\[(1+x)^a-1\sim ax,\quad1-\cos^a
x\sim\frac{a}{2}x^2,\quad a^x-1\sim x\ln a.\]</span></p></li>
<li><p><span class="math inline">\(x-\sin
x\sim\frac{x^3}{6},\quad\arcsin x-x\sim\frac{x^3}{6},\quad
x-\ln(1+x)\sim\frac{x^2}{2}\)</span>, <span class="math display">\[\tan
x-x\sim\frac{x^3}{3},\quad x-\arctan
x\sim\frac{x^3}{3}.\]</span></p></li>
<li><p>设 <span class="math inline">\(f(x)\)</span> 和 <span
class="math inline">\(g(x)\)</span> 在 <span
class="math inline">\(x=0\)</span> 的某邻域内连续，且 <span
class="math inline">\(\lim\limits_{x\to
0}\frac{f(x)}{g(x)}=1\)</span>，则 <span class="math display">\[\int_0^x
f(t)\mathrm{d}t\sim\int_0^x g(t)\mathrm{d}t.\]</span></p></li>
</ol>
<p><strong>注</strong> 例如当 <span class="math inline">\(x\to0\)</span>
时，<span class="math inline">\(\ln(1+x^2)\sim x^2\)</span>，则 <span
class="math inline">\(\int_0^x\ln(1+t^2)dt\sim\int_0^x
t^2\mathrm{d}t=\frac{1}{3}x^3\)</span>.</p>
<ol start="2" type="1">
<li>等价无穷小代换的原则</li>
</ol>
<ul>
<li><p>乘、除关系可以换: 若<span
class="math inline">\(\alpha\sim\alpha_1,\beta\sim \beta_1\)</span>，则
<span
class="math inline">\(\lim\frac{\alpha}{\beta}=\lim\frac{\alpha_1}{\beta}=\lim\frac{\alpha}{\beta_1}=\lim\frac{\alpha_1}{\beta_1}\)</span>.</p></li>
<li><p>加、减关系在一定条件下可以换: ① 若 <span
class="math inline">\(\alpha\sim\alpha_1,\beta\sim\beta_1\)</span>，且
<span class="math inline">\(\lim \frac{\alpha_1}{\beta_1} = A \neq
1\)</span>，则 $ - _1 - _1 $. ② 若 $ _1, _1 $，且 <span
class="math inline">\(\lim \frac{\alpha_1}{\beta_1} = A \neq
-1\)</span>，则 $ + _1 + _1 $.</p></li>
</ul>
<p>高等数学辅导讲义</p>
<p>【例】求极限 <span class="math display">\[ \lim\limits_{x \to 0}
\frac{\tan x - \sin x}{x^3} \]</span>。</p>
<p>解（方法一）<span class="math display">\[ \lim\limits_{x \to 0}
\frac{\tan x - \sin x}{x^3} = \lim\limits_{x \to 0} \frac{\tan x (1 -
\cos x)}{x^3} \]</span> <span class="math display">\[ = \lim\limits_{x
\to 0} \frac{x \cdot \frac{1}{2}x^2}{x^3} \quad (\text{等价代换})
\]</span> <span class="math display">\[ = \frac{1}{2} \]</span></p>
<p>（方法二）<span class="math display">\[ \lim\limits_{x \to 0}
\frac{\tan x - \sin x}{x^3} = \lim\limits_{x \to 0} \frac{(\tan x - x) -
(\sin x - x)}{x^3} \]</span> <span class="math display">\[ =
\lim\limits_{x \to 0} \frac{(\frac{1}{3}x^3) - (- \frac{1}{6}x^3)}{x^3}
\quad (\text{等价代换}) \]</span> <span class="math display">\[ =
\frac{1}{2} \]</span></p>
<p>方法4 利用洛必达法则求极限</p>
<p>若（1）<span class="math display">\[ \lim\limits_{x \to x_0} f(x) =
\lim\limits_{x \to x_0} g(x) = 0 (\infty) \]</span>；</p>
<p>（2）<span class="math display">\[ f(x) \]</span> 和 <span
class="math display">\[ g(x) \]</span> 在 <span class="math display">\[
x_0 \]</span> 的某去心邻域内可导，且 <span class="math display">\[
g&#39;(x) \neq 0 \]</span>；</p>
<p>（3）<span class="math display">\[ \lim\limits_{x \to x_0}
\frac{f&#39;(x)}{g&#39;(x)} \]</span> 存在（或 <span
class="math inline">\(\infty\)</span>）。</p>
<p>则 <span class="math display">\[ \lim\limits_{x \to x_0}
\frac{f(x)}{g(x)} = \lim\limits_{x \to x_0} \frac{f&#39;(x)}{g&#39;(x)}
\]</span>。</p>
<p><strong>注</strong> 洛必达法则可用表7种类型不定式的极限，即 <span
class="math display">\[ \frac{0}{0}
\overset{\infty}{\underset{\infty}{\rightleftharpoons}} -\infty, 0 \cdot
\infty, 1^\infty, \infty^0, 0^0 \]</span>，其中前两种 <span
class="math display">\[ \frac{0}{0}
\overset{\infty}{\underset{\infty}{\rightleftharpoons}} \]</span>
直接用洛必达法则，后五种均可化为前两种。</p>
<p><span class="math display">\[\begin{array}{c}
0, \quad \infty \\
0, \quad \infty
\end{array}
\quad \begin{array}{c}
0 \cdot \infty \\
0^0
\end{array}\]</span></p>
<p>【例1】求极限 <span class="math display">\[ \lim\limits_{x \to 1}
\frac{\ln \cos(x-1)}{1 - \sin \frac{\pi}{2} x} \]</span>。</p>
<p>解 原式= <span class="math display">\[ \lim\limits_{x \to 1}
\frac{-\tan(x-1)}{-\frac{\pi}{2} \cos \frac{\pi}{2} x} \quad
(\text{洛必达法则}) \]</span> <span class="math display">\[ =
\frac{2}{\pi} \lim\limits_{x \to 1} \frac{x-1}{\cos \frac{\pi}{2} x}
\quad (\text{等价无穷小代换}) \]</span> <span class="math display">\[ =
\frac{2}{\pi} \lim\limits_{x \to 1} \frac{1}{\frac{\pi}{2} \sin
\frac{\pi}{2} x} = -\frac{4}{\pi^2} \]</span></p>
<p>高等数学辅导讲义</p>
<p>【例2】求极限 <span class="math inline">\(\lim\limits_{x \to \infty}
(x + \sqrt{1 + x^2})^{\frac{1}{x}}\)</span>。</p>
<p>解 <span class="math display">\[\lim\limits_{x \to \infty} (x +
\sqrt{1 + x^2})^{\frac{1}{x}} = \lim\limits_{x \to \infty} e^{\ln(x +
\sqrt{1 + x^2})}, \]</span> <span class="math display">\[\lim\limits_{x
\to \infty} \frac{\ln(x + \sqrt{1 + x^2})}{x} = \lim\limits_{x \to
\infty} \frac{\frac{1}{\sqrt{1 + x^2}}}{1} = 0, \quad
\text{(洛必达法则)}\]</span></p>
<p>则 <span class="math display">\[\lim\limits_{x \to \infty} (x +
\sqrt{1 + x^2})^{\frac{1}{x}} = e^0 = 1.\]</span></p>
<p>方法5 利用泰勒公式求极限
<strong>定理</strong>（带Peano余项的泰勒公式）设<span
class="math inline">\(f(x)\)</span>在<span class="math inline">\(x =
x_0\)</span>处n阶可导，则 <span class="math display">\[f(x) = f(x_0) +
f&#39;(x_0)(x - x_0) + \frac{f&#39;&#39;(x_0)}{2!}(x - x_0)^2 + \cdots +
\frac{f^{(n)}(x_0)}{n!}(x - x_0)^n + o((x - x_0)^n)\]</span></p>
<p>特别是当<span class="math inline">\(x_0 = 0\)</span>时， <span
class="math display">\[f(x) = f(0) + f&#39;(0)x +
\frac{f&#39;&#39;(0)}{2!}x^2 + \cdots + \frac{f^{(n)}(0)}{n!}x^n +
o(x^n)\]</span></p>
<p>几个常用的泰勒公式 (1) <span class="math inline">\(e^x = 1 + x +
\frac{x^2}{2!} + \cdots + \frac{x^n}{n!} + o(x^n)\)</span>。 (2) <span
class="math inline">\(\sin x = x - \frac{x^3}{3!} + \cdots +
(-1)^{n-1}\frac{x^{2n-1}}{(2n-1)!} + o(x^{2n-1})\)</span>。 (3) <span
class="math inline">\(\cos x = 1 - \frac{x^2}{2!} + \cdots +
(-1)^n\frac{x^{2n}}{(2n)!} + o(x^{2n})\)</span>。 (4) <span
class="math inline">\(\ln(1 + x) = x - \frac{x^2}{2} + \cdots +
(-1)^{n-1}\frac{x^n}{n} + o(x^n)\)</span>。 (5) <span
class="math inline">\((1 + x)^a = 1 + ax + \frac{a(a-1)}{2!}x^2 + \cdots
+ \frac{a(a-1)\cdots(a-n+1)}{n!}x^n + o(x^n)\)</span>。</p>
<p>【例】求极限 <span class="math inline">\(\lim\limits_{x \to 0}
\frac{\frac{x^2}{2} + 1 - \sqrt{1 + x^2}}{(\cos x - e^x) \sin^2
x}\)</span>。</p>
<p>解由于<span class="math inline">\(\sqrt{1 + x^2} = 1 + \frac{1}{2}x^2
+ \frac{1}{2}\left(\frac{1}{2}-1\right)x^4 + o(x^4)\)</span>， <span
class="math display">\[\cos x = 1 - \frac{1}{2}x^2 + o(x^2),\]</span>
<span class="math display">\[e^x = 1 + x^2 + o(x^2),\]</span></p>
<p>代入所求极限式得 <span class="math display">\[\lim\limits_{x \to 0}
\frac{\frac{1}{8}x^4 + o(x^4)}{\left[-\frac{3}{2}x^2 + o(x^2)\right]x^2}
= -\frac{1}{12}.\]</span></p>
<p>方法6 利用夹逼准则求极限</p>
<p>【例】求极限 <span class="math inline">\(\lim\limits_{n \to \infty}
\left(\frac{1}{n^2 + 1} + \frac{2}{n^2 + 2} + \cdots + \frac{n}{n^2 +
n}\right)\)</span>.</p>
<p>第一章 函数极限 连续</p>
<p><span class="math display">\[ \frac{1+2+\cdots+n}{n^2+n} \leq
\frac{1}{n^2+1}+\frac{2}{n^2+2}+\cdots+\frac{n}{n^2+n} \leq
\frac{1+2+\cdots+n}{n^2+1}, \]</span></p>
<p><span class="math display">\[ \lim\limits_{n \to \infty}
\frac{1+2+\cdots+n}{n^2+n} = \lim\limits_{n \to \infty}
\frac{\frac{1}{2} n(n+1)}{n^2+n} = \frac{1}{2}, \]</span></p>
<p><span class="math display">\[ \lim\limits_{n \to \infty}
\frac{1+2+\cdots+n}{n^2+1} = \lim\limits_{n \to \infty}
\frac{\frac{1}{2} n(n+1)}{n^2+1} = \frac{1}{2}, \]</span></p>
<p>则</p>
<p><span class="math display">\[ \lim\limits_{n \to \infty} \left(
\frac{1}{n^2+1} + \frac{2}{n^2+2} + \cdots + \frac{n}{n^2+n} \right) =
\frac{1}{2}. \]</span></p>
<p><strong>注</strong> 1+2++n=n(n+1).</p>
<p>方法7 利用定积分的定义求极限</p>
<p>【例】求极限 <span class="math inline">\(\lim\limits_{n \to \infty}
\left( \frac{1}{n+1} + \frac{1}{n+2} + \cdots + \frac{1}{n+n}
\right).\)</span></p>
<p>解 <span class="math inline">\(\lim\limits_{n \to \infty} \left(
\frac{1}{n+1} + \frac{1}{n+2} + \cdots + \frac{1}{n+n} \right) =
\lim\limits_{n \to \infty} \frac{1}{n} \left[ \frac{1}{1+\frac{1}{n}} +
\frac{1}{1+\frac{2}{n}} + \cdots + \frac{1}{1+\frac{n}{n}} \right] =
\int_0^1 \frac{1}{1+x} dx = \ln 2.\)</span></p>
<p><strong>注</strong> 由定积分定义可知，若将区间 <span
class="math inline">\([0,1]\)</span> 等分，第k个子区间上的 <span
class="math inline">\(\xi_k\)</span> 取该子区间右端点，此时 <span
class="math inline">\(\Delta x_k = \frac{1}{n}, \xi_k =
\frac{k}{n}\)</span>，则</p>
<p><span class="math display">\[ \int_0^1 f(x)dx = \lim\limits_{\lambda
\to 0} \sum\limits_{k=1}^n f(\xi_k) \Delta x_k = \lim\limits_{n \to
\infty} \sum\limits_{k=1}^n f\left( \frac{k}{n} \right), \frac{1}{n} =
\lim\limits_{n \to \infty} \frac{1}{n} \sum\limits_{k=1}^n f\left(
\frac{k}{n} \right) \]</span></p>
<p>上式右端是一种常见的积分和式的极限。所以，用定积分定义求极限的一般方法是：先提“可爱因子”<span
class="math inline">\(\frac{1}{n}\)</span>，然后再确定被积函数和积分区间。</p>
<p>方法8 利用单调有界准则求极限
一手高清无水印PDF及课程公众号：请读本时</p>
<p>【例】设 $x_1 &gt; 0, x_{n+1} = ( x_n + ), n = 1, 2, . $ 求极限 <span
class="math inline">\(\lim\limits_{n \to \infty} x_n.\)</span></p>
<p>解 由题设知 <span class="math inline">\(x_n &gt; 0, 且\)</span></p>
<p><span class="math display">\[ x_{n+1} = \frac{1}{2} \left( x_n +
\frac{1}{x_n} \right) = \frac{1}{2} \left[ (\sqrt{x_n})^2 + \left(
\frac{1}{\sqrt{x_n}} \right)^2 \right] \geq \frac{1}{2} \times 2
\sqrt{x_n} \times \frac{1}{\sqrt{x_n}} = 1, \]</span></p>
<p><span class="math display">\[ \frac{x_{n+1}}{x_n} = \frac{1}{2}
\left( 1 + \frac{1}{x_n^2} \right) \leq \frac{1}{2} \left( 1 +
\frac{1}{1} \right) = 1, \]</span></p>
<p>则数列 <span class="math inline">\(\{x_n\}\)</span>
单调减且有下界，故极限 <span class="math inline">\(\lim\limits_{n \to
\infty} x_n\)</span> 存在。设 <span class="math inline">\(\lim\limits_{n
\to \infty} x_n = a,\)</span> 由极限保号性知 <span
class="math inline">\(a \geq 1.\)</span></p>
<p>对等式 <span class="math inline">\(x_{n+1} = \frac{1}{2} \left( x_n +
\frac{1}{x_n} \right)\)</span> 两端取极限，得 <span
class="math inline">\(a = \frac{1}{2} \left( a + \frac{1}{a} \right),
X_a \geq 1,\)</span> 由此解得 <span class="math inline">\(a =
1.\)</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/30/NonlinearProgramming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/30/NonlinearProgramming/" class="post-title-link" itemprop="url">NonlinearProgramming</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-30 15:24:33" itemprop="dateCreated datePublished" datetime="2025-05-30T15:24:33+08:00">2025-05-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-06-14 18:23:55" itemprop="dateModified" datetime="2025-06-14T18:23:55+08:00">2025-06-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="非线性规划模型引出">非线性规划——模型引出</h1>
<h2
id="除了线性规划模型优化类问题往往还有一些更复杂的">除了线性规划模型，优化类问题往往还有一些更复杂的</h2>
<ul>
<li><p><strong>常见的收益率、传播率、经济增长率等规划问题</strong>，通常涉及
<span class="math inline">\(\frac{1}{x}\)</span>
形式的表达，属于典型的非线性问题。</p></li>
<li><p><strong>空间运动问题</strong>（如空间约束、避障、角度调整等），由于涉及曲线轨迹和角度变化，常用到三角函数、指数函数等非线性表达，因而也属于非线性问题的范畴。</p></li>
<li><p><strong>运输优化问题</strong>，例如已知多个坐标点，需确定最优运输路径。此类问题通常用到欧几里得距离公式，其数学形式包含变量的平方和开方，因此也属于非线性问题。</p></li>
<li><p><strong>示例</strong>：</p></li>
</ul>
<p><span class="math display">\[\begin{aligned}
&amp;\max~y=x_1^2+x_2^2-x_1x_2-2x_1-5x_2,\\
&amp;\text{s.t.}\begin{cases}(-x_1-1)^2+x_2\geqslant 0,\\
2x_1-3x_2+6\geqslant 0
\end{cases}
\end{aligned}\]</span></p>
<p>这就是一个非线性规划模型，与线性规划类似，它同样需要在确定决策变量的基础上，构建目标函数并列出相应的约束条件。</p>
<h2 id="非线性规划模型引出-1">非线性规划——模型引出</h2>
<h3 id="非线性规划简介">非线性规划简介</h3>
<p><strong>非线性规划</strong>是运筹学的重要分支，致力于求解目标函数或约束条件包含<strong>非线性函数</strong>的最优化问题。20世纪50年代初，库恩（H.W.
Kuhn）和塔克（A.W.
Tucker）提出的<strong>基本定理</strong>（K-T条件）为该领域奠定了理论基础。该方法在工业、交通运输、经济管理与军事等领域应用广泛，尤其在<strong>最优设计</strong>中提供关键的数学基础与计算方法，具有显著的实用价值。</p>
<h3 id="非线性规划模型特点">非线性规划模型特点</h3>
<ul>
<li><strong>非线性特征：</strong>
模型中至少包含一个<strong>非线性项</strong>，例如 <span
class="math inline">\(x^2\)</span>、<span
class="math inline">\(e^x\)</span>、<span
class="math inline">\(\frac{1}{x}\)</span>、<span
class="math inline">\(\sin x\)</span>、<span
class="math inline">\(\log_2 x\)</span> 等形式。</li>
<li><strong>与线性规划的区别：</strong>
<ul>
<li><strong>线性规划 (LP)：</strong>
存在通用的精确求解方法（如单纯形法），其最优解必然位于可行域的边界上。</li>
<li><strong>非线性规划 (NLP)：</strong>
最优解（若存在）可能出现在可行域的<strong>内部或边界任意点</strong>。目前尚无适用于所有
NLP 问题的通用解法，不同算法有其特定的适用范围。</li>
</ul></li>
<li><strong>数学建模中的应用：</strong> 对于数学建模实践，掌握利用
MATLAB
等工具的<strong>内置函数</strong>求解非线性规划问题（通常得到近似最优解）即可满足需求。</li>
</ul>
<h1 id="非线性规划模型原理">非线性规划——模型原理</h1>
<h2 id="非线性规划模型的matlab标准型">非线性规划模型的matlab标准型</h2>
<p><span class="math display">\[\begin{aligned}
&amp;\min ~f(x)\\
&amp;\text{s.t.}\begin{cases}
Ax \leqslant b,~Aeq\cdot x = beq&amp;(\text{线性})\\
C(x) \leqslant 0,~Ceq(x) = 0&amp;(\text{非线性})\\
lb \leqslant x \leqslant ub
\end{cases}
\end{aligned}\]</span></p>
<h3
id="非线性规划求解的matlab函数fmicon">非线性规划求解的Matlab函数:fmicon</h3>
<ul>
<li><p><strong>fmincon函数</strong>: <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x, fval] = fmincon ( fun, x0, A, b, Aeq, beq, lb, ub, nonlcon, option)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>fun：把目标函数定义为一个单独的函数文件（min）</li>
<li>x0：决策变量的初始值</li>
<li>A, b：线性约束的不等式变量系数矩阵和常数项矩阵（<span
class="math inline">\(&lt;\)</span> 或 <span
class="math inline">\(\leqslant\)</span>）</li>
<li>Aeq, beq：线性约束的等式变量系数矩阵和常数项矩阵</li>
<li>lb, ub：决策变量的最小取值和最大取值</li>
<li>nonlcon：非线性约束，包括不等式和等式</li>
<li>option：求解非线性规划使用的方法</li>
</ul></li>
<li><p>非线性规划中对于初始值<span
class="math inline">\(x0\)</span>的选取非常重要，因为非线性规划的算法求解出来的是一个局部最优解。如果要求全局最优解，有两个思路：</p>
<ul>
<li>给定不同的初始值，在里面找到一个最优解；</li>
<li>先用蒙特卡罗模拟，得到一个蒙特卡罗解，然后将这个解作为初始值求最优解</li>
</ul></li>
<li><p>options选项可以给定求解的算法，一共有五种：interior-point（内点法）、trust-region-reflective（信赖域反射法）、sqp（序列二次规划法）、sqp-legacy（约束非线性优化算法）、active-set（有效集法）。不同的算法有其各自的优缺点和适用情况，我们可以改变求解的算法来对比求解的结果。</p></li>
<li><p>fun表示目标函数，我们要编写一个独立的“m文件”储存目标函数
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">fun</span><span class="params">(x)</span></span></span><br><span class="line">   f=……</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>nonlcon</strong>
表示非线性部分的约束，也要编写一个独立的“m文件”储存非线性约束条件  
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="params">[c, ceq]</span> = <span class="title">nonlfun</span><span class="params">(x)</span></span></span><br><span class="line">  c=[非线性不等式约束<span class="number">1</span>;</span><br><span class="line">    ……</span><br><span class="line">    非线性不等式约束n]</span><br><span class="line">  ceq=[非线性等式约束<span class="number">1</span>;</span><br><span class="line">      ……</span><br><span class="line">      非线性等式约束m]</span><br></pre></td></tr></table></figure></p></li>
<li><p>决策变量下标要改为括号，比如 <span
class="math inline">\(x_1\)</span> 要改为 <span
class="math inline">\(x(1)\)</span>，matlab才能识别</p></li>
<li><p>若不存在某种约束，可以用“[]”替代，若后面全为“[]”且option使用默认，后面的“[]”可省略</p></li>
</ul>
<h2 id="非线性规划模型的python标准型">非线性规划模型的python标准型</h2>
<p><span class="math display">\[\begin{aligned}
&amp;\min ~f(x)\\
&amp;\text{s.t.}\begin{cases}
h_i(x) = 0,i=1,\cdots,m\\
g_j(x) \geqslant 0,j=1,\cdots,n\\
lb \leqslant x \leqslant ub
\end{cases}
\end{aligned}\]</span></p>
<h3
id="非线性规划求解的python函数minimize">非线性规划求解的python函数:minimize</h3>
<p><code>scipy.optimize.minimize</code> 是 SciPy
库中用于寻找函数最小值的核心函数。以下是所有参数的详细介绍和完整用法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> minimize</span><br><span class="line"></span><br><span class="line">result = minimize(fun, x0, args=(), method=<span class="literal">None</span>, jac=<span class="literal">None</span>, hess=<span class="literal">None</span>,hessp=<span class="literal">None</span>, bounds=<span class="literal">None</span>, constraints=(), tol=<span class="literal">None</span>, callback=<span class="literal">None</span>, options=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<h3
id="scipy.optimize.minimize-参数详解表"><code>scipy.optimize.minimize</code>
参数详解表</h3>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;"><strong>参数</strong></th>
<th style="text-align: center;"><strong>功能</strong></th>
<th style="text-align: center;"><strong>格式/要求</strong></th>
<th style="text-align: center;"><strong>默认值</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong><code>fun</code></strong></td>
<td style="text-align: center;">目标函数</td>
<td
style="text-align: center;">需要最小化的目标函数。这个函数需要接收一个或多个参数，并返回对应的目标函数值</td>
<td style="text-align: center;"><strong>必需</strong></td>
</tr>
<tr>
<td style="text-align: center;"><strong><code>x0</code></strong></td>
<td style="text-align: center;">初始猜测值</td>
<td style="text-align: center;">决策变量的初始值。它是一个一维的 numpy
数组</td>
<td style="text-align: center;"><strong>必需</strong></td>
</tr>
<tr>
<td style="text-align: center;"><strong><code>args</code></strong></td>
<td style="text-align: center;">额外参数</td>
<td style="text-align: center;">用于向目标函数 fun
和约束函数（如果有）传递额外的固定参数</td>
<td style="text-align: center;"><code>()</code></td>
</tr>
<tr>
<td
style="text-align: center;"><strong><code>method</code></strong></td>
<td style="text-align: center;">优化算法</td>
<td
style="text-align: center;">格式：字符串。指定求解优化问题所使用的算法方法。不同的问题类型（例如无约束优化、有约束优化等）可选用不同的合适算法</td>
<td style="text-align: center;">自动选择</td>
</tr>
<tr>
<td
style="text-align: center;"><strong><code>jac,hess,hessp</code></strong></td>
<td
style="text-align: center;">用于加速梯度优化的一些参数，大多数中小规模问题或简单函数不用管</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td
style="text-align: center;"><strong><code>bounds</code></strong></td>
<td style="text-align: center;">变量边界</td>
<td style="text-align: center;">格式：<br>•
<code>[(min0,max0), (min1,max1), ...]</code></td>
<td style="text-align: center;"><code>None</code></td>
</tr>
<tr>
<td
style="text-align: center;"><strong><code>constraints</code></strong></td>
<td style="text-align: center;">约束条件</td>
<td style="text-align: center;">格式：字典或字典列表：<br>•
等式：<code>&#123;'type':'eq', 'fun':F&#125;</code><br>•
不等式：<code>&#123;'type':'ineq', 'fun':F&#125;</code></td>
<td style="text-align: center;"><code>()</code></td>
</tr>
<tr>
<td style="text-align: center;"><strong><code>tol</code></strong></td>
<td style="text-align: center;">容差阈值</td>
<td style="text-align: center;">格式：浮点数。
<br>用于控制优化算法何时认为已经收敛并停止迭代。当算法在某次迭代后的改进程度小于这个容差值时，就会停止迭代。一般不用设置</td>
<td style="text-align: center;">算法默认值</td>
</tr>
<tr>
<td
style="text-align: center;"><strong><code>callback</code></strong></td>
<td style="text-align: center;">回调函数</td>
<td style="text-align: center;">可调用：<code>callback(xk)</code><br>•
<code>xk</code>：当前参数向量<br>每次迭代时的回调函数，通常用于调试或跟踪优化进度，一般不需要。</td>
<td style="text-align: center;"><code>None</code></td>
</tr>
<tr>
<td
style="text-align: center;"><strong><code>options</code></strong></td>
<td style="text-align: center;">算法选项</td>
<td
style="text-align: center;"><br>用于设置各种与算法相关的额外选项，比如以下字典：<br>•
<code>'maxiter'</code>：最大迭代次数<br>•
<code>'disp'</code>：显示信息<br>• <code>'gtol'</code>：梯度容差<br>•
<code>'eps'</code>：有限差分步长</td>
<td style="text-align: center;"><code>None</code></td>
</tr>
</tbody>
</table>
<h3 id="优化算法">优化算法</h3>
<table>
<thead>
<tr>
<th><strong>算法</strong></th>
<th><strong>描述</strong></th>
<th><strong>边界支持</strong></th>
<th><strong>约束支持</strong></th>
<th><strong>梯度需求</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>'Nelder-Mead'</code></td>
<td>单纯形法</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td><code>'Powell'</code></td>
<td>改进Powell法</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td><code>'CG'</code></td>
<td>共轭梯度法</td>
<td>❌</td>
<td>❌</td>
<td>可选</td>
</tr>
<tr>
<td><code>'BFGS'</code></td>
<td>拟牛顿法</td>
<td>❌</td>
<td>❌</td>
<td>可选</td>
</tr>
<tr>
<td><code>'Newton-CG'</code></td>
<td>牛顿共轭梯度法</td>
<td>❌</td>
<td>❌</td>
<td>必需</td>
</tr>
<tr>
<td><code>'L-BFGS-B'</code></td>
<td>有限内存BFGS</td>
<td>✔️</td>
<td>❌</td>
<td>可选</td>
</tr>
<tr>
<td><code>'TNC'</code></td>
<td>截断牛顿法</td>
<td>✔️</td>
<td>❌</td>
<td>可选</td>
</tr>
<tr>
<td><code>'COBYLA'</code></td>
<td>约束线性逼近</td>
<td>❌</td>
<td>✔️</td>
<td>❌</td>
</tr>
<tr>
<td><code>'SLSQP'</code></td>
<td>序列最小二乘</td>
<td>✔️</td>
<td>✔️</td>
<td>可选</td>
</tr>
<tr>
<td><code>'trust-constr'</code></td>
<td>信赖域约束法</td>
<td>✔️</td>
<td>✔️</td>
<td>可选</td>
</tr>
</tbody>
</table>
<h3 id="返回值">返回值</h3>
<p>返回 <code>OptimizeResult</code> 对象，包含以下属性：</p>
<table>
<thead>
<tr>
<th style="text-align: center;">属性</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>x</code></td>
<td style="text-align: center;">最优解数组</td>
</tr>
<tr>
<td style="text-align: center;"><code>success</code></td>
<td style="text-align: center;">是否成功收敛 (布尔值)</td>
</tr>
<tr>
<td style="text-align: center;"><code>status</code></td>
<td style="text-align: center;">终止状态代码</td>
</tr>
<tr>
<td style="text-align: center;"><code>message</code></td>
<td style="text-align: center;">终止状态描述</td>
</tr>
<tr>
<td style="text-align: center;"><code>fun</code></td>
<td style="text-align: center;">最优解处的函数值</td>
</tr>
<tr>
<td style="text-align: center;"><code>jac</code></td>
<td style="text-align: center;">最优解处的梯度</td>
</tr>
<tr>
<td style="text-align: center;"><code>hess</code></td>
<td style="text-align: center;">最优解处的Hessian矩阵</td>
</tr>
<tr>
<td style="text-align: center;"><code>nfev</code></td>
<td style="text-align: center;">函数调用次数</td>
</tr>
<tr>
<td style="text-align: center;"><code>njev</code></td>
<td style="text-align: center;">梯度调用次数</td>
</tr>
<tr>
<td style="text-align: center;"><code>nhev</code></td>
<td style="text-align: center;">Hessian调用次数</td>
</tr>
<tr>
<td style="text-align: center;"><code>nit</code></td>
<td style="text-align: center;">迭代次数</td>
</tr>
</tbody>
</table>
<h1 id="非线性规划典型例题">非线性规划——典型例题</h1>
<h2 id="选址问题">选址问题</h2>
<ul>
<li>临时料场：<span
class="math inline">\(A(5,1)，B(2,7)\)</span>；日储量各20吨。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center;">工地位置坐标及日需求量</th>
<th style="text-align: center;">I    </th>
<th style="text-align: center;">II  </th>
<th style="text-align: center;">III  </th>
<th style="text-align: center;">IV  </th>
<th style="text-align: center;">V    </th>
<th style="text-align: center;">VI  </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">横坐标                </td>
<td style="text-align: center;">1.25</td>
<td style="text-align: center;">8.75</td>
<td style="text-align: center;">0.5  </td>
<td style="text-align: center;">5.75</td>
<td style="text-align: center;">3    </td>
<td style="text-align: center;">7.25</td>
</tr>
<tr>
<td style="text-align: center;">纵坐标                </td>
<td style="text-align: center;">1.25</td>
<td style="text-align: center;">0.75</td>
<td style="text-align: center;">4.75</td>
<td style="text-align: center;">5    </td>
<td style="text-align: center;">6.5  </td>
<td style="text-align: center;">7.75</td>
</tr>
<tr>
<td style="text-align: center;">日需求量              </td>
<td style="text-align: center;">3    </td>
<td style="text-align: center;">5    </td>
<td style="text-align: center;">4    </td>
<td style="text-align: center;">7    </td>
<td style="text-align: center;">6    </td>
<td style="text-align: center;">11  </td>
</tr>
</tbody>
</table>
<p>（1）试制定每天的供应计划，即从两料场分别向各工地运送多少吨水泥，使总的吨千米数最小？</p>
<p>（2）为了进一步减少吨千米数，打算舍弃两个临时料场，改建两个新的，日储量各为20吨，问应建在何处，节省的吨千米数为多大？</p>
<h2 id="建立模型">建立模型</h2>
<h3 id="确定决策变量"><strong>确定决策变量</strong>  </h3>
<p>  设第<span class="math inline">\(i\)</span>个工地的坐标 <span
class="math inline">\((a_i,b_i)\)</span>，水泥日用量 <span
class="math inline">\(d_i\)</span>，<span class="math inline">\(i = 1,
2, ..., 6\)</span>；料场位置 <span
class="math inline">\((x_j,y_j)\)</span>，日储量 <span
class="math inline">\(e_j\)</span>，<span class="math inline">\(j = 1,
2\)</span>；从料场向工地的运送量为 <span
class="math inline">\(x_{ij}\)</span> （从第 <span
class="math inline">\(j\)</span> 个料场运往第 <span
class="math inline">\(i\)</span> 个工地）</p>
<h3 id="确定约束条件"><strong>确定约束条件</strong>  </h3>
<p>  料场水泥运输总量不超过其日储量：<span
class="math inline">\(\sum\limits_{i=1}^6 x_{ij} \leqslant e_j, j = 1,
2\)</span>  </p>
<p>  两个料场向某工地运输量之和等于该工地水泥日用量：<span
class="math inline">\(\sum\limits_{j=1}^2 x_{ij} = d_i, i = 1, 2, ...,
6\)</span>  </p>
<h3 id="确定目标函数"><strong>确定目标函数</strong>  </h3>
<p>  求总吨千米数最小，即运送量乘运送距离求和最小 <span
class="math inline">\(\min f = \sum\limits_{j=1}^2\sum\limits_{i=1}^6
x_{ij}\sqrt{(x_j-a_i)^2+(y_j-b_i)^2}\)</span>  </p>
<h3 id="建立模型-1"><strong>建立模型</strong>  </h3>
<p><span class="math display">\[\begin{aligned}
   &amp;\min~f=\sum_{j=1}^2 \sum_{i=1}^6 x_{ij} \sqrt{(x_j - a_i)^2 +
(y_j - b_i)^2}\\
   &amp;\text{s.t.} \begin{cases}
    \sum\limits_{i=1}^6 x_{ij} \leqslant e_j, j = 1, 2
~~~(x_{11}+x_{21}+\cdots+x_{61}\leqslant
e_1,x_{12}+x_{22}+\cdots+x_{62}\leqslant e_2)\\
    \sum\limits_{j=1}^2 x_{ij} = d_i, i = 1, 2, ...,
6~~~(x_{11}+x_{12}=d_{1},x_{21}+x_{22}=d_2,\cdots,x_{61}+x_{62}=d_{6})\\
    x_{ij} \geqslant 0, i = 1, 2, ..., 6; j = 1, 2
    \end{cases}
\end{aligned}\]</span></p>
<ul>
<li>对于第一问：因料场位置已知，故决策变量仅为 $ x_{ij}
$，为线性规划模型  </li>
<li>对于第二问：新料场位置未知，所以 $ x_j $ 和 $ y_j $
均为变量，故为非线性规划模型  </li>
<li>共有8个约束，注意，在 Matlab
里这些双角标的变量要改为单角标的变量，如 $x_{11}x_1, x_{21} x_2, ,
x_{62} x_{12} $</li>
</ul>
<h1 id="示例代码求解">示例代码求解</h1>
<p><span class="math display">\[\begin{aligned}
&amp;\max~y = x_1^2 + x_2^2 - x_1x_2 - 2x_1 - 5x_2, \\
&amp;\text{s.t.}
\begin{cases}
-(x_1 - 1)^2 + x_2 \geqslant 0, \\
2x_1 - 3x_2 + 6 \geqslant 0
\end{cases}
\end{aligned}\]</span></p>
<h2 id="matlab代码求解">matlab代码求解</h2>
<p>fun1.m的文件内容如下： <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">fun1</span><span class="params">(x)</span></span></span><br><span class="line">    <span class="comment">% 注意：这里的f实际上就是目标函数，函数的返回值也是f</span></span><br><span class="line">    <span class="comment">% 输入值x实际上就是决策变量，由x1和x2组成的向量</span></span><br><span class="line">    <span class="comment">% fun1是函数名称，到时候会被fmincon函数调用, 可以任意取名</span></span><br><span class="line">    <span class="comment">% 保存的m文件和函数名称得一致，也要为fun1.m</span></span><br><span class="line">    <span class="comment">% max f(x) = x1^2 +x2^2 -x1*x2 -2x1 -5x2</span></span><br><span class="line">    f = -x(<span class="number">1</span>)^<span class="number">2</span>-x(<span class="number">2</span>)^<span class="number">2</span> +x(<span class="number">1</span>)*x(<span class="number">2</span>)+<span class="number">2</span>*x(<span class="number">1</span>)+<span class="number">5</span>*x(<span class="number">2</span>) ; </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure> nonfun1.m的文件内容如下：
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[c,ceq]</span> = <span class="title">nonlfun1</span><span class="params">(x)</span></span></span><br><span class="line">    <span class="comment">% 注意：这里的c实际上就是非线性不等式约束，ceq实际上就是非线性等式约束</span></span><br><span class="line">    <span class="comment">% 输入值x实际上就是决策变量，由x1和x2组成的一个向量</span></span><br><span class="line">    <span class="comment">% 返回值有两个，一个是非线性不等式约束c，一个是非线性等式约束ceq</span></span><br><span class="line">    <span class="comment">% nonlfun1是函数名称，到时候会被fmincon函数调用, 可以任意取名，但不能和目标函数fun1重名</span></span><br><span class="line">    <span class="comment">% 保存的m文件和函数名称得一致，也要为nonlfun1.m</span></span><br><span class="line">    <span class="comment">% -(x1-1)^2 +x2 &gt;= 0</span></span><br><span class="line">   c = [(x(<span class="number">1</span>)<span class="number">-1</span>)^<span class="number">2</span>-x(<span class="number">2</span>)];   <span class="comment">% 千万別写成了: (x1-1)^2 -x2</span></span><br><span class="line">   ceq = [];  <span class="comment">% 不存在非线性等式约束，所以用[]表示</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<h3 id="使用默认算法">使用默认算法</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 非线性规划的函数</span></span><br><span class="line"><span class="comment">% [x,fval] = fmincon(fun,x0,A,b,Aeq,beq,lb,ub,nonlfun,option)</span></span><br><span class="line"><span class="comment">% x0表示给定的初始值（用行向量或者列向量表示），必须得写</span></span><br><span class="line"><span class="comment">% A b表示线性不等式约束</span></span><br><span class="line"><span class="comment">% Aeq beq 表示线性等式约束</span></span><br><span class="line"><span class="comment">% lb ub 表示上下界约束</span></span><br><span class="line"><span class="comment">% fun表示目标函数</span></span><br><span class="line"><span class="comment">% nonlfun表示非线性约束的函数</span></span><br><span class="line"><span class="comment">% option 表示求解非线性规划使用的方法</span></span><br><span class="line">clc;clear all;close all</span><br><span class="line">format long g   <span class="comment">%可以将Matlab的计算结果显示为一般的长数字格式（默认会保留四位小数，或使用科学计数法）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% max f(x) = x1^2 +x2^2 -x1*x2 -2x1 -5x2</span></span><br><span class="line"><span class="comment">% s.t. -(x1-1)^2 +x2 &gt;= 0 ;  2x1-3x2+6 &gt;= 0</span></span><br><span class="line">x0 = [<span class="number">0</span> <span class="number">0</span>];  <span class="comment">%任意给定一个初始值 </span></span><br><span class="line">A = [<span class="number">-2</span> <span class="number">3</span>]; b = <span class="number">6</span>;</span><br><span class="line">[x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1)  <span class="comment">% 注意 fun1.m文件和nonlfun1.m文件都必须在当前文件夹目录下</span></span><br><span class="line">fval = -fval</span><br></pre></td></tr></table></figure>
<h3 id="使用interior-point算法">使用interior point算法</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">clc;clear all;close all</span><br><span class="line">format long g</span><br><span class="line">x0 = [<span class="number">0</span> <span class="number">0</span>];  <span class="comment">%任意给定一个初始值 </span></span><br><span class="line">A = [<span class="number">-2</span> <span class="number">3</span>]; b = <span class="number">6</span>;</span><br><span class="line">option = optimoptions(<span class="string">&#x27;fmincon&#x27;</span>,<span class="string">&#x27;Algorithm&#x27;</span>,<span class="string">&#x27;interior-point&#x27;</span>)  </span><br><span class="line">[x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1,option)  </span><br><span class="line">fval = -fval  </span><br></pre></td></tr></table></figure>
<h3 id="使用sqp算法序列二次规划法">使用SQP算法（序列二次规划法）</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">clc;clear all;close all</span><br><span class="line">format long g</span><br><span class="line">x0 = [<span class="number">0</span> <span class="number">0</span>];  <span class="comment">%任意给定一个初始值 </span></span><br><span class="line">A = [<span class="number">-2</span> <span class="number">3</span>]; b = <span class="number">6</span>;  </span><br><span class="line">option = optimoptions(<span class="string">&#x27;fmincon&#x27;</span>,<span class="string">&#x27;Algorithm&#x27;</span>,<span class="string">&#x27;sqp&#x27;</span>)  </span><br><span class="line">[x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1,option)  </span><br><span class="line">fval = -fval <span class="comment">%得到-4.358，远远小于内点法得到的-1，猜想是初始值的影响  </span></span><br></pre></td></tr></table></figure>
<h3 id="尝试改变初始值">尝试改变初始值</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">clc;clear all;close all</span><br><span class="line">format long g</span><br><span class="line">x0 = [<span class="number">1</span> <span class="number">1</span>];  <span class="comment">%任意给定一个初始值 </span></span><br><span class="line">A = [<span class="number">-2</span> <span class="number">3</span>]; b = <span class="number">6</span>;  </span><br><span class="line">option = optimoptions(<span class="string">&#x27;fmincon&#x27;</span>,<span class="string">&#x27;Algorithm&#x27;</span>,<span class="string">&#x27;sqp&#x27;</span>)  </span><br><span class="line">[x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1,option)  </span><br><span class="line">fval = -fval <span class="comment">%% 最小值为-1，和内点法相同（这说明内点法的适应性比较好）  </span></span><br></pre></td></tr></table></figure>
<h3
id="使用蒙特卡罗的方法来求初始值推荐">使用蒙特卡罗的方法来求初始值（推荐）</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">clc;clear all;close all</span><br><span class="line">n=<span class="number">10000000</span>; <span class="comment">%生成的随机数组数</span></span><br><span class="line">x1=unifrnd(<span class="number">-100</span>,<span class="number">100</span>,n,<span class="number">1</span>); <span class="comment">%生成在[-100,100]之间均匀分布的随机数组</span></span><br><span class="line">x2=unifrnd(<span class="number">-100</span>,<span class="number">100</span>,n,<span class="number">1</span>);</span><br><span class="line">fmin=+<span class="built_in">inf</span>; <span class="comment">%初始化函数的最小值为正无穷</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    x = [x1(<span class="built_in">i</span>), x2(<span class="built_in">i</span>)]; </span><br><span class="line">    <span class="keyword">if</span> ((x(<span class="number">1</span>)<span class="number">-1</span>)^<span class="number">2</span>-x(<span class="number">2</span>)&lt;=<span class="number">0</span>)  &amp; (<span class="number">-2</span>*x(<span class="number">1</span>)+<span class="number">3</span>*x(<span class="number">2</span>)<span class="number">-6</span> &lt;= <span class="number">0</span>) <span class="comment">%判断是否满足条件</span></span><br><span class="line">        result = -x(<span class="number">1</span>)^<span class="number">2</span>-x(<span class="number">2</span>)^<span class="number">2</span> +x(<span class="number">1</span>)*x(<span class="number">2</span>)+<span class="number">2</span>*x(<span class="number">1</span>)+<span class="number">5</span>*x(<span class="number">2</span>); </span><br><span class="line">        <span class="keyword">if</span> result &lt; fmin </span><br><span class="line">            fmin = result; </span><br><span class="line">            x0 = x; </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;蒙特卡罗选取的初始值为: &#x27;</span>); <span class="built_in">disp</span>(x0)</span><br><span class="line">A = [<span class="number">-2</span> <span class="number">3</span>]; b = <span class="number">6</span>;</span><br><span class="line">[x, fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@non1fun1)</span><br><span class="line">fval = -fval</span><br></pre></td></tr></table></figure>
<h2 id="python代码求解">python代码求解</h2>
<h3 id="使用默认算法-1">使用默认算法</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> minimize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标函数，接受一个长度为2的一维数组x（代表两个变量x1和x2），计算并返回目标函数值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun1</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">0</span>] ** <span class="number">2</span> + x[<span class="number">1</span>] ** <span class="number">2</span> - x[<span class="number">0</span>] * x[<span class="number">1</span>] - <span class="number">2</span> * x[<span class="number">0</span>] - <span class="number">5</span> * x[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个非线性约束条件函数，接受变量x，返回对应的某条件的值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nonlcon1</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> -(x[<span class="number">0</span>] - <span class="number">1</span>) ** <span class="number">2</span> + x[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个非线性约束条件函数，接受变量x，返回对应的某条件的值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nonlcon2</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * x[<span class="number">0</span>] - <span class="number">3</span> * x[<span class="number">1</span>] + <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始值设定，设置为一个二维的numpy数组，初始值为[0, 0]</span></span><br><span class="line">x0 = np.array([<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用默认解法（内点法类似的算法，在scipy中会根据情况选择合适的）求解</span></span><br><span class="line">res = minimize(fun1, x0,</span><br><span class="line">               constraints=(&#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;ineq&#x27;</span>, <span class="string">&#x27;fun&#x27;</span>: nonlcon1&#125;,</span><br><span class="line">                            &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;ineq&#x27;</span>, <span class="string">&#x27;fun&#x27;</span>: nonlcon2&#125;),</span><br><span class="line">               bounds=<span class="literal">None</span>, tol=<span class="literal">None</span>, options=<span class="literal">None</span>, args=())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">或res = minimize(fun1, x0, args=(), </span></span><br><span class="line"><span class="string">               constraints=(&#123;&#x27;type&#x27;: &#x27;ineq&#x27;, &#x27;fun&#x27;: nonlcon1&#125;,</span></span><br><span class="line"><span class="string">                            &#123;&#x27;type&#x27;: &#x27;ineq&#x27;, &#x27;fun&#x27;: nonlcon2&#125;),</span></span><br><span class="line"><span class="string">               bounds=None, tol=None, options=None)</span></span><br><span class="line"><span class="string">或res = minimize(fun1, x0,</span></span><br><span class="line"><span class="string">               constraints=(&#123;&#x27;type&#x27;: &#x27;ineq&#x27;, &#x27;fun&#x27;: nonlcon1&#125;,</span></span><br><span class="line"><span class="string">                            &#123;&#x27;type&#x27;: &#x27;ineq&#x27;, &#x27;fun&#x27;: nonlcon2&#125;))</span></span><br><span class="line"><span class="string">或con=(&#123;&#x27;type&#x27;: &#x27;ineq&#x27;, &#x27;fun&#x27;: nonlcon1&#125;,</span></span><br><span class="line"><span class="string">       &#123;&#x27;type&#x27;: &#x27;ineq&#x27;, &#x27;fun&#x27;: nonlcon2&#125;)</span></span><br><span class="line"><span class="string">res = minimize(fun1, x0, constraints=con)</span></span><br><span class="line"><span class="string">或con=(&#123;&#x27;type&#x27;: &#x27;ineq&#x27;, &#x27;fun&#x27;: nonlcon1&#125;,</span></span><br><span class="line"><span class="string">       &#123;&#x27;type&#x27;: &#x27;ineq&#x27;, &#x27;fun&#x27;: nonlcon2&#125;)</span></span><br><span class="line"><span class="string">res = minimize(fun=fun1, x0=x0, constraints=con)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;默认算法（类似内点法等情况）求解结果：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最优解：&quot;</span>, res.x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最优值：&quot;</span>, res.fun)</span><br></pre></td></tr></table></figure>
<h3
id="使用slsqp算法序列二次规划法求解"> 使用SLSQP算法（序列二次规划法）求解</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> minimize</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun1</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">0</span>] ** <span class="number">2</span> + x[<span class="number">1</span>] ** <span class="number">2</span> - x[<span class="number">0</span>] * x[<span class="number">1</span>] - <span class="number">2</span> * x[<span class="number">0</span>] - <span class="number">5</span> * x[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nonlcon1</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> -(x[<span class="number">0</span>] - <span class="number">1</span>) ** <span class="number">2</span> + x[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nonlcon2</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * x[<span class="number">0</span>] - <span class="number">3</span> * x[<span class="number">1</span>] + <span class="number">6</span></span><br><span class="line"></span><br><span class="line">x0 = np.array([<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">res_sqp = minimize(fun1, x0=x0, method=<span class="string">&#x27;SLSQP&#x27;</span>,</span><br><span class="line">                   constraints=(&#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;ineq&#x27;</span>, <span class="string">&#x27;fun&#x27;</span>: nonlcon1&#125;,</span><br><span class="line">                                &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;ineq&#x27;</span>, <span class="string">&#x27;fun&#x27;</span>: nonlcon2&#125;),</span><br><span class="line">                   bounds=<span class="literal">None</span>, tol=<span class="literal">None</span>, options=<span class="literal">None</span>, args=())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;SQP算法（序列二次规划法）求解结果：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最优解：&quot;</span>, res_sqp.x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最优值：&quot;</span>, res_sqp.fun)</span><br></pre></td></tr></table></figure>
<h3
id="使用蒙特卡罗的方法来找初始值推荐">使用蒙特卡罗的方法来找初始值(推荐)</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> minimize</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun1</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">0</span>] ** <span class="number">2</span> + x[<span class="number">1</span>] ** <span class="number">2</span> - x[<span class="number">0</span>] * x[<span class="number">1</span>] - <span class="number">2</span> * x[<span class="number">0</span>] - <span class="number">5</span> * x[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nonlcon1</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> -(x[<span class="number">0</span>] - <span class="number">1</span>) ** <span class="number">2</span> + x[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nonlcon2</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * x[<span class="number">0</span>] - <span class="number">3</span> * x[<span class="number">1</span>] + <span class="number">6</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">10000000</span></span><br><span class="line"><span class="comment"># np.random.uniform 是 NumPy 库中用于生成在指定区间内均匀分布的随机数（或随机数组）的函数。</span></span><br><span class="line"><span class="comment"># 用法同 np.random.randint，不过这里生成的是随机数，不是整数</span></span><br><span class="line">x1 = np.random.uniform(-<span class="number">100</span>, <span class="number">100</span>, size=n)</span><br><span class="line">x2 = np.random.uniform(-<span class="number">100</span>, <span class="number">100</span>, size=n)</span><br><span class="line">fmin = <span class="number">100000000</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    x = np.array([x1[i], x2[i]])</span><br><span class="line">    <span class="comment"># 后续的约束条件判断和结果处理逻辑保持不变</span></span><br><span class="line">    <span class="keyword">if</span> nonlcon1(x) &gt;= <span class="number">0</span> <span class="keyword">and</span> nonlcon2(x) &gt;= <span class="number">0</span>:</span><br><span class="line">        result = fun1(x)</span><br><span class="line">        <span class="keyword">if</span> result &lt; fmin:</span><br><span class="line">            fmin = result</span><br><span class="line">            x0 = x</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;蒙特卡罗选取的初始值为：&quot;</span>, x0)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用找到的初始值再次进行优化求解</span></span><br><span class="line">res_final = minimize(fun1, x0,</span><br><span class="line">                    constraints=(&#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;ineq&#x27;</span>, <span class="string">&#x27;fun&#x27;</span>: nonlcon1&#125;,</span><br><span class="line">                                 &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;ineq&#x27;</span>, <span class="string">&#x27;fun&#x27;</span>: nonlcon2&#125;),</span><br><span class="line">                    bounds=<span class="literal">None</span>, tol=<span class="literal">None</span>, options=<span class="literal">None</span>, args=())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;基于蒙特卡罗初始值的最终求解结果：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最优解：&quot;</span>, res_final.x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最优值：&quot;</span>, res_final.fun)</span><br></pre></td></tr></table></figure>
<h1 id="选址问题代码求解">选址问题代码求解</h1>
<h2 id="matlab代码求解-1">matlab代码求解</h2>
<h3 id="第一问代码线性规划">第一问代码（线性规划）</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">clear;clc;</span><br><span class="line"><span class="comment">% 6个工地坐标</span></span><br><span class="line">a=[<span class="number">1.25</span> <span class="number">8.75</span> <span class="number">0.5</span> <span class="number">5.75</span> <span class="number">3</span> <span class="number">7.25</span>];</span><br><span class="line">b=[<span class="number">1.25</span> <span class="number">0.75</span> <span class="number">4.75</span> <span class="number">5</span> <span class="number">6.5</span> <span class="number">7.75</span>];</span><br><span class="line"><span class="comment">% 临时料场位置</span></span><br><span class="line">x=[<span class="number">5</span> <span class="number">2</span>];</span><br><span class="line">y=[<span class="number">1</span> <span class="number">7</span>];</span><br><span class="line"><span class="comment">% 6个工地水泥日用量</span></span><br><span class="line">d=[<span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">7</span> <span class="number">6</span> <span class="number">11</span>];</span><br><span class="line"><span class="comment">% 计算目标函数系数，即6工地与两个料场的距离，总共12个值</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">6</span>   <span class="comment">% 对于6个工地</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="number">2</span>       <span class="comment">% 接收两个料场的供用</span></span><br><span class="line">        l(<span class="built_in">i</span>,<span class="built_in">j</span>)=<span class="built_in">sqrt</span>((x(<span class="built_in">j</span>)-a(<span class="built_in">i</span>))^<span class="number">2</span>+(y(<span class="built_in">j</span>)-b(<span class="built_in">i</span>))^<span class="number">2</span>);   <span class="comment">% 距离</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">f = [l(:,<span class="number">1</span>);l(:,<span class="number">2</span>)];    <span class="comment">% 目标函数系数向量，总共12个值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 不等式约束条件的变量系数和常数项</span></span><br><span class="line"><span class="comment">% 双下标转换成单下标：x11=x1，x21=x2，x31=x3，x41=x4，x51=x5, x61=x6</span></span><br><span class="line"><span class="comment">% 双下标转换成单下标：x12=x7, x22=x8, x32=x9, x42=x10, x52=x11, x62=x12</span></span><br><span class="line">A = [<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">     <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% 两个临时料场日储量</span></span><br><span class="line">b = [<span class="number">20</span>;<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">% 矩阵的行数是约束条件个数，列数是变量个数</span></span><br><span class="line"><span class="comment">% 等式约束的变量系数和常数项</span></span><br><span class="line">Aeq = [<span class="built_in">eye</span>(<span class="number">6</span>),<span class="built_in">eye</span>(<span class="number">6</span>)];    <span class="comment">% 两个单位矩阵横向拼成</span></span><br><span class="line">beq=[d(<span class="number">1</span>);d(<span class="number">2</span>);d(<span class="number">3</span>);d(<span class="number">4</span>);d(<span class="number">5</span>);d(<span class="number">6</span>)];</span><br><span class="line"><span class="comment">% 所有变量下限全是0</span></span><br><span class="line">Vlb=[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]; </span><br><span class="line">[x,fval]=linprog(f,A,b,Aeq,beq,Vlb);</span><br><span class="line">x,fval</span><br></pre></td></tr></table></figure>
<h3 id="第二问代码非线性规划">第二问代码（非线性规划）</h3>
<p>fun2.m的文件内容为： <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ff</span> = <span class="title">fun2</span><span class="params">(x)</span></span></span><br><span class="line"><span class="comment">% 6个工地坐标</span></span><br><span class="line">a1 = [<span class="number">1.25</span> <span class="number">8.75</span> <span class="number">0.5</span> <span class="number">5.75</span> <span class="number">3</span> <span class="number">7.25</span>];</span><br><span class="line">b1 = [<span class="number">1.25</span> <span class="number">0.75</span> <span class="number">4.75</span> <span class="number">5</span> <span class="number">6.5</span> <span class="number">7.75</span>];</span><br><span class="line"></span><br><span class="line">f1=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% x(13)是第一个新料场的横坐标，x(14)是其纵坐标；</span></span><br><span class="line"><span class="comment">% x(15)是第二个新料场的横坐标，x(16)是其纵坐标；</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">6</span></span><br><span class="line">    s(<span class="built_in">i</span>)=<span class="built_in">sqrt</span>((x(<span class="number">13</span>)-a1(<span class="built_in">i</span>))^<span class="number">2</span>+(x(<span class="number">14</span>)-b1(<span class="built_in">i</span>))^<span class="number">2</span>); <span class="comment">% 第一个料场到各工地的距离</span></span><br><span class="line">    f1=s(<span class="built_in">i</span>)*x(<span class="built_in">i</span>)+f1;  <span class="comment">% 第一个料场给各工地的吨千米数</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">f2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">7</span>:<span class="number">12</span></span><br><span class="line">    s(<span class="built_in">i</span>)=<span class="built_in">sqrt</span>((x(<span class="number">15</span>)-a1(<span class="built_in">i</span><span class="number">-6</span>))^<span class="number">2</span>+(x(<span class="number">16</span>)-b1(<span class="built_in">i</span><span class="number">-6</span>))^<span class="number">2</span>);  <span class="comment">% 第二个料场到各工地的距离</span></span><br><span class="line">    f2=s(<span class="built_in">i</span>)*x(<span class="built_in">i</span>)+f2;  <span class="comment">% 第二个料场给各工地的吨千米数</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 总运输量（吨千米数）</span></span><br><span class="line">ff=f1+f2;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<h4
id="设置初始值为已知条件和第一问的值">设置初始值为已知条件和第一问的值</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">clc; clear all; close all</span><br><span class="line"><span class="comment">% 注意！第二问中求新料场位置，所以两个料场的横纵坐标也是变量，所以多了4个变量</span></span><br><span class="line"><span class="comment">% 对新坐标没有不等式约束，所以其不等式约束条件里的系数为0</span></span><br><span class="line">A2 = [<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">      <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line">B2 = [<span class="number">20</span>;<span class="number">20</span>];</span><br><span class="line"><span class="comment">% 对新坐标也没有等式约束，所以相应项也为0</span></span><br><span class="line">Aeq2 = [<span class="built_in">eye</span>(<span class="number">6</span>),<span class="built_in">eye</span>(<span class="number">6</span>),<span class="built_in">zeros</span>(<span class="number">6</span>,<span class="number">4</span>)];    <span class="comment">% 两个单位矩阵和一个全0矩阵拼成</span></span><br><span class="line">beq2=[<span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">7</span> <span class="number">6</span> <span class="number">11</span>]&#x27;;</span><br><span class="line">Vlb2=[<span class="built_in">zeros</span>(<span class="number">12</span>,<span class="number">1</span>);-<span class="built_in">inf</span>;-<span class="built_in">inf</span>;-<span class="built_in">inf</span>;-<span class="built_in">inf</span>];</span><br><span class="line"><span class="comment">% 非线性规划必须赋初值，可以基于问题情况来设，或设置rand()随机数等等；</span></span><br><span class="line"><span class="comment">% 初始值设为线性规划的计算结果，即临时料场的坐标</span></span><br><span class="line"><span class="comment">% 设置初始值x0，此处可直接使用第一问的值作为初始值；</span></span><br><span class="line">x0=[<span class="number">3</span> <span class="number">5</span> <span class="number">0</span> <span class="number">7</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">4</span> <span class="number">0</span> <span class="number">6</span> <span class="number">10</span> <span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">7</span>]&#x27;;  </span><br><span class="line">[x2,fval2]=fmincon(@fun2,x0,A2,B2,Aeq2,beq2,Vlb2)</span><br><span class="line"><span class="comment">% 若约束条件里有非线性函数，可使用在fmincon里使用nonlcon 项</span></span><br></pre></td></tr></table></figure>
<h4
id="使用蒙特卡罗法求一个近似解作为初始值">使用蒙特卡罗法求一个近似解作为初始值</h4>
<p>constraint.m 的文件内容为： <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[g,k]</span> = <span class="title">constraint</span><span class="params">(x)</span></span></span><br><span class="line"><span class="comment">% 不等式约束条件</span></span><br><span class="line"><span class="comment">% sum(x(:,1:6),2)是对矩阵前6列按行求和，即对前6个元素求和，</span></span><br><span class="line"><span class="comment">% 对应6个工地接收第一个料场的总量。再减去20，即把不等式右边常数项移到左边</span></span><br><span class="line">g = [sum(x(:,<span class="number">1</span>:<span class="number">6</span>),<span class="number">2</span>)<span class="number">-20</span>    </span><br><span class="line">     sum(x(:,<span class="number">7</span>:<span class="number">12</span>),<span class="number">2</span>)<span class="number">-20</span></span><br><span class="line">    ];</span><br><span class="line"><span class="comment">% 等式约束条件,6个工地从两个料场收到的总量分别为3,5,4,7,6,11</span></span><br><span class="line">k = [x(<span class="number">1</span>)+x(<span class="number">7</span>)<span class="number">-3</span></span><br><span class="line">     x(<span class="number">2</span>)+x(<span class="number">8</span>)<span class="number">-5</span></span><br><span class="line">     x(<span class="number">3</span>)+x(<span class="number">9</span>)<span class="number">-4</span></span><br><span class="line">     x(<span class="number">4</span>)+x(<span class="number">10</span>)<span class="number">-7</span></span><br><span class="line">     x(<span class="number">5</span>)+x(<span class="number">11</span>)<span class="number">-6</span></span><br><span class="line">     x(<span class="number">6</span>)+x(<span class="number">12</span>)<span class="number">-11</span></span><br><span class="line">    ];</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure> 主程序为：
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">clc; clear all; close all</span><br><span class="line"><span class="comment">% 1、因为第2问模型中有16个变量，所以要给16个变量分别生成随机值，作为当前解；</span></span><br><span class="line"><span class="comment">% 2、判断这些当前解是否满足模型的约束条件</span></span><br><span class="line"><span class="comment">% 3、若满足，代入目标函数，求当前目标函数值</span></span><br><span class="line"><span class="comment">% 4、判断当前目标函数值是否比已求的较优函数值更好，若是，则替换掉较优函数值和对应的较优解</span></span><br><span class="line"><span class="comment">% 5、不断重复前5步，构成统计意义，求得较优解。</span></span><br><span class="line">p0 = <span class="number">10000</span>; n = <span class="number">10</span>^<span class="number">6</span>; tic</span><br><span class="line">x_m0 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    <span class="comment">% 前12个数是6个工地从两个料场接收的量，6个工地分别需要3,5,4,7,6,11吨水泥</span></span><br><span class="line">    <span class="comment">% 所以前12个变量分别需要取0到3，0到5，……，0到11的随机数</span></span><br><span class="line">    <span class="comment">% 为加速求近似，取前12个变量（工地从料场接受的量）为随机整数</span></span><br><span class="line">    <span class="comment">% randi(n)为随机取1到n之间的一个整数，则randi(n+1)-1为取0到n间随机整数</span></span><br><span class="line">    <span class="comment">% 后4个变量是两个料场的横纵坐标，取一定范围内的随机数（根据题目，工地坐标都在0到9，所以此处取0到9）</span></span><br><span class="line">    x_m = [randi(<span class="number">4</span>)<span class="number">-1</span>,randi(<span class="number">6</span>)<span class="number">-1</span>,randi(<span class="number">5</span>)<span class="number">-1</span>,randi(<span class="number">8</span>)<span class="number">-1</span>,randi(<span class="number">7</span>)<span class="number">-1</span>,randi(<span class="number">12</span>)<span class="number">-1</span>,...</span><br><span class="line">        randi(<span class="number">4</span>)<span class="number">-1</span>,randi(<span class="number">6</span>)<span class="number">-1</span>,randi(<span class="number">5</span>)<span class="number">-1</span>,randi(<span class="number">8</span>)<span class="number">-1</span>,randi(<span class="number">7</span>)<span class="number">-1</span>,randi(<span class="number">12</span>)<span class="number">-1</span>,...</span><br><span class="line">        <span class="number">9</span>*<span class="built_in">rand</span>(<span class="number">1</span>,<span class="number">4</span>)];</span><br><span class="line">    </span><br><span class="line">    [g,k] = constraint(x_m);        <span class="comment">% 约束条件</span></span><br><span class="line">    <span class="keyword">if</span> all(g&lt;=<span class="number">0</span>)   <span class="comment">% 等式约束难以严格满足，所以此处相差不大即可算近似</span></span><br><span class="line">        <span class="keyword">if</span> all(<span class="built_in">abs</span>(k)&lt;=<span class="number">1</span>)</span><br><span class="line">            ff = fun2(x_m);     <span class="comment">% 目标函数</span></span><br><span class="line">            <span class="keyword">if</span> ff&lt;p0</span><br><span class="line">                x_m0 = x_m; p0 = ff;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">x_m0,p0,toc</span><br><span class="line"><span class="comment">% 以采样10^6次的蒙特卡罗法求得的近似值作为初始值，调用fmincon</span></span><br><span class="line">[x3,fval3]=fmincon(@fun2,x_m0,A2,B2,Aeq2,beq2,Vlb2)</span><br><span class="line"><span class="comment">% 此时最终求得的结果fval3 = 85.4054，</span></span><br><span class="line"><span class="comment">% 优于前面以第一问线性规划结果为初始值时求得的90.4920</span></span><br><span class="line"><span class="comment">% 注意！！！非线性规划每次求解的结果都不一样！！！</span></span><br><span class="line"><span class="comment">% 多次运行相同代码，得出的结果不相同是正常的！！！</span></span><br></pre></td></tr></table></figure></p>
<h2 id="python代码求解-1">python代码求解</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog, minimize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 工地坐标与水泥需求</span></span><br><span class="line"><span class="comment"># 工地横坐标列表</span></span><br><span class="line">a = [<span class="number">1.25</span>, <span class="number">8.75</span>, <span class="number">0.5</span>, <span class="number">5.75</span>, <span class="number">3</span>, <span class="number">7.25</span>]</span><br><span class="line"><span class="comment"># 工地纵坐标列表</span></span><br><span class="line">b = [<span class="number">1.25</span>, <span class="number">0.75</span>, <span class="number">4.75</span>, <span class="number">5</span>, <span class="number">6.5</span>, <span class="number">7.75</span>]</span><br><span class="line"><span class="comment"># 水泥日需求列表</span></span><br><span class="line">d = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">11</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一问：线性规划</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义两个料场的坐标（这里简单示例了坐标值，实际可能对应具体位置）</span></span><br><span class="line"><span class="comment"># 料场1的横坐标、纵坐标</span></span><br><span class="line">x1_coord, y1_coord = <span class="number">5</span>, <span class="number">1</span></span><br><span class="line"><span class="comment"># 料场2的横坐标、纵坐标</span></span><br><span class="line">x2_coord, y2_coord = <span class="number">2</span>, <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每个工地到料场1的距离</span></span><br><span class="line">distances_to_x1 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">    distance = np.sqrt((x1_coord - a[i]) ** <span class="number">2</span> + (y1_coord - b[i]) ** <span class="number">2</span>)</span><br><span class="line">    distances_to_x1.append(distance)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每个工地到料场2的距离</span></span><br><span class="line">distances_to_x2 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">    distance = np.sqrt((x2_coord - a[i]) ** <span class="number">2</span> + (y2_coord - b[i]) ** <span class="number">2</span>)</span><br><span class="line">    distances_to_x2.append(distance)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将两个料场到各工地的距离合并到一个列表中，形成距离向量（对应目标函数的系数向量）</span></span><br><span class="line">f = distances_to_x1 + distances_to_x2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造不等式约束的系数矩阵A</span></span><br><span class="line"><span class="comment"># 先初始化一个空列表用于构建A</span></span><br><span class="line">A = []</span><br><span class="line"><span class="comment"># 构建对应第一个料场供应各工地水泥量系数的行（每行6个1，后面6个0）</span></span><br><span class="line">row_1 = [<span class="number">1</span>] * <span class="number">6</span> + [<span class="number">0</span>] * <span class="number">6</span></span><br><span class="line">A.append(row_1)</span><br><span class="line"><span class="comment"># 构建对应第二个料场供应各工地水泥量系数的行（每行6个0，前面6个1）</span></span><br><span class="line">row_2 = [<span class="number">0</span>] * <span class="number">6</span> + [<span class="number">1</span>] * <span class="number">6</span></span><br><span class="line">A.append(row_2)</span><br><span class="line">A = np.array(A)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A=[[1 1 1 1 1 1 0 0 0 0 0 0]</span></span><br><span class="line"><span class="comment">#    [0 0 0 0 0 0 1 1 1 1 1 1]]</span></span><br><span class="line"><span class="comment"># 不等式约束的右侧常数向量（对应两个料场的水泥供应量上限）</span></span><br><span class="line">b_constraints = [<span class="number">20</span>, <span class="number">20</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造等式约束的系数矩阵A_eq，表示每个工地从两个料场获得的水泥量之和等于该工地的需求</span></span><br><span class="line"><span class="comment"># 先创建两个6阶单位矩阵</span></span><br><span class="line">eye_matrix_1 = np.eye(<span class="number">6</span>)</span><br><span class="line">eye_matrix_2 = np.eye(<span class="number">6</span>)</span><br><span class="line"><span class="comment"># 横向拼接两个单位矩阵</span></span><br><span class="line">A_eq = np.hstack((eye_matrix_1, eye_matrix_2))</span><br><span class="line"></span><br><span class="line"><span class="comment"># A_eq=[[1. 0. 0. 0. 0. 0. 1. 0. 0. 0. 0. 0.]</span></span><br><span class="line"><span class="comment">#       [0. 1. 0. 0. 0. 0. 0. 1. 0. 0. 0. 0.]</span></span><br><span class="line"><span class="comment">#       [0. 0. 1. 0. 0. 0. 0. 0. 1. 0. 0. 0.]</span></span><br><span class="line"><span class="comment">#       [0. 0. 0. 1. 0. 0. 0. 0. 0. 1. 0. 0.]</span></span><br><span class="line"><span class="comment">#       [0. 0. 0. 0. 1. 0. 0. 0. 0. 0. 1. 0.]</span></span><br><span class="line"><span class="comment">#       [0. 0. 0. 0. 0. 1. 0. 0. 0. 0. 0. 1.]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等式约束的右侧常数向量（各工地的水泥日需求）</span></span><br><span class="line">b_eq = np.array(d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置变量的边界，每个变量（水泥分配量）下限为0，上限无限制</span></span><br><span class="line">bounds = [(<span class="number">0</span>, <span class="literal">None</span>)] * <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用线性规划函数linprog求解</span></span><br><span class="line"><span class="comment"># f是目标函数的系数向量，目标是最小化运输距离总和（通过分配水泥量来实现）</span></span><br><span class="line"><span class="comment"># A_ub是不等式约束的系数矩阵，b_ub是不等式约束的右侧常数向量</span></span><br><span class="line"><span class="comment"># A_eq是等式约束的系数矩阵，b_eq是等式约束的右侧常数向量</span></span><br><span class="line"><span class="comment"># bounds是变量的边界约束</span></span><br><span class="line">result = linprog(f, A_ub=A, b_ub=b_constraints, A_eq=A_eq, b_eq=b_eq, bounds=bounds)</span><br><span class="line">x1, fval1 = result.x, result.fun</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第一问解：&quot;</span>, x1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第一问目标值：&quot;</span>, fval1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二问：非线性规划</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">objective</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="comment"># 定义目标函数，计算总的运输成本（这里基于距离和水泥分配量）</span></span><br><span class="line">    <span class="comment"># x是包含水泥分配量和料场坐标的变量向量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算第一个料场到各工地的运输成本总和</span></span><br><span class="line">    f1 = <span class="built_in">sum</span>(np.sqrt((x[<span class="number">12</span>] - a) ** <span class="number">2</span> + (x[<span class="number">13</span>] - b) ** <span class="number">2</span>) * x[:<span class="number">6</span>])</span><br><span class="line">    <span class="comment"># 计算第二个料场到各工地的运输成本总和</span></span><br><span class="line">    f2 = <span class="built_in">sum</span>(np.sqrt((x[<span class="number">14</span>] - a) ** <span class="number">2</span> + (x[<span class="number">15</span>] - b) ** <span class="number">2</span>) * x[<span class="number">6</span>:<span class="number">12</span>])</span><br><span class="line">    <span class="keyword">return</span> f1 + f2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接定义不等式约束条件对应的计算函数（这里不再通过多层函数调用）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inequality_constraints_direct</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="comment"># 直接定义不等式约束条件，要求两个料场分配的水泥总量不超过各自上限（这里设上限为20）。</span></span><br><span class="line">    <span class="keyword">return</span> np.array([<span class="number">20</span> - <span class="built_in">sum</span>(x[:<span class="number">6</span>]), <span class="number">20</span> - <span class="built_in">sum</span>(x[<span class="number">6</span>:<span class="number">12</span>])])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接定义等式约束条件对应的计算函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">equality_constraints_direct</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="comment"># 直接定义等式约束条件，各工地从两个料场获得的水泥量要满足工地需求。</span></span><br><span class="line">    <span class="keyword">return</span> np.array([x[<span class="number">0</span>] + x[<span class="number">6</span>] - <span class="number">3</span>, x[<span class="number">1</span>] + x[<span class="number">7</span>] - <span class="number">5</span>, x[<span class="number">2</span>] + x[<span class="number">8</span>] - <span class="number">4</span>,</span><br><span class="line">                    x[<span class="number">3</span>] + x[<span class="number">9</span>] - <span class="number">7</span>, x[<span class="number">4</span>] + x[<span class="number">10</span>] - <span class="number">6</span>, x[<span class="number">5</span>] + x[<span class="number">11</span>] - <span class="number">11</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建约束条件的字典列表，用于传递给优化函数，包含不等式和等式约束</span></span><br><span class="line">cons = [</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;ineq&quot;</span>, <span class="string">&quot;fun&quot;</span>: inequality_constraints_direct&#125;,  <span class="comment"># 不等式约束</span></span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;eq&quot;</span>, <span class="string">&quot;fun&quot;</span>: equality_constraints_direct&#125;       <span class="comment"># 等式约束</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 变量边界定义（和原代码保持一致，假设原代码中的 bounds2 定义合适）</span></span><br><span class="line">bounds2 = [(<span class="number">0</span>, <span class="literal">None</span>)] * <span class="number">12</span> + [(-np.inf, np.inf)] * <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># np.hstack函数用于沿水平方向（也就是列方向）堆叠数组序列，即将多个数组按顺序在水平方向拼接成一个新的数组</span></span><br><span class="line"><span class="comment"># 它要求输入的数组在除了拼接方向（列方向）外的其他维度大小要一致，这样才能正确拼接。</span></span><br><span class="line"><span class="comment"># 例如，有两个一维数组，我们可以使用np.hstack将它们拼接成一个一维数组，其中每行对应原来的一个一维数组。</span></span><br><span class="line"><span class="comment"># 以下是示例代码（此处仅为注释说明，可自行取消注释查看实际结果）：</span></span><br><span class="line"><span class="comment"># arr1 = np.array([1, 2, 3])</span></span><br><span class="line"><span class="comment"># arr2 = np.array([4, 5, 6])</span></span><br><span class="line"><span class="comment"># example_hstack = np.hstack([arr1, arr2])</span></span><br><span class="line"><span class="comment"># 拼接后得到的数组为：[1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="comment"># 如果是多个二维数组，比如有两个形状为(2, 3)的二维数组，使用np.hstack可以将它们拼接成一个形状为(2, 6)的二维数组，示例如下（此处仅为注释说明，可自行取消注释查看实际结果）：</span></span><br><span class="line"><span class="comment"># arr3 = np.array([[1, 2, 3], [4, 5, 6]])</span></span><br><span class="line"><span class="comment"># arr4 = np.array([[7, 8, 9], [10, 11, 12]])</span></span><br><span class="line"><span class="comment"># example_hstack_2d = np.hstack([arr3, arr4])</span></span><br><span class="line"><span class="comment"># 拼接后得到的二维数组如下：</span></span><br><span class="line"><span class="comment"># [[1, 2, 3, 7, 8, 9],</span></span><br><span class="line"><span class="comment">#  [4, 5, 6, 10, 11, 12]]</span></span><br><span class="line"></span><br><span class="line">x0_Lp = np.hstack([x1, [<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用scipy.minimize函数进行非线性规划求解，传入目标函数、初始值、约束条件和变量边界</span></span><br><span class="line">result2_Lp = minimize(fun=objective, x0=x0_Lp, constraints=cons, bounds=bounds2)</span><br><span class="line">x2_Lp, fval2_Lp = result2_Lp.x, result2_Lp.fun</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;用线性规划结果作为初值：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;解：&quot;</span>, x2_Lp)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;目标值：&quot;</span>, fval2_Lp)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/29/MonteCarloMethod/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/29/MonteCarloMethod/" class="post-title-link" itemprop="url">Monte Carlo Method</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-29 16:28:19" itemprop="dateCreated datePublished" datetime="2025-05-29T16:28:19+08:00">2025-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-06-14 18:23:55" itemprop="dateModified" datetime="2025-06-14T18:23:55+08:00">2025-06-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="蒙特卡罗法模型引出">蒙特卡罗法——模型引出</h1>
<h2
id="我们都知道圆周率π是个无理数那么有什么方法可以去算圆周率吗">我们都知道，圆周率π是个无理数，那么有什么方法可以去算圆周率吗？</h2>
<ul>
<li>圆的面积<span class="math inline">\(=\pi\times
r^2\)</span>，那如果我们能求得面积的值，自然也就能求得<span
class="math inline">\(\pi\)</span>的近似值</li>
<li>那么该怎么求圆的面积呢？ 一个半径为1的圆，其外切正方形面积易知为4  
若在正方形内随机撒大量的点，有些落在圆内，有些落在圆外</li>
</ul>
<h3 id="统计意义上">统计意义上</h3>
<p><span
class="math display">\[\frac{\text{圆内点数}}{\text{总点数}}=\frac{\text{圆面积}}{\text{正方形面积}}=\frac{\pi}{4}
~\Rightarrow~\pi =
4\times\frac{\text{圆内点数}}{\text{总点数}}\]</span></p>
<div style="display: flex; justify-content: space-between;">
<p> 
<img src="/images/MonteCarlo/1.jpg" alt="图片1" style="width: 50%;">  
<img src="/images/MonteCarlo/2.jpg" alt="图片2" style="width: 50%;"></p>
</div>
<h1 id="蒙特卡罗法模型原理">蒙特卡罗法——模型原理</h1>
<p><strong>提出背景：</strong>
蒙特卡罗方法诞生于20世纪40年代，由参与美国第二次世界大战“曼哈顿计划”的成员——S.M.乌拉姆和约翰·冯·诺依曼首次系统提出。冯·诺依曼以著名的赌城摩纳哥（Monte
Carlo）为这一方法命名，赋予其一种神秘而富有象征意义的色彩。事实上，早在此之前，类似思想已经存在。早在1777年，法国数学家布丰（Buffon）就提出了通过投针实验来估算圆周率的方法，这被认为是蒙特卡罗方法的雏形。</p>
<p><strong>定义：</strong>
蒙特卡罗方法，又称统计模拟法，是一种基于概率论与数理统计的计算方法。其核心思想是通过随机数（通常为伪随机数）来模拟问题的随机过程，将原问题与一个概率模型建立联系，并利用计算机进行大量的随机试验，从而获得问题的近似解。为突出其概率统计特征，方法名称借用了以博彩闻名的城市——蒙特卡罗。</p>
<p><strong>基本原理：</strong>
根据大数定律，当样本数量足够大时，某一事件的发生频率将趋近于其真实概率。这一统计规律正是蒙特卡罗方法得以成立的理论基础。</p>
<p><strong>注意事项：</strong>
需要强调的是，蒙特卡罗方法并非一种具体的算法，更准确地说，它是一种思想或方法论。只要所研究的问题能够与概率模型建立联系，就可以采用蒙特卡罗方法加以求解。因此，从数学建模的角度来看，蒙特卡罗方法并没有通用的实现代码，不同的问题需要构建相应的模型与模拟程序。</p>
<h1
id="蒙特卡罗法例题及matlab代码讲解">蒙特卡罗法——例题及matlab代码讲解</h1>
<h2 id="圆周率问题">圆周率问题</h2>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line"><span class="comment">%参数初始化：投放10000个点，圆半径为1，圆心坐标(1, 1)</span></span><br><span class="line"><span class="comment">%初始时还未投放点，有0个点在圆内  </span></span><br><span class="line">  p = <span class="number">10000</span>; r = <span class="number">1</span>; x0 = <span class="number">1</span>; y0 = <span class="number">1</span>; n = <span class="number">0</span>;  </span><br><span class="line">  <span class="built_in">hold</span> on <span class="comment">% 保持绘图窗口，多次绘图</span></span><br><span class="line">  <span class="comment">% rand函数产生在(0, 1)之间的随机数；rand函数还有其他多种形式</span></span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:p <span class="comment">% 对于要投放的总共p个点  </span></span><br><span class="line">      px = <span class="built_in">rand</span>*<span class="number">2</span>; <span class="comment">% 随机生成该点的横坐标  </span></span><br><span class="line">      py = <span class="built_in">rand</span>*<span class="number">2</span>; <span class="comment">% 随机生成该点的纵坐标  </span></span><br><span class="line">      <span class="comment">% 若该点在圆内，则颜色设为蓝色，变量n加1；在圆外则设为红色</span></span><br><span class="line">      <span class="keyword">if</span> (px<span class="number">-1</span>)^<span class="number">2</span> + (py<span class="number">-1</span>)^<span class="number">2</span> &lt; <span class="number">1</span> <span class="comment">% 横坐标的平方和小于半径，则在圆内</span></span><br><span class="line">          <span class="built_in">plot</span>(px, py, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;Color&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">          n = n+<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">plot</span>(px, py, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;Color&#x27;</span>, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">      <span class="keyword">end</span>  </span><br><span class="line">  <span class="keyword">end</span>  </span><br><span class="line">  axis equal <span class="comment">% 绘图时横纵坐标单位长度相同，便于观察圆  </span></span><br><span class="line">  s = (n/p)*<span class="number">4</span>;  </span><br><span class="line">  pi0 = s</span><br></pre></td></tr></table></figure>
<h2 id="三门问题">三门问题</h2>
<p>你参加一档电视节目，节目组提供了A、B、C三扇门，主持人告诉你，其中一扇门后边有辆汽车，其他两扇门后面是一头山羊，你可以选择一扇门打开获得门后的东西。</p>
<p>假如你选择了B门，这时，主持人打开了C门，让你看到C门后是只山羊，然后问你要不要改选A门？（你想要汽车）</p>
<ul>
<li>一般人的直觉：    
在三个门，参赛者选一个，主持人排除掉一个错误的，还剩一个。那么此时的命题变为：
 
<ul>
<li>条件：两个门里，一个是汽车，一个是山羊，任选一个。  </li>
<li>问题：交换选择是否能提高胜率？  </li>
<li>答案：不能，二选一的问题，选哪个门都是50%的胜率。  </li>
</ul></li>
<li>那真的是这样吗？我们可以用蒙特卡洛方法试一下。  </li>
</ul>
<h3
id="三门问题matlab代码在成功的条件下的概率">三门问题matlab代码——在成功的条件下的概率</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line"><span class="comment">%%  </span></span><br><span class="line">n = <span class="number">100000</span>; <span class="comment">% n代表蒙特卡罗模拟重复次数  </span></span><br><span class="line">a = <span class="number">0</span>; <span class="comment">% a表示不改变主意时能赢得汽车的次数  </span></span><br><span class="line">b = <span class="number">0</span>; <span class="comment">% b表示改变主意时能赢得汽车的次数  </span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>: n <span class="comment">% 开始模拟n次  </span></span><br><span class="line">    x = randi([<span class="number">1</span>,<span class="number">3</span>]); <span class="comment">% 随机生成一个1-3之间的整数x表示汽车出现在第x扇门后</span></span><br><span class="line">    y = randi([<span class="number">1</span>,<span class="number">3</span>]); <span class="comment">% 随机生成一个1-3之间的整数y表示自己选的门</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% 下面分为两种情况讨论：x=y和x≠y</span></span><br><span class="line">    <span class="keyword">if</span> x == y <span class="comment">% 如果x和y相同，那么我们只有不改变主意时才能赢</span></span><br><span class="line">        a = a + <span class="number">1</span>; b = b + <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">% x ≠ y , 如果x和y不同，那么我们只有改变主意时才能赢</span></span><br><span class="line">        a = a + <span class="number">0</span>; b = b +<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;蒙特卡罗方法得到的不改变主意时的获奖概率为: &#x27;</span>, num2str(a/n)]); </span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;蒙特卡罗方法得到的改变主意时的获奖概率为: &#x27;</span>, num2str(b/n)]); </span><br></pre></td></tr></table></figure>
<h3
id="三门问题代码考虑失败情况的代码无条件概率">三门问题代码——考虑失败情况的代码(无条件概率)</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line">n = <span class="number">100000</span>; <span class="comment">% n代表蒙特卡罗模拟重复次数  </span></span><br><span class="line">a = <span class="number">0</span>; <span class="comment">% a表示不改变主意时能赢得汽车的次数  </span></span><br><span class="line">b = <span class="number">0</span>; <span class="comment">% b表示改变主意时能赢得汽车的次数  </span></span><br><span class="line">c = <span class="number">0</span>; <span class="comment">% c表示没有获奖的次数  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>: n <span class="comment">% 开始模拟n次  </span></span><br><span class="line">    x = randi([<span class="number">1</span>,<span class="number">3</span>]); <span class="comment">% 随机生成一个1-3之间的整数x表示汽车出现在第x扇门后</span></span><br><span class="line">    y = randi([<span class="number">1</span>,<span class="number">3</span>]); <span class="comment">% 随机生成一个1-3之间的整数y表示自己选的门</span></span><br><span class="line">    change = randi([<span class="number">0</span>, <span class="number">1</span>]); <span class="comment">% change = 0 不改变主意, change = 1 改变主意</span></span><br><span class="line">    <span class="keyword">if</span> x == y <span class="comment">% 如果x和y相同，那么我们只有不改变主意时才能赢</span></span><br><span class="line">        <span class="keyword">if</span> change == <span class="number">0</span> <span class="comment">% 不改变主意</span></span><br><span class="line">            a = a + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">% 改变了主意</span></span><br><span class="line">            c = c+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">% x ≠ y , 如果x和y不同，那么我们只有改变主意时才能赢</span></span><br><span class="line">        <span class="keyword">if</span> change == <span class="number">0</span> <span class="comment">% 不改变主意</span></span><br><span class="line">            c = c + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">% 改变了主意</span></span><br><span class="line">            b = b + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;蒙特卡罗方法得到的不改变主意时的获奖概率为: &#x27;</span>, num2str(a/n)]); </span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;蒙特卡罗方法得到的的改变主意时的获奖概率为: &#x27;</span>, num2str(b/n)]); </span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;蒙特卡罗方法得到的没有获奖的概率为: &#x27;</span>, num2str(c/n)]);  </span><br></pre></td></tr></table></figure>
<h1
id="蒙特卡罗法例题及python代码讲解">蒙特卡罗法——例题及python代码讲解</h1>
<h2 id="圆周率问题-1">圆周率问题</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 参数初始化: 投放10000个点, 圆半径为1, 圆心坐标(1,1)</span></span><br><span class="line">p = <span class="number">10000</span>  <span class="comment"># 总共要投放的点数</span></span><br><span class="line">r = <span class="number">1</span>  <span class="comment"># 圆的半径</span></span><br><span class="line">x0, y0 = <span class="number">1</span>, <span class="number">1</span>  <span class="comment"># 圆心的坐标</span></span><br><span class="line">n = <span class="number">0</span>  <span class="comment"># 初始时还未投放点, 有0个点在圆内</span></span><br><span class="line"><span class="comment"># 设置绘图窗口</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.title(<span class="string">&#x27;Monte Carlo Simulation for Estimating Pi&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"><span class="comment"># 保持绘图窗口, 多次绘图</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(p):  <span class="comment"># 对于要投放的总共p个点</span></span><br><span class="line">    <span class="comment"># np.random.rand()函数产生在(0, 1)之间的随机数</span></span><br><span class="line">    px = np.random.rand() * <span class="number">2</span>  <span class="comment"># 随机生成该点的横坐标</span></span><br><span class="line">    py = np.random.rand() * <span class="number">2</span>  <span class="comment"># 随机生成该点的纵坐标</span></span><br><span class="line">    <span class="comment"># 判断点是否在圆内</span></span><br><span class="line">    <span class="keyword">if</span> (px - x0) ** <span class="number">2</span> + (py - y0) ** <span class="number">2</span> &lt; r ** <span class="number">2</span>:  <span class="comment"># 横纵坐标的平方和小于半径, 则在圆内</span></span><br><span class="line">        plt.plot(px, py, <span class="string">&#x27;.&#x27;</span>, color=<span class="string">&#x27;b&#x27;</span>)  <span class="comment"># 圆内点用蓝色表示</span></span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        plt.plot(px, py, <span class="string">&#x27;.&#x27;</span>, color=<span class="string">&#x27;r&#x27;</span>)  <span class="comment"># 圆外点用红色表示</span></span><br><span class="line">plt.axis(<span class="string">&#x27;equal&#x27;</span>)  <span class="comment"># 绘图时横纵坐标单位长度相同, 便于观察圆</span></span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 计算π的估计值</span></span><br><span class="line">s = (n / p) * <span class="number">4</span>  <span class="comment"># 计算圆面积占正方形面积的比例</span></span><br><span class="line">pi_estimate = s</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Estimated value of π: &quot;</span>, pi_estimate)</span><br></pre></td></tr></table></figure>
<h2 id="三门问题-1">三门问题</h2>
<h3
id="三门问题python代码在成功的条件下的概率">三门问题python代码——在成功的条件下的概率</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">n = <span class="number">100000</span>  <span class="comment"># n代表蒙特卡罗模拟重复次数</span></span><br><span class="line">a = <span class="number">0</span>  <span class="comment"># a表示不改变主意时能赢得汽车的次数</span></span><br><span class="line">b = <span class="number">0</span>  <span class="comment"># b表示改变主意时能赢得汽车的次数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># 开始模拟n次</span></span><br><span class="line">    x = np.random.randint(low=<span class="number">1</span>, high=<span class="number">4</span>)  <span class="comment"># 随机生成一个1-3之间的整数x表示汽车出现在第x扇门后</span></span><br><span class="line">    y = np.random.randint(low=<span class="number">1</span>, high=<span class="number">4</span>)  <span class="comment"># 随机生成一个1-3之间的整数y表示自己选的门</span></span><br><span class="line">    <span class="comment"># 下面分为两种情况讨论：x=y和x!=y</span></span><br><span class="line">    <span class="keyword">if</span> x == y:  <span class="comment"># 如果x和y相同，那么我们只有不改变主意时才能赢</span></span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># x != y，如果x和y不同，那么我们只有改变主意时才能赢</span></span><br><span class="line">        b += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;蒙特卡罗方法得到的不改变主意时的获奖概率为：&#x27;</span>, a/n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;蒙特卡罗方法得到的改变主意时的获奖概率为：&#x27;</span>, b/n)</span><br></pre></td></tr></table></figure>
<h3
id="三门问题python代码考虑失败情况的代码无条件概率">三门问题python代码——考虑失败情况的代码(无条件概率)</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">n = <span class="number">100000</span>  <span class="comment"># n代表蒙特卡罗模拟重复次数</span></span><br><span class="line">a = <span class="number">0</span>  <span class="comment"># a表示不改变主意时能赢得汽车的次数</span></span><br><span class="line">b = <span class="number">0</span>  <span class="comment"># b表示改变主意时能赢得汽车的次数</span></span><br><span class="line">c = <span class="number">0</span>  <span class="comment"># c表示没有获奖的次数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># 开始模拟n次</span></span><br><span class="line">    x = np.random.randint(low=<span class="number">1</span>, high=<span class="number">4</span>)  <span class="comment"># 随机生成一个1-3之间的整数x表示汽车出现在第x扇门后</span></span><br><span class="line">    y = np.random.randint(low=<span class="number">1</span>, high=<span class="number">4</span>)  <span class="comment"># 随机生成一个1-3之间的整数y表示自己选的门</span></span><br><span class="line">    change = np.random.randint(low=<span class="number">0</span>, high=<span class="number">2</span>)  <span class="comment"># change =0 不改变主意，change = 1 改变主意</span></span><br><span class="line">    <span class="comment"># 下面分为两种情况讨论：x=y和x!=y</span></span><br><span class="line">    <span class="keyword">if</span> x == y:  <span class="comment"># 如果x和y相同，那么我们只有不改变主意时才能赢</span></span><br><span class="line">        <span class="keyword">if</span> change == <span class="number">0</span>:  <span class="comment"># 不改变主意</span></span><br><span class="line">            a = a + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c = c + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># 改变了主意</span></span><br><span class="line">        <span class="keyword">if</span> change == <span class="number">0</span>:  <span class="comment"># 不改变主意</span></span><br><span class="line">            c = c + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            b = b + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;蒙特卡罗方法得到的不改变主意时的获奖概率为: &#x27;</span>, a/n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;蒙特卡罗方法得到的的改变主意时的获奖概率为: &#x27;</span>,b/n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;蒙特卡罗方法得到的没有获奖的概率为: &#x27;</span>,c/n)</span><br></pre></td></tr></table></figure>
<h1 id="附三门问题概率论分析">附：三门问题概率论分析</h1>
<p>三门问题（Monty Hall
problem）是一个经典的概率悖论，源自美国电视游戏节目《Let's Make a
Deal》。该问题涉及概率、信息更新和决策，常被用于教学概率论的基本概念。以下是详细分析，包括问题描述、直观误解、数学证明、关键点解释和扩展讨论。</p>
<h2 id="问题描述">问题描述</h2>
<ul>
<li>场景：有三扇关闭的门（门1、门2、门3）。一扇门后面有一辆汽车（奖品），另外两扇门后面是山羊（无奖）。</li>
<li>步骤：
<ul>
<li>参赛者随机选择一扇门（假设选择门1）。</li>
<li>主持人（蒙提霍尔）知道汽车的位置，会打开一扇<strong>没有汽车</strong>的门（露出山羊），且不能打开参赛者选择的门。例如，如果参赛者选择门1，主持人可能打开门3（假设门3后有山羊）。</li>
<li>主持人给参赛者一个选择：坚持原选择（门1）或换到剩下的那扇未打开的门（门2）。</li>
</ul></li>
<li><strong>核心问题</strong>：参赛者应该换门还是不换门？哪种策略获得汽车的概率更高？</li>
</ul>
<h2 id="直观误解">直观误解</h2>
<p>许多人（包括数学家和公众）的直觉是：</p>
<ul>
<li>主持人打开一扇山羊门后，剩下两扇门（原选门和另一扇未开门），汽车在任一扇门后的概率似乎都是50%。</li>
<li>因此，换门和不换门的获胜概率似乎相同（各50%）。</li>
</ul>
<p>然而，这个直觉是<strong>错误的</strong>。数学证明显示：</p>
<p>这种误解源于忽略了主持人的行为提供的新信息：</p>
<ul>
<li>主持人不是随机开门：他必须打开一扇山羊门，且不能打开参赛者选择的门。这相当于“过滤”了信息，增加了初始选择错误的可能性。</li>
<li>简单说：参赛者的初始选择只有1/3概率正确，而换门策略利用了主持人“揭示错误”的信息，将初始错误转化为优势。</li>
</ul>
<h2 id="条件概率贝叶斯定理">条件概率（贝叶斯定理）</h2>
<p>使用概率公式更严谨地计算。设：</p>
<ul>
<li><span class="math inline">\(C_i\)</span>: 汽车在门i后的事件（<span
class="math inline">\(i=1,2,3\)</span>），<span
class="math inline">\(P(C_i)=1/3\)</span>。</li>
<li><span class="math inline">\(S_1\)</span>: 参赛者初始选择门1。</li>
<li><span class="math inline">\(H_3\)</span>:
主持人打开门3（露出山羊），且门3 ≠ 参赛者选择。</li>
</ul>
<p>我们计算在主持人打开门3后，汽车在门1后的概率 <span
class="math inline">\(P(C_1|H_3)\)</span> 和在门2后的概率 <span
class="math inline">\(P(C_2|H_3)\)</span>。  
参赛者原选门1，如果坚持不换，获胜概率是 <span
class="math inline">\(P(C_1|H_3)\)</span>; 如果换到门2，获胜概率是 <span
class="math inline">\(P(C_2|H_3)\)</span>.</p>
<p>使用贝叶斯定理： <span
class="math display">\[P(C_i|H_3)=\frac{P(H_3|C_i)\cdot
P(C_i)}{P(H_3)}\]</span></p>
<ul>
<li><p><strong>计算 <span
class="math inline">\(P(H_3)\)</span>（主持人打开门3的总概率）</strong>：</p>
<ul>
<li>如果汽车在门1（<span
class="math inline">\(C_1\)</span>）：主持人可以打开门2或门3（各1/2概率），所以
<span class="math inline">\(P(H_3|C_1)=1/2\)</span>。</li>
<li>如果汽车在门2（$ C_2
$）：主持人必须打开门3（不能打开门2，有汽车），所以 <span
class="math inline">\(P(H_3|C_2)=1\)</span>。</li>
<li>如果汽车在门3（<span
class="math inline">\(C_3\)</span>）：主持人不能打开门3（有汽车），所以
<span class="math inline">\(P(H_3|C_3)=0\)</span>。</li>
<li>因此：     <span class="math display">\[\begin{aligned}
    P(H_3) &amp;= P(H_3 | C_1) P(C_1) + P(H_3 | C_2) P(C_2) + P(H_3 |
C_3) P(C_3)\\
    &amp;= \left(\frac{1}{2} \times \frac{1}{3}\right) + \left(1 \times
\frac{1}{3}\right) + \left(0 \times \frac{1}{3}\right) =\frac{1}{2}
    \end{aligned}
    \]</span></li>
</ul></li>
<li><p><strong>计算 $ P(C_1 | H_3)
$（汽车在门1后的条件概率，即不换门获胜概率）</strong>：   <span
class="math display">\[
  P(C_1 | H_3) = \frac{P(H_3 | C_1) \cdot P(C_1)}{P(H_3)} =
\frac{\frac{1}{2} \times \frac{1}{3}}{\frac{1}{2}} =
\frac{\frac{1}{6}}{\frac{1}{2}} = \frac{1}{6} \times 2 = \frac{1}{3}
  \]</span></p></li>
<li><p><strong>计算 $ P(C_2 | H_3)
$（汽车在门2后的条件概率，即换门获胜概率）</strong>：   <span
class="math display">\[
  P(C_2 | H_3) = \frac{P(H_3 | C_2) \cdot P(C_2)}{P(H_3)} = \frac{1
\times \frac{1}{3}}{\frac{1}{2}} = \frac{\frac{1}{3}}{\frac{1}{2}} =
\frac{1}{3} \times 2 = \frac{2}{3}
  \]</span></p></li>
</ul>
<p>结果：在主持人打开门3后，不换门获胜概率为1/3，换门获胜概率为2/3。这证明换门更优。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/23/Mandelbrot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/23/Mandelbrot/" class="post-title-link" itemprop="url">绘制mandelbrot集时所用到函数逐个解析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-23 19:13:34" itemprop="dateCreated datePublished" datetime="2025-05-23T19:13:34+08:00">2025-05-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一.-range-函数">一. <code>range</code> 函数</h2>
<h3 id="语法">语法</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">range</span>(<span class="title class_ inherited__">object</span>)</span><br><span class="line"> |  <span class="built_in">range</span>(stop) -&gt; <span class="built_in">range</span> <span class="built_in">object</span></span><br><span class="line"> |  <span class="built_in">range</span>(start, stop[, step]) -&gt; <span class="built_in">range</span> <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<h3 id="说明">说明</h3>
<ul>
<li><code>range(start, stop[, step])</code>：返回一个生成从
<code>start</code>（包含）到
<code>stop</code>（不包含）的整数序列的对象，步长为
<code>step</code>。</li>
<li><code>range(start, stop)</code>：生成从 <code>start</code> 到
<code>stop-1</code> 的整数序列。</li>
<li><code>range(stop)</code>：<code>start</code> 默认为
0，<code>stop</code> 是必须指定的。生成从 0 到 <code>stop-1</code>
的整数序列。</li>
<li><code>step</code> 可以是正数（递增）或负数（递减）。</li>
</ul>
<h3 id="示例">示例</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">range</span>(<span class="number">4</span>)  <span class="comment"># 生成 [0, 1, 2, 3]</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>)  <span class="comment"># 生成 [1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>)  <span class="comment"># 生成 [1, 3, 5, 7, 9]</span></span><br></pre></td></tr></table></figure>
<p>在 Python 中，<code>range(4)</code> 返回的是一个 <strong>range
对象</strong>（迭代器），而不是直接输出一个列表。如果你希望显示
<code>range(4)</code>
的内容，可以将其转换为列表或使用循环打印。以下是几种方法：</p>
<h5 id="方法-1转换为-list-显示">方法 1：转换为 <code>list</code>
显示</h5>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">4</span>)))   <span class="comment">#输出 [0, 1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>list(range(4))</code> 将 <code>range(4)</code>
转换为列表，显示所有元素。</li>
</ul>
<h5 id="方法-2使用-for-循环打印">方法 2：使用 <code>for</code>
循环打印</h5>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(num, end=<span class="string">&#x27; &#x27;</span>)  <span class="comment"># 用空格分隔，输出 0 1 2 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>直接遍历 <code>range(4)</code> 并逐个打印。</li>
</ul>
<h5 id="方法-3解包-range-对象">方法 3：解包 <code>range</code> 对象</h5>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(*<span class="built_in">range</span>(<span class="number">4</span>))  <span class="comment"># 使用 * 解包，输出 0 1 2 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>*range(4)</code> 将 <code>range(4)</code>
解包为独立参数，<code>print()</code> 默认用空格分隔。</li>
</ul>
<h5 id="方法-4拼接字符串">方法 4：拼接字符串</h5>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, <span class="built_in">range</span>(<span class="number">4</span>))))  <span class="comment"># 使用 * 解包，输出 0 1 2 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>map(str, range(4))</code>
将数字转为字符串，<code>join()</code> 拼接成一行。</li>
</ul>
<h5 id="为什么-range4-不直接显示数字">为什么 <code>range(4)</code>
不直接显示数字？</h5>
<ul>
<li>Python 3 的 <code>range()</code> 返回的是一个
<strong>惰性序列</strong>（按需生成值），节省内存。<br />
</li>
<li>直接打印 <code>range(4)</code> 会显示对象信息，而非内容：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">range</span>(<span class="number">4</span>))  <span class="comment"># 输出: range(0, 4)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二.-real-和-imag-属性">二. <code>real</code> 和
<code>imag</code> 属性</h2>
<h3 id="说明-1">说明</h3>
<ul>
<li><code>real</code>：获取复数的实部。</li>
<li><code>imag</code>：获取复数的虚部。</li>
</ul>
<h3 id="示例-1">示例</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">z = <span class="number">3</span> + <span class="number">4j</span></span><br><span class="line"><span class="built_in">print</span>(z.real)  <span class="comment"># 输出 3.0</span></span><br><span class="line"><span class="built_in">print</span>(z.imag)  <span class="comment"># 输出 4.0</span></span><br></pre></td></tr></table></figure>
<h2 id="三.-ogrid-与-mgrid">三. <code>ogrid</code> 与
<code>mgrid</code></h2>
<h3 id="语法-1">语法</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numpy.ogrid[start:stop:step, start:stop:step, ...]</span><br><span class="line">numpy.mgrid[start:stop:step, start:stop:step, ...]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>start</code>：起始值（包含）。</li>
<li><code>stop</code>：结束值（不包含）。</li>
<li><code>step</code>：步长。</li>
<li><h3 id="说明-2">说明</h3></li>
<li><code>ogrid</code>：生成稀疏数组（节省内存）。</li>
<li><code>mgrid</code>：生成密集数组（完全展开的网格）。</li>
</ul>
<h3 id="示例-2">示例</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># ogrid 示例</span></span><br><span class="line">x = np.ogrid[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 输出: [0 1 2 3 4]</span></span><br><span class="line"></span><br><span class="line">x, y = np.ogrid[<span class="number">0</span>:<span class="number">3</span>, <span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 输出: [[0] [1] [2]]</span></span><br><span class="line"><span class="built_in">print</span>(y)  <span class="comment"># 输出: [[0 1 2]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mgrid 示例</span></span><br><span class="line">x, y = np.mgrid[<span class="number">0</span>:<span class="number">3</span>, <span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 输出: [[0 0 0] [1 1 1] [2 2 2]]</span></span><br><span class="line"><span class="built_in">print</span>(y)  <span class="comment"># 输出: [[0 1 2] [0 1 2] [0 1 2]]</span></span><br></pre></td></tr></table></figure>
<p>以下两个程序，通过画图可以直观显示出ogrid和mgrid这两个函数在生成数据集时的差异。
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x,y=np.ogrid[<span class="number">0</span>:<span class="number">5</span>,<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line">plt.scatter(x,y)</span><br><span class="line">plt.show()</span><br><span class="line">plt.savefig(<span class="string">&#x27;ogrid-draw.png&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x,y=np.mgrid[<span class="number">0</span>:<span class="number">5</span>,<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line">plt.scatter(x,y)</span><br><span class="line">plt.title(<span class="string">&quot;5x5 Grid Scatter Plot&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;X-axis&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Y-axis&quot;</span>)</span><br><span class="line">plt.show()</span><br><span class="line">plt.savefig(<span class="string">&#x27;mgrid-draw.png&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="四.-numpy.asarray-与-numpy.array">四. <code>numpy.asarray</code>
与 <code>numpy.array</code></h2>
<h3 id="语法-2">语法</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.asarray(a, dtype=<span class="literal">None</span>, order=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>a</code></strong>:
输入数据，可以是列表、元组、数组或其他可转换为数组的对象。</li>
<li><strong><code>dtype</code></strong>:
可选参数，指定数组的数据类型（如 <code>float</code>、<code>int</code>
等）。</li>
<li><strong><code>order</code></strong>:
可选参数，指定数组的内存布局（如 <code>'C'</code> 表示 C
风格，<code>'F'</code> 表示 Fortran 风格）。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.array(<span class="built_in">object</span>, dtype=<span class="literal">None</span>, copy=<span class="literal">True</span>, order=<span class="string">&#x27;K&#x27;</span>, subok=<span class="literal">False</span>, ndmin=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>object</code></strong>:
<ul>
<li><strong>类型</strong>:
任何可迭代对象（如列表、元组、其他数组等）。</li>
<li><strong>作用</strong>: 输入数据，用于创建 NumPy 数组。</li>
<li><strong>示例</strong>: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numpy.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment"># 从列表创建数组</span></span><br><span class="line">numpy.array((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))  <span class="comment"># 从元组创建数组</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>dtype</code></strong>:
<ul>
<li><strong>类型</strong>: 数据类型对象（如
<code>int</code>、<code>float</code>、<code>str</code> 等）或字符串（如
<code>'int32'</code>、<code>'float64'</code>）。</li>
<li><strong>作用</strong>: 指定数组的数据类型。如果未指定，NumPy
会自动推断数据类型。</li>
<li><strong>示例</strong>: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numpy.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=<span class="built_in">float</span>)  <span class="comment"># 指定为浮点数类型</span></span><br><span class="line">numpy.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=<span class="string">&#x27;int32&#x27;</span>)  <span class="comment"># 指定为 32 位整数类型</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>copy</code></strong>:
<ul>
<li><strong>类型</strong>: 布尔值（<code>True</code> 或
<code>False</code>）。</li>
<li><strong>作用</strong>: 是否创建输入数据的副本。如果为
<code>True</code>（默认），则总是创建新数组；如果为
<code>False</code>，则尽可能避免复制数据（仅在必要时复制）。</li>
<li><strong>示例</strong>: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = numpy.array(a, copy=<span class="literal">False</span>)  <span class="comment"># 尽可能不复制数据</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>order</code></strong>:
<ul>
<li><strong>类型</strong>:
字符串（<code>'C'</code>、<code>'F'</code>、<code>'A'</code> 或
<code>'K'</code>）。</li>
<li><strong>作用</strong>: 控制数组的内存布局。
<ul>
<li><code>'C'</code>: C 风格（行优先）。</li>
<li><code>'F'</code>: Fortran 风格（列优先）。</li>
<li><code>'A'</code>: 如果输入是 Fortran 风格的数组，则返回 Fortran
风格；否则返回 C 风格。</li>
<li><code>'K'</code>: 尽可能保持输入数据的布局（默认）。</li>
</ul></li>
<li><strong>示例</strong>: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], order=<span class="string">&#x27;F&#x27;</span>)  <span class="comment"># 列优先存储</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>subok</code></strong>:
<ul>
<li><strong>类型</strong>: 布尔值（<code>True</code> 或
<code>False</code>）。</li>
<li><strong>作用</strong>: 是否返回子类数组。如果为
<code>True</code>，则返回输入对象的子类数组；如果为
<code>False</code>（默认），则返回基类 <code>ndarray</code>。</li>
<li><strong>示例</strong>: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span>(numpy.ndarray):</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line">a = numpy.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).view(MyArray)</span><br><span class="line">b = numpy.array(a, subok=<span class="literal">True</span>)  <span class="comment"># 返回 MyArray 类型</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong><code>ndmin</code></strong>:
<ul>
<li><strong>类型</strong>: 整数。</li>
<li><strong>作用</strong>:
指定返回数组的最小维度。如果输入数据的维度小于
<code>ndmin</code>，则会自动补全维度。</li>
<li><strong>示例</strong>: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], ndmin=<span class="number">2</span>)  <span class="comment"># 返回二维数组</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="说明-3">说明</h3>
<ul>
<li><code>numpy.asarray</code>：将输入转换为 <code>numpy</code>
数组，如果输入已经是数组，则不创建副本。</li>
<li><code>numpy.array</code>：总是创建一个新的数组副本。</li>
</ul>
<h3 id="示例-3">示例</h3>
<h4
id="示例1将列表转换为数组输入已经是数组">示例1：将列表转换为数组+输入已经是数组</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="comment">#asarray示例</span></span><br><span class="line">arr=np.asarray(data)</span><br><span class="line"><span class="built_in">print</span>(arr)<span class="comment"># 输出: [1 2 3 4]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(arr)) <span class="comment">#输出&lt;class &#x27;numpy.ndarray&#x27;&gt;，表示 N-dimensional array（N 维数组），简称 ndarray</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#array示例</span></span><br><span class="line">brr=np.array(data)<span class="comment"># 输出: [1 2 3 4]</span></span><br><span class="line"><span class="built_in">print</span>(brr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输入已经是数组</span></span><br><span class="line">crr=np.asarray(brr)</span><br><span class="line"><span class="built_in">print</span>(crr <span class="keyword">is</span> brr)<span class="comment">#输出: True（有创建新副本）</span></span><br><span class="line"></span><br><span class="line">drr=np.array(brr)</span><br><span class="line"><span class="built_in">print</span>(drr <span class="keyword">is</span> brr)<span class="comment">#输出: False（创建了新副本）</span></span><br></pre></td></tr></table></figure>
<h4 id="示例-2指定数据类型">示例 2：指定数据类型</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">arr = np.asarray(data, dtype=<span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">print</span>(arr)  <span class="comment"># 输出: [1. 2. 3. 4.]</span></span><br></pre></td></tr></table></figure>
<h2 id="五.-numpy.frompyfunc">五. <code>numpy.frompyfunc</code></h2>
<h3 id="语法-3">语法</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.frompyfunc(func, nin, nout)</span><br></pre></td></tr></table></figure>
<h3 id="说明-4">说明</h3>
<ul>
<li><code>frompyfunc</code> 是 NumPy 库中的一个函数，用于将普通的 Python
函数转换为 <strong>通用函数（ufunc）</strong>。通用函数是 NumPy
中的一种特殊函数，可以对NumPy数组进行逐元素操作，并支持<strong>广播机制</strong>。
<strong>返回对象数组</strong>：默认情况下，<code>frompyfunc</code>
返回的对象是 <code>dtype=object</code>
的数组。如果需要特定类型，可以使用 <code>np.vectorize</code>。</li>
</ul>
<h3 id="示例-4">示例</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个普通的 Python 函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_add</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 将 Python 函数转换为 ufunc</span></span><br><span class="line">my_ufunc = np.frompyfunc(my_add, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 ufunc 操作 NumPy 数组</span></span><br><span class="line">result = my_ufunc(np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]), np.array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]))</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出: [5 7 9]</span></span><br></pre></td></tr></table></figure>
<h3 id="与-np.vectorize-的区别">与 <code>np.vectorize</code> 的区别</h3>
<ul>
<li><code>np.vectorize</code> 是另一个类似的函数，也可以将 Python
函数转换为
ufunc，但它提供了更多的选项（如指定输出类型）。<code>frompyfunc</code>
更底层，性能稍高，但功能较少。</li>
</ul>
<h2 id="六.-广播机制">六. 广播机制</h2>
<h3 id="说明-5">说明</h3>
<ul>
<li>广播机制允许在不同形状的数组之间进行算术运算，自动扩展较小的数组以匹配较大数组的形状。</li>
</ul>
<h3 id="广播规则">广播规则</h3>
<ol type="1">
<li><strong>维度对齐</strong>：从数组的最后一个维度（最右边）开始，依次比较两个数组的维度大小。</li>
<li><strong>维度兼容</strong>：两个数组的维度大小在以下情况下是兼容的：
<ul>
<li>两个维度的大小相等。</li>
<li>其中一个维度的大小为 1。</li>
</ul></li>
<li><strong>扩展维度</strong>：如果两个数组的维度不匹配，NumPy
会将大小为 1 的维度扩展为与另一个数组对应维度的大小相同。</li>
<li><strong>维度不足</strong>：如果两个数组的维度数不同，NumPy
会在形状较小的数组前面补 1，直到两个数组的维度数相同。</li>
</ol>
<h3 id="示例-5">示例</h3>
<h4 id="示例-1标量与数组的广播">示例 1：标量与数组的广播</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 标量 b 被广播为 [2, 2, 2]，然后与 a 相加</span></span><br><span class="line">result = a + b</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出: [3 4 5]</span></span><br></pre></td></tr></table></figure>
<h4 id="示例-2不同形状数组的广播">示例 2：不同形状数组的广播</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])  <span class="comment"># 形状: (2, 3)</span></span><br><span class="line">b = np.array([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>])            <span class="comment"># 形状: (3,)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># b 被广播为 [[10, 20, 30], [10, 20, 30]]，然后与 a 相加</span></span><br><span class="line">result = a + b</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># [[11 22 33]</span></span><br><span class="line"><span class="comment">#  [14 25 36]]</span></span><br></pre></td></tr></table></figure>
<h4 id="示例-3维度不足的广播">示例 3：维度不足的广播</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>], [<span class="number">2</span>], [<span class="number">3</span>]])  <span class="comment"># 形状: (3, 1)</span></span><br><span class="line">b = np.array([<span class="number">10</span>, <span class="number">20</span>])         <span class="comment"># 形状: (2,)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># a 被广播为 [[1, 1], [2, 2], [3, 3]]</span></span><br><span class="line"><span class="comment"># b 被广播为 [[10, 20], [10, 20], [10, 20]]</span></span><br><span class="line">result = a + b</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># [[11 21]</span></span><br><span class="line"><span class="comment">#  [12 22]</span></span><br><span class="line"><span class="comment">#  [13 23]]</span></span><br></pre></td></tr></table></figure>
<h3 id="广播的限制">广播的限制</h3>
<p>广播机制虽然强大，但并非所有形状的数组都可以广播。如果两个数组的形状在任何维度上都不兼容（即既不相等，也不为
1），则会引发 <code>ValueError</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment"># 形状: (3,)</span></span><br><span class="line">b = np.array([<span class="number">10</span>, <span class="number">20</span>])   <span class="comment"># 形状: (2,)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 无法广播，因为最后一个维度的大小不兼容</span></span><br><span class="line">result = a + b  <span class="comment"># 引发 ValueError</span></span><br></pre></td></tr></table></figure>
<h2 id="七.-astype">七. <code>astype</code></h2>
<h3 id="语法-4">语法</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ndarray.astype(dtype, order=<span class="string">&#x27;K&#x27;</span>, casting=<span class="string">&#x27;unsafe&#x27;</span>, subok=<span class="literal">True</span>, copy=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>dtype</code></strong>: 目标数据类型（如
<code>int</code>、<code>float</code>、<code>str</code> 等）。</li>
<li><strong><code>order</code></strong>: 控制内存布局（可选，默认
<code>'K'</code>）。</li>
<li><strong><code>casting</code></strong>:
控制类型转换的规则（可选，默认 <code>'unsafe'</code>）。</li>
<li><strong><code>subok</code></strong>: 是否返回子类（可选，默认
<code>True</code>）。</li>
<li><strong><code>copy</code></strong>: 是否创建副本（可选，默认
<code>True</code>）。</li>
</ul>
<h3 id="说明-6">说明</h3>
<ul>
<li><code>astype</code>
的主要作用是改变数组的数据类型。例如，将整数数组转换为浮点数数组，或者将浮点数数组转换为字符串数组等。</li>
</ul>
<h3 id="示例-6">示例</h3>
<h4 id="示例1.-将整数数组转换为浮点数数组">示例1.
将整数数组转换为浮点数数组</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">b = a.astype(<span class="built_in">float</span>)  <span class="comment"># 将整数数组转换为浮点数数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b)             <span class="comment"># 输出: [1. 2. 3. 4.]</span></span><br><span class="line"><span class="built_in">print</span>(b.dtype)       <span class="comment"># 输出: float64</span></span><br></pre></td></tr></table></figure>
<h4 id="示例2.-将浮点数数组转换为整数数组">示例2.
将浮点数数组转换为整数数组</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1.5</span>, <span class="number">2.7</span>, <span class="number">3.9</span>])</span><br><span class="line">b = a.astype(<span class="built_in">int</span>)    <span class="comment"># 将浮点数数组转换为整数数组（小数部分会被截断）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b)             <span class="comment"># 输出: [1 2 3]</span></span><br><span class="line"><span class="built_in">print</span>(b.dtype)       <span class="comment"># 输出: int64</span></span><br></pre></td></tr></table></figure>
<h4 id="示例3.-将数组转换为字符串类型">示例3.
将数组转换为字符串类型</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">b = a.astype(<span class="built_in">str</span>)    <span class="comment"># 将数组转换为字符串类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b)             <span class="comment"># 输出: [&#x27;1&#x27; &#x27;2&#x27; &#x27;3&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(b.dtype)       <span class="comment"># 输出: &lt;U21 (表示长度为 21 的 Unicode 字符串)</span></span><br></pre></td></tr></table></figure>
<h4 id="示例4.-指定数据类型">示例4. 指定数据类型</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">b = a.astype(np.float32)  <span class="comment"># 将数组转换为 32 位浮点数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b)             <span class="comment"># 输出: [1. 2. 3.]</span></span><br><span class="line"><span class="built_in">print</span>(b.dtype)       <span class="comment"># 输出: float32</span></span><br></pre></td></tr></table></figure>
<h3 id="注意事项">注意事项</h3>
<ol type="1">
<li><strong>数据截断</strong>：如果将浮点数转换为整数，小数部分会被截断，而不是四舍五入。</li>
<li><strong>内存占用</strong>：不同的数据类型占用的内存空间不同，转换时需要注意内存开销。</li>
<li><strong>副本创建</strong>：默认情况下，<code>astype</code>
会创建一个新的数组副本。如果不需要副本，可以设置
<code>copy=False</code>，但前提是数据类型兼容。</li>
</ol>
<h2 id="八.-numpy.stack">八. <code>numpy.stack</code></h2>
<h3 id="语法-5">语法</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.stack(arrays, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>arrays</code></strong>:
需要堆叠的数组序列（通常是一个列表或元组）。</li>
<li><strong><code>axis</code></strong>: 指定沿哪个轴堆叠数组。默认是
<code>axis=0</code>，表示沿着新的第一个维度堆叠。</li>
</ul>
<h3 id="示例-7">示例</h3>
<h4 id="示例1.-沿新轴堆叠一维数组">示例1. 沿新轴堆叠一维数组</h4>
<p>垂直堆叠（按行合并，axis=0）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">b = np.array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 沿 axis=0 堆叠</span></span><br><span class="line">stacked = np.stack([a, b])</span><br><span class="line"><span class="built_in">print</span>(stacked)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[1 2 3]</span><br><span class="line"> [4 5 6]]</span><br></pre></td></tr></table></figure>
<ul>
<li>这里 <code>a</code> 和 <code>b</code> 是一维数组，<code>stack</code>
将它们沿新的第一个维度堆叠，形成一个二维数组。</li>
</ul>
<h4 id="示例2.-沿-axis1-堆叠">示例2. 沿 axis=1 堆叠</h4>
<p>水平堆叠（按列合并，axis=1）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stacked = np.stack([a, b], axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(stacked)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[1 4]</span><br><span class="line"> [2 5]</span><br><span class="line"> [3 6]]</span><br></pre></td></tr></table></figure>
<ul>
<li>这里 <code>a</code> 和 <code>b</code>
沿第二个维度（<code>axis=1</code>）堆叠。</li>
</ul>
<h4 id="示例3.-堆叠二维数组">示例3. 堆叠二维数组</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">y = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 沿 axis=0 堆叠</span></span><br><span class="line">stacked = np.stack([x, y])</span><br><span class="line"><span class="built_in">print</span>(stacked)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[[1 2]</span><br><span class="line">  [3 4]]</span><br><span class="line"></span><br><span class="line"> [[5 6]</span><br><span class="line">  [7 8]]]</span><br></pre></td></tr></table></figure>
<ul>
<li>这里 <code>x</code> 和 <code>y</code> 是二维数组，<code>stack</code>
将它们沿新的第一个维度堆叠，形成一个三维数组。</li>
</ul>
<h4 id="示例4.-沿-axis2-堆叠">示例4. 沿 axis=2 堆叠</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stacked = np.stack([x, y], axis=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(stacked)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[[1 5]</span><br><span class="line">  [2 6]]</span><br><span class="line"></span><br><span class="line"> [[3 7]</span><br><span class="line">  [4 8]]]</span><br></pre></td></tr></table></figure>
<ul>
<li>这里 <code>x</code> 和 <code>y</code>
沿第三个维度（<code>axis=2</code>）堆叠。</li>
</ul>
<h3
id="numpy.stack-与-numpy.concatenate-的区别"><code>numpy.stack</code> 与
<code>numpy.concatenate</code> 的区别</h3>
<ul>
<li><strong><code>numpy.stack</code></strong>:
创建一个新的维度来堆叠数组。</li>
<li><strong><code>numpy.concatenate</code></strong>:
在现有维度上连接数组，不会创建新的维度。</li>
</ul>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">b = np.array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 concatenate</span></span><br><span class="line">concatenated = np.concatenate([a, b])</span><br><span class="line"><span class="built_in">print</span>(concatenated)  <span class="comment"># 输出: [1 2 3 4 5 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 stack</span></span><br><span class="line">stacked = np.stack([a, b])</span><br><span class="line"><span class="built_in">print</span>(stacked)  <span class="comment"># 输出: [[1 2 3] [4 5 6]]</span></span><br></pre></td></tr></table></figure>
<h2 id="九.-pil.image.fromarray">九.
<code>PIL.Image.fromarray</code></h2>
<h3 id="语法-6">语法</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PIL.Image.fromarray(array, mode=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>数据类型 (<code>dtype</code>)</strong>:
<ul>
<li><code>Image.fromarray</code> 要求输入数组的数据类型为
<code>np.uint8</code>（0 到 255 的整数）。</li>
<li>如果数组的值是浮点数（例如 0 到 1 之间的值），需要先将其转换为
<code>np.uint8</code>：</li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array = (array * <span class="number">255</span>).astype(np.uint8)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>数组形状</strong>:
<ul>
<li>灰度图像：2D 数组，形状为 <code>(height, width)</code>。</li>
<li>彩色图像：3D 数组，形状为 <code>(height, width, 3)</code>（RGB）或
<code>(height, width, 4)</code>（RGBA）。</li>
</ul></li>
<li><strong>模式 (<code>mode</code>)</strong>:
<ul>
<li><code>Image.fromarray</code> 会自动根据数组的形状推断图像的模式（如
<code>'L'</code> 表示灰度，<code>'RGB'</code> 表示彩色）。</li>
<li>如果需要指定模式，可以使用 <code>mode</code> 参数：</li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image = Image.fromarray(array, mode=<span class="string">&#x27;RGB&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="说明-7">说明</h3>
<ul>
<li>将 NumPy 数组转换为 PIL 图像对象。 在 Python
中，<code>PIL.Image.fromarray</code> 是 PIL（Python Imaging
Library）或其分支 Pillow 库中的一个函数，用于将 NumPy 数组转换为 PIL
图像对象。这对于处理图像数据（例如从 NumPy 数组生成图像）非常有用。</li>
<li>如果你还没有安装 Pillow，可以通过以下命令安装：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pillow</span><br></pre></td></tr></table></figure>
<h3 id="示例-8">示例</h3>
<ul>
<li><code>Image.fromarray</code> 的基本用法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<h4 id="示例1将-numpy-数组转换为灰度图像">示例1：将 NumPy
数组转换为灰度图像</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 创建一个 2D NumPy 数组（灰度图像）</span></span><br><span class="line">array = np.array([</span><br><span class="line">    [<span class="number">0</span>, <span class="number">50</span>, <span class="number">100</span>],</span><br><span class="line">    [<span class="number">150</span>, <span class="number">200</span>, <span class="number">255</span>]</span><br><span class="line">], dtype=np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数组转换为 PIL 图像</span></span><br><span class="line">image = Image.fromarray(array)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line">image.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存图像</span></span><br><span class="line">image.save(<span class="string">&#x27;gray_image.png&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">array = np.array([[<span class="number">0</span>, <span class="number">255</span>], [<span class="number">255</span>, <span class="number">0</span>]], dtype=np.uint8)</span><br><span class="line">image = Image.fromarray(array, mode=<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">image.show()</span><br></pre></td></tr></table></figure>
<ul>
<li>这里<code>dtype=np.uint8</code> 确保数组的值在 0 到 255 之间。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 100x100 的灰度图像（随机像素值）</span></span><br><span class="line">gray_image = np.random.randint(<span class="number">0</span>, <span class="number">256</span>, size=(<span class="number">100</span>, <span class="number">100</span>), dtype=np.uint8)</span><br><span class="line"><span class="comment"># numpy.random.randint(low, high=None, size=None, dtype=&#x27;int&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数组转换为 PIL 图像</span></span><br><span class="line">image = Image.fromarray(gray_image, mode=<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line">image.show()</span><br></pre></td></tr></table></figure>
<h4 id="示例2.-将-numpy-数组转换为彩色图像">示例2. 将 NumPy
数组转换为彩色图像</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 创建一个 3D NumPy 数组（RGB 图像）</span></span><br><span class="line">array = np.array([</span><br><span class="line">    [[<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>]],  <span class="comment"># 红色, 绿色, 蓝色</span></span><br><span class="line">    [[<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>], [<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>], [<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>]]  <span class="comment"># 黄色, 洋红色, 青色</span></span><br><span class="line">], dtype=np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数组转换为 PIL 图像</span></span><br><span class="line">image = Image.fromarray(array)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line">image.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存图像</span></span><br><span class="line">image.save(<span class="string">&#x27;color_image.png&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 创建一个 100x100 的彩色图像（随机 RGB 值）</span></span><br><span class="line">color_image = np.random.randint(<span class="number">0</span>, <span class="number">256</span>, size=(<span class="number">100</span>, <span class="number">100</span>, <span class="number">3</span>), dtype=np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数组转换为 PIL 图像</span></span><br><span class="line">image = Image.fromarray(color_image, mode=<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line">image.show()</span><br></pre></td></tr></table></figure>
<h4 id="示例3将浮点数组转换为图像">示例3：将浮点数组转换为图像</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 创建一个浮点数组（值在 0 到 1 之间）</span></span><br><span class="line">array = np.random.rand(<span class="number">100</span>, <span class="number">100</span>)  <span class="comment"># 100x100 的随机灰度图像</span></span><br><span class="line"><span class="comment">#在NumPy中，random.rand()是一个常用的随机数生成函数，用于生成均匀分布在[0, 1)之间的随机数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将浮点数组转换为 0-255 的整数数组</span></span><br><span class="line">array = (array * <span class="number">255</span>).astype(np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数组转换为 PIL 图像</span></span><br><span class="line">image = Image.fromarray(array, mode=<span class="string">&#x27;L&#x27;</span>)  <span class="comment"># &#x27;L&#x27; 表示灰度模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line">image.show()</span><br></pre></td></tr></table></figure>
<h2 id="十.-unit8函数">十. unit8函数</h2>
<p>在图像处理中，图像的像素值通常以 <code>uint8</code> 类型存储（0
表示黑色，255 表示白色）。<code>uint8</code> 的取值范围是 0 到 255。</p>
<h3 id="示例-9">示例</h3>
<h4 id="示例1-创建-uint8-数组">示例1 创建 <code>uint8</code> 数组</h4>
<p>可以使用 <code>numpy.array</code> 或 <code>numpy.zeros</code>
等函数创建 <code>uint8</code> 类型的数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 uint8 数组</span></span><br><span class="line">array = np.array([<span class="number">0</span>, <span class="number">127</span>, <span class="number">255</span>], dtype=np.uint8)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="built_in">print</span>(array.dtype)  <span class="comment"># 输出数据类型</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[  0 127 255]</span><br><span class="line">uint8</span><br></pre></td></tr></table></figure>
<ul>
<li>这里 <code>dtype=np.uint8</code> 指定数组的数据类型为
<code>uint8</code>。</li>
</ul>
<h4 id="示例2-创建全零或全一的-uint8-数组">示例2 创建全零或全一的
<code>uint8</code> 数组</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 3x3 的全零 uint8 数组</span></span><br><span class="line">zeros_array = np.zeros((<span class="number">3</span>, <span class="number">3</span>), dtype=np.uint8)</span><br><span class="line"><span class="built_in">print</span>(zeros_array)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 2x2 的全一 uint8 数组</span></span><br><span class="line">ones_array = np.ones((<span class="number">2</span>, <span class="number">2</span>), dtype=np.uint8)</span><br><span class="line"><span class="built_in">print</span>(ones_array)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[0 0 0]</span><br><span class="line"> [0 0 0]</span><br><span class="line"> [0 0 0]]</span><br><span class="line">[[1 1]</span><br><span class="line"> [1 1]]</span><br></pre></td></tr></table></figure>
<h4 id="示例3-创建随机-uint8-数组">示例3 创建随机 <code>uint8</code>
数组</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 2x2 的随机 uint8 数组（值在 0 到 255 之间）</span></span><br><span class="line">random_array = np.random.randint(<span class="number">0</span>, <span class="number">256</span>, size=(<span class="number">2</span>, <span class="number">2</span>), dtype=np.uint8)</span><br><span class="line"><span class="built_in">print</span>(random_array)</span><br></pre></td></tr></table></figure>
<p>输出（示例）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[ 42 173]</span><br><span class="line"> [ 89 211]]</span><br></pre></td></tr></table></figure>
<h3 id="uint8-的特性"><code>uint8</code> 的特性</h3>
<h4 id="取值范围">取值范围</h4>
<ul>
<li><code>uint8</code> 的取值范围是 0 到 255。</li>
<li>如果赋值超出范围，值会“环绕”（即取模 256）： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array = np.array([<span class="number">256</span>, <span class="number">257</span>, <span class="number">258</span>], dtype=np.uint8)</span><br><span class="line"><span class="built_in">print</span>(array)  <span class="comment"># 输出: [0 1 2]</span></span><br></pre></td></tr></table></figure></li>
<li>如果对 <code>uint8</code>
数组进行数学运算（如加法、乘法），结果可能会溢出。如果需要避免溢出，可以先将数组转换为更大的数据类型（如
<code>uint16</code> 或 <code>float</code>），再进行运算。例如：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">200</span>], dtype=np.uint8)</span><br><span class="line">b = np.array([<span class="number">100</span>], dtype=np.uint8)</span><br><span class="line">c = a + b</span><br><span class="line"><span class="built_in">print</span>(c)  <span class="comment"># 输出: [44]（因为 300 % 256 = 44）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="数据类型转换">数据类型转换</h4>
<ul>
<li>可以将其他数据类型的数组转换为 <code>uint8</code>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float_array = np.array([<span class="number">0.1</span>, <span class="number">0.5</span>, <span class="number">1.0</span>])</span><br><span class="line">uint8_array = (float_array * <span class="number">255</span>).astype(np.uint8)</span><br><span class="line"><span class="built_in">print</span>(uint8_array)  <span class="comment"># 输出: [ 25 127 255]</span></span><br></pre></td></tr></table></figure>
<h4 id="与其他数据类型的兼容性">与其他数据类型的兼容性</h4>
<ul>
<li>当 <code>uint8</code>
数组与其他数据类型的数组一起运算时，结果的数据类型可能会提升。例如：</li>
</ul>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>], dtype=np.uint8)</span><br><span class="line">b = np.array([<span class="number">1</span>], dtype=np.float32)</span><br><span class="line">c = a + b</span><br><span class="line"><span class="built_in">print</span>(c.dtype)  <span class="comment"># 输出: float32</span></span><br></pre></td></tr></table></figure></p>
<p>以上内容按照函数和概念分类整理，方便快速查找和学习。</p>
<h1 id="附-mandelbrot程序">附: Mandelbrot程序</h1>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="string">A fast Mandelbrot set wallpaper renderer</span></span><br><span class="line"><span class="string">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">reddit discussion:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;https://www.reddit.com/r/math/comments/2abwyt/smooth_colour_mandelbrot&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> jit <span class="comment"># type: ignore</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">MAXITERS = <span class="number">200</span></span><br><span class="line">RADIUS = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@jit</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">color</span>(<span class="params">z, i</span>):</span><br><span class="line">    v = np.log2(i + <span class="number">1</span> - np.log2(np.log2(<span class="built_in">abs</span>(z)))) / <span class="number">5</span></span><br><span class="line">    <span class="keyword">if</span> v &lt; <span class="number">1.0</span>:</span><br><span class="line">        <span class="keyword">return</span> v**<span class="number">4</span>, v**<span class="number">2.5</span>, v</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        v = <span class="built_in">max</span>(<span class="number">0</span>, <span class="number">2</span> - v)</span><br><span class="line">        <span class="keyword">return</span> v, v**<span class="number">1.5</span>, v**<span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@jit</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">iterate</span>(<span class="params">c</span>):</span><br><span class="line">    z = <span class="number">0j</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(MAXITERS):</span><br><span class="line">        <span class="keyword">if</span> z.real * z.real + z.imag * z.imag &gt; RADIUS:</span><br><span class="line">            <span class="keyword">return</span> color(z, i)</span><br><span class="line">        z = z * z + c</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">xmin, xmax, ymin, ymax, width, height</span>):</span><br><span class="line">    y, x = np.ogrid[ymax : ymin : height * <span class="number">1j</span>, xmin : xmax : width * <span class="number">1j</span>]</span><br><span class="line">    z = x + y * <span class="number">1j</span></span><br><span class="line">    R, G, B = np.asarray(np.frompyfunc(iterate, <span class="number">1</span>, <span class="number">3</span>)(z)).astype(<span class="built_in">float</span>)</span><br><span class="line">    img = np.stack((R, G, B), axis=<span class="number">2</span>)</span><br><span class="line">    Image.fromarray(np.uint8(img * <span class="number">255</span>)).save(<span class="string">&quot;mandelbrot4.png&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main(-<span class="number">2.1</span>, <span class="number">0.8</span>, -<span class="number">1.16</span>, <span class="number">1.16</span>, <span class="number">800</span>, <span class="number">640</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/mandelbrot/mandelbrot4.png" alt="图Koch3-xuehua" style="width: 100%;"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/22/LinearProgramming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/22/LinearProgramming/" class="post-title-link" itemprop="url">线性规划</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-22 09:32:43" itemprop="dateCreated datePublished" datetime="2025-05-22T09:32:43+08:00">2025-05-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-05-23 20:13:01" itemprop="dateModified" datetime="2025-05-23T20:13:01+08:00">2025-05-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="线性规划模型引出">线性规划——模型引出</h1>
<h2
id="在总量有限的条件下如何合理分配以实现最大化最小化或最优化目标">在总量有限的条件下，如何合理分配以实现最大化、最小化或最优化目标？</h2>
<ul>
<li><p><strong>生产优化</strong>：某工厂计划生产两种机床，每种机床的单位利润不同，且在生产过程中会消耗不同数量的资源，如电力、工时和材料。<strong>如何安排生产数量，以使总利润最大？</strong></p></li>
<li><p><strong>资产配置</strong>：总资产为 <span
class="math inline">\(A\)</span>，可投资于 <span
class="math inline">\(n\)</span>
种不同的金融资产。每种资产具有不同的平均收益率、风险损失率和手续费。<strong>如何分配投资比例，才能在控制风险的同时，实现收益最大化？</strong></p></li>
<li><p><strong>物流调度</strong>：某商品从 <span
class="math inline">\(n\)</span> 个产地运输至 <span
class="math inline">\(p\)</span>
个销售地。各产地的产量已知，销售地的需求量也已确定。不同产地到销售地的运输成本不同。<strong>如何安排运输计划，才能在满足供需的前提下，使总运营成本最小？</strong></p></li>
<li><p><strong>车辆调度</strong>：不同类型车辆的承载能力不同。工地之间需安排车辆进行运输作业，多个线路需满足各自的运输需求。<strong>如何调配车辆，使车次安排最合理、资源利用率最高？</strong></p></li>
</ul>
<p>以上列举的是一些常见的<strong>运筹优化问题</strong>，也是数学建模竞赛中经常出现的题型。本质上，它们都是在特定约束条件下，寻求某个目标的极大或极小值，也就是典型的<strong>极值</strong>问题。在这类问题中，线性规划是最常用、也最有效的建模与求解工具之一。</p>
<h2
id="某同学特别喜欢玩一款游戏想找到最快升级到满级的方法">某同学特别喜欢玩一款游戏，想找到最快升级到满级的方法</h2>
<ul>
<li>游戏中每天有 <strong>100 点体力</strong>可用，玩家可以通过反复挑战
<strong>A、B、C 三张地图</strong>来获取经验值升级。</li>
<li>每次通关可获得的经验分别为：A 图 <strong>20 点</strong>、B 图
<strong>30 点</strong>、C 图 <strong>45 点</strong>。</li>
<li>每次通关所需体力分别为：A 图 <strong>4 点</strong>、B 图 <strong>8
点</strong>、C 图 <strong>15 点</strong>。</li>
<li>每天通关的总次数上限为 <strong>20 次</strong>（A、B、C
图加起来不超过 20 次）。</li>
</ul>
<p><strong>问题</strong>：这位同学应该如何分配通关 A、B、C
三张地图的次数，才能在今天<strong>获得最多的经验值</strong>？</p>
<h2 id="线性规划">线性规划</h2>
<ul>
<li><p><strong>线性规划</strong>（Linear Programming，简称
LP）是运筹学中最早研究、发展最快、应用最广泛的方法之一。它是一种数学工具，主要用于研究<strong>在线性约束条件下，如何使线性目标函数达到极值</strong>的问题，常用于辅助人们进行科学决策与管理。</p></li>
<li><p>作为运筹学的重要分支，线性规划在<strong>军事、经济、管理、工程</strong>等领域具有广泛应用。它为在资源有限的情况下，如何做出最优配置与决策，提供了科学依据和有效手段。</p></li>
</ul>
<h1 id="线性规划模型原理">线性规划——模型原理</h1>
<h2 id="线性规划模型的三要素">线性规划模型的三要素</h2>
<ul>
<li><strong>决策变量</strong>:
问题中要确定的未知量，用于表明规划问题中的用数量表示的方案、措施等，可由决策者决定和控制；<br />
</li>
<li><strong>目标函数</strong>:
决策变量的函数，优化目标通常是求该函数的最大值或最小值；<br />
</li>
<li><strong>约束条件</strong>:
决策变量的取值所受到的约束和限制条件，通常用含有决策变量的等式或不等式表示。</li>
</ul>
<h2 id="线性规划模型建立步骤">线性规划模型建立步骤</h2>
<ul>
<li>从实际问题中建立数学模型一般有以下三个步骤：
<ol type="1">
<li>根据影响所要达到目的的因素找到决策变量<br />
</li>
<li>由决策变量和所在达到目的之间的函数关系确定目标函数<br />
</li>
<li>由决策变量所受的限制条件确定决策变量所要满足的约束条件</li>
</ol></li>
</ul>
<h3
id="某同学特别喜欢玩一款游戏想找到最快升级到满级的方法-1">某同学特别喜欢玩一款游戏，想找到最快升级到满级的方法</h3>
<ul>
<li><strong>决策变量</strong>：三个地图通关次数。设A、B、C三个地图通关的次数分别为<span
class="math inline">\(x_1, x_2, x_3\)</span></li>
<li><strong>目标函数</strong>：获得的经验最高。设经验为<span
class="math inline">\(y\)</span>，<span class="math inline">\(\max y =
20x_1 + 30x_2 + 45x_3\)</span></li>
<li><strong>约束条件</strong>：
<ul>
<li>消耗体力不能超过100：<span class="math inline">\(4x_1 + 8x_2 + 15x_3
\leqslant 100\)</span></li>
<li>三个地图最多通关20次：<span class="math inline">\(x_1 + x_2 + x_3
\leqslant 20\)</span></li>
<li>隐藏约束条件：<span class="math inline">\(x_1, x_2, x_3 \geqslant
0\)</span></li>
</ul></li>
</ul>
<h2 id="线性规划的表现形式">线性规划的表现形式</h2>
<ul>
<li><p>一般形式/代数形式<br />
<span class="math display">\[\begin{aligned}
&amp;\max(\text{求}\min)~z=c_1x_1+c_2x_2+\cdots+c_nx_n,\\
&amp;\mathrm{s.t.}\begin{cases}  
a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n\leqslant(\text{或}=,\geqslant)b_1,\\
a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_n\leqslant(\text{或}=,\geqslant)b_2,\\
\vdots\\
a_{m1}x_1+a_{m2}x_2+\cdots+a_{mn}x_n\leqslant(\text{或}=,\geqslant)b_m,\\
x_1,x_2,\cdots,x_n\geqslant 0.
\end{cases}
\end{aligned}\Rightarrow\begin{aligned}
&amp;\max~y=20x_1+30x_2+45x_3,\\
&amp;\mathrm{s.t.}\begin{cases}  
4x_1+8x_2+15x_3\leqslant 100,\\
x_1+x_2+x_3\leqslant 20,\\
x_1, x_2, x_3\geqslant 0.  
\end{cases}
\end{aligned}\]</span></p></li>
<li><p>简写形式： <span class="math display">\[\begin{aligned}
&amp;\max(\text{或}\min)~z=\sum\limits_{j=1}^{n}c_j x_j\\
&amp;\mathrm{s.t.}\begin{cases}   
\sum\limits_{j=1}^{n} a_{ij}x_j\leqslant(\text{或}=,\geqslant)
b_i,&amp;i=1,2,\cdots,m,\\   
x_j\geqslant 0,&amp;j=1,2,\cdots,n.  
\end{cases}
\end{aligned}\]</span></p></li>
<li><p>矩阵表现形式：</p></li>
</ul>
<p><span class="math display">\[\begin{aligned}
&amp;\max(\text{式}\min)~z = c^T x,\\
&amp;\mathrm{s.t.}\begin{cases}   
Ax\leqslant(\text{或}=,\geqslant)b,\\   
x\geqslant0.  
\end{cases}\\
&amp;c=[c_1, c_2, \cdots,
c_n]^T\text{——目标函数的系数向量，即价值向量；}\\
&amp;x=[x_1, x_2, \cdots, x_n]^T\text{——决策向量；}\\
&amp;A=(a_{ij})_{m\times n}\text{——约束方程组的系数矩阵；}\\
&amp;b=[b_1, b_2, \cdots, b_m]^T\text{——约束方程组的常数向量。}
\end{aligned}\Rightarrow\begin{aligned}
&amp;\max~y=c^T x,\\
&amp;\mathrm{s.t.}   
\begin{cases}   
Ax\leqslant b,\\   
x\geqslant0.  
\end{cases}\\
&amp;c=[20, 30, 45]^T\\  
&amp;x=[x_1, x_2, x_3]^T\\  
&amp;A=\begin{bmatrix}  
4&amp;8&amp;15\\  
1&amp;1&amp;1  
\end{bmatrix},\\
&amp;b = [100, 20]^T
\end{aligned}\]</span></p>
<h2 id="线性规划模型特点">线性规划模型特点</h2>
<ul>
<li>要解决的问题是优化类的（即在有限的资源条件下，获取最大的收益）。<br />
</li>
<li>目标函数和约束条件都是决策变量的线性函数，即不存在 <span
class="math inline">\(x^2,e^x,\frac{1}{x},\sin x,\log_2 x\)</span>
等。<br />
</li>
<li>线性规划模型：在一组线性约束条件下，求线性目标函数的最大值或最小值。</li>
</ul>
<p>数学建模的过程，就是把题目“翻译”成数学语言的过程一组公式，加上对这组公式含义的解释，就是一个数学模型。</p>
<h2 id="线型规划模型求解">线型规划模型求解</h2>
<ul>
<li>线性规划求解可采用单纯形法，证明比较复杂，有兴趣可以自行学习。<br />
</li>
<li>推荐采用 matlab、python 的相关函数进行求解。</li>
</ul>
<h1 id="线性规划典型例题">线性规划——典型例题</h1>
<h2 id="例题1998年国赛a题">例题（1998年国赛A题）</h2>
<ul>
<li>市场上有<span
class="math inline">\(n\)</span>种资产（如股票、债券、……）<span
class="math inline">\(s_i\)</span>（<span class="math inline">\(i =
1,2,\cdots,n\)</span>）供投资者选择，某公司有数额为 <span
class="math inline">\(M\)</span>
的一笔相当大的资金可用作一个时期的投资。公司财务分析人员对这 <span
class="math inline">\(n\)</span>
种资产进行了评估，估算出在这一时期内购买资产的平均收益率为 <span
class="math inline">\(r_i\)</span>，并预测出购买 <span
class="math inline">\(s_i\)</span> 的风险损失率为 <span
class="math inline">\(q_i\)</span>。考虑到投资越分散，总的风险越小，公司确定，当用这笔资金购买若干种资产时，总体风险可用所投资的
<span class="math inline">\(s_i\)</span> 中最大的一个风险来度量。<br />
</li>
<li>购买 <span class="math inline">\(s_i\)</span> 要付交易费，费率为
<span class="math inline">\(p_i\)</span>，并且当购买额不超过给定值 <span
class="math inline">\(u_i\)</span> 时，交易费按购买 <span
class="math inline">\(u_i\)</span>
计算（不买当然无须付费）。另外，假定同期银行存款利率是 <span
class="math inline">\(r_0\)</span>（<span
class="math inline">\(r_0=5\%\)</span>），且既无交易费又无风险。<br />
</li>
<li>已知 <span class="math inline">\(n=4\)</span>
时的相关数据如表所示。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center;">$ s_i $</th>
<th style="text-align: center;"><span
class="math inline">\(r_i(\%)\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(q_i(\%)\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(p_i(\%)\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(u_i(\text{元})\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">$ s_1 $</td>
<td style="text-align: center;">28</td>
<td style="text-align: center;">2.5</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">103</td>
</tr>
<tr>
<td style="text-align: center;">$ s_2 $</td>
<td style="text-align: center;">21</td>
<td style="text-align: center;">1.5</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">198</td>
</tr>
<tr>
<td style="text-align: center;">$ s_3 $</td>
<td style="text-align: center;">23</td>
<td style="text-align: center;">5.5</td>
<td style="text-align: center;">4.5</td>
<td style="text-align: center;">52</td>
</tr>
<tr>
<td style="text-align: center;">$ s_4 $</td>
<td style="text-align: center;">25</td>
<td style="text-align: center;">2.6</td>
<td style="text-align: center;">6.5</td>
<td style="text-align: center;">40</td>
</tr>
</tbody>
</table>
<h3 id="投资收益问题">投资收益问题</h3>
<ul>
<li>投资收益问题：给上述公司设计投资组合方案，用给定资金 <span
class="math inline">\(M\)</span>
，有选择地购买若干种资产或存银行生息，使净收益尽可能大，总体风险尽可能小。</li>
</ul>
<h3 id="问题分析">问题分析</h3>
<ul>
<li>决策变量：投资不同项目 <span class="math inline">\(s_i\)</span> 的为
<span class="math inline">\(x_i\)</span> (<span class="math inline">\(i
= 1,2,\cdots,n\)</span>) ；</li>
<li>目标函数：净收益 <span class="math inline">\(Q\)</span>
尽可能大、总风险尽可能小；<br />
</li>
<li>约束条件：总资金 <span class="math inline">\(M\)</span>
有限，每一笔投资都是非负数；<br />
</li>
<li>且已知，目标函数和约束条件都是决策变量的线性函数。</li>
</ul>
<h3 id="模型假设">模型假设</h3>
<ul>
<li>可供投资的资金数额 <span class="math inline">\(M\)</span>
相当大；<br />
</li>
<li>投资越分散，总的风险越小，总体风险可用所投资的 <span
class="math inline">\(s_i\)</span> 中最大的一个风险来度量；</li>
<li>可供选择的 <span class="math inline">\(n+1\)</span>
种资产（含银行存款）之间是相互独立的；</li>
<li>每种资产可购买的数量为任意值；</li>
<li>在当前投资周期内，<span
class="math inline">\(r_i,q_i,p_i,u_i\)</span>（<span
class="math inline">\(i=0,1,\cdots,n\)</span>）固定不变；</li>
<li>不考虑在资产交易过程中产生的其他费用，如股票交易和花税等；</li>
<li>由于投资数额 <span class="math inline">\(M\)</span>
相当大，而题目设定的定额 <span class="math inline">\(u_i\)</span> 相对
<span class="math inline">\(M\)</span> 很小，<span
class="math inline">\(p_i\)</span> 更小，因此假设每一笔交易 <span
class="math inline">\(x_i\)</span> 都大于对应定额 <span
class="math inline">\(u_i\)</span>.</li>
</ul>
<h3 id="模型建立">模型建立</h3>
<ul>
<li>总体风险用所投资的 <span class="math inline">\(s_i\)</span>
中最大的一个风险来衡量，即 <span class="math inline">\(\max\{q_i
x_i|i=1,2,\cdots,n\}\)</span>。<br />
</li>
<li>购买 <span class="math inline">\(s_i\)</span>（<span
class="math inline">\(i=1,2,\cdots,n\)</span>）所付交易费本来是一个分段函数，但假设中已经假设每一笔交易
<span class="math inline">\(x_i\)</span> 都大于对应定额 <span
class="math inline">\(u_i\)</span>，所以交易费 <span
class="math inline">\(=p_i x_i\)</span>。这样购买 <span
class="math inline">\(s_i\)</span> 的净收益可以简化为 <span
class="math inline">\((r_i-p_i)x_i\)</span> 。<br />
</li>
<li><span class="math inline">\(\text{目标函数为}\begin{cases}
\max\sum\limits_{i=0}^n (r_i - p_i)x_i, \\
\min\{\max\limits_{1 \leqslant i \leqslant n} \{q_ix_i\}\}
\end{cases}\text{，约束条件为}\begin{cases}
\sum\limits_{i=0}^n (1 + p_i)x_i = M, \\
x_i \geqslant 0, i = 0,1,\cdots,n.
\end{cases}\)</span><br />
</li>
<li>这是一个多目标规划模型！</li>
</ul>
<h3 id="模型的简化">模型的简化</h3>
<ul>
<li><p>在实际投资中，投资者承受风险的程度不一样，若给定风险一个界限
<span class="math inline">\(a\)</span>，使最大的一个风险 <span
class="math inline">\(\frac{q_ix_i}{M} \leqslant
a\)</span>，可找到相应的投资方案。这样把多目标规划变成一个目标的线性规划。</p></li>
<li><p>这里将目标函数 <span
class="math inline">\(\min\{\max\limits_{1\leqslant i\leqslant
n}\{q_ix_i\}\}\)</span> 转化为约束条件：<span
class="math inline">\(\frac{q_i x_i}{M}\leqslant
a\)</span>（总体风险小于某个常数）</p></li>
</ul>
<p><span class="math inline">\(\begin{aligned}
&amp;\max\sum_{i=0}^n (r_i - p_i)x_i\quad\text{目标函数：总收益最大}\\
&amp;\text{s.t.}\begin{cases}
\frac{q_ix_i}{M}\leqslant
a,i=1,2,\cdots,n,&amp;\text{风险率不超过某定值}\\
\sum_{i=0}^n(1+p_i)x_i=M,&amp;\text{投资所有项目的总金额加起来等于总资产}\\
x_i\geqslant0,i=0,1,\cdots,n.&amp;\text{投资的金额都是非负数}
\end{cases}
\end{aligned}\)</span></p>
<h1 id="线性规划matlab代码求解">线性规划——matlab代码求解</h1>
<h2 id="matlab-linprog函数">Matlab linprog函数</h2>
<p><span class="math display">\[[x, fval]=\text{linprog}(f, A, b, Aeq,
beq, lb, ub)\]</span></p>
<p><span class="math display">\[\begin{aligned}  
&amp;\min_{x}f^T x,\\  
&amp;\text{s.t.} \begin{cases}
A\cdot x\leqslant b,\\  
Aeq\cdot x=beq,\\  
lb\leqslant x\leqslant ub.
\end{cases}
\end{aligned}\]</span></p>
<ul>
<li><span class="math inline">\(f\)</span>
——目标函数的系数向量（必须是求最小值形式下的）<br />
</li>
<li><span class="math inline">\(A, b\)</span>
——不等式约束条件的变量系数矩阵和常数项矩阵（必须是<span
class="math inline">\(\leqslant\)</span>形式）<br />
</li>
<li><span class="math inline">\(Aeq, beq\)</span>
——等式约束条件的系数矩阵和常数项矩阵<br />
</li>
<li><span class="math inline">\(lb, ub\)</span>
——决策变量的最小取值和最大取值<br />
</li>
<li><span class="math inline">\(x\)</span>
是返回的最优解的变量取值，<span class="math inline">\(fval\)</span>
返回目标函数的最优值</li>
</ul>
<p><strong>注意：</strong></p>
<p>要调用 linprog
函数，必须是标准形式，即目标函数是求最小值，约束条件都是小于等于号或等号.
如果不满足标准形式，我们可以用同乘“-”变号来继续求解。</p>
<h2 id="求解某同学游戏升级的问题">求解某同学游戏升级的问题</h2>
<p><span class="math display">\[\begin{aligned}  
&amp;\max~y = 20x_1 + 30x_2 + 45x_3, \\  
&amp;\text{s.t.}\begin{cases}
4x_1 + 8x_2 + 15x_3 \leqslant 100, \\  
x_1 + x_2 + x_3 \leqslant 20, \\  
x_1, x_2, x_3 \geqslant 0.
\end{cases}
\end{aligned}~\Rightarrow~\begin{aligned}  
&amp;\min~-y=-20x_1-30x_2-45x_3,\\
&amp;\text{s.t.}\begin{cases}
4x_1+8x_2+15x_3\leqslant100,\\  
\quad x_1 + x_2 + x_3 \leqslant 20, \\  
x_1, x_2, x_3 \geqslant 0.
\end{cases}
\end{aligned}\]</span><br />
<span class="math display">\[[x, fval]=\text{linprog}(f, A, b, Aeq, beq,
lb, ub)\]</span><br />
<span class="math display">\[\begin{aligned}
&amp;\min~f^T x,\\
&amp;\text{s.t.}\begin{cases}
A\cdot x\leqslant b,\\
Aeq\cdot x=beq,\\
lb\leqslant x\leqslant ub.
\end{cases}~\Rightarrow~
\begin{cases}
f=[-20, -30, -45]^T,\\
A=\begin{bmatrix}4&amp;8&amp;15\\1&amp;1&amp;1\end{bmatrix},\\
b=[100, 20]^T,\\
lb=[0, 0, 0]^T.
\end{cases}~\Rightarrow~
\begin{cases}
[x, fval]=\text{linprog}(f,A,b,[],[],lb)\\
y=-fval.
\end{cases}
\end{aligned}\]</span></p>
<ul>
<li>Matlab代码<br />
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line">f = [<span class="number">-20</span>; <span class="number">-30</span>; <span class="number">-45</span>];  </span><br><span class="line">A = [<span class="number">4</span>, <span class="number">8</span>, <span class="number">15</span>; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];  </span><br><span class="line">b = [<span class="number">100</span>; <span class="number">20</span>];  </span><br><span class="line">lb = <span class="built_in">zeros</span>(<span class="number">3</span>, <span class="number">1</span>);  </span><br><span class="line">[x,fval]=linprog(f,A,b,[],[],lb)  <span class="comment">%没有等号约束 </span></span><br><span class="line">y = -fval<span class="comment">%目标函数为最大化  </span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;A、B、C三图分别通关的次数为：&#x27;</span>)  </span><br><span class="line"><span class="built_in">disp</span>(x)  </span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;最终获得的经验为：&#x27;</span>)  </span><br><span class="line"><span class="built_in">disp</span>(y)  </span><br></pre></td></tr></table></figure></li>
</ul>
<p>A、B、C三图分别通关的次数为：<br />
15.0000<br />
5.0000<br />
0</p>
<p>最终获得的经验为：<br />
450</p>
<p><strong>注意</strong>：这个题目其实是整数线性规划，并不适用这个函数，这里求出整数解是巧合！</p>
<h2 id="求解投资收益问题">求解投资收益问题</h2>
<p><span class="math display">\[\begin{aligned}
&amp;\max\sum\limits_{i=0}^{n}(r_i-p_i)x_i\\  
&amp;\text{s.t.}\begin{cases}  
\frac{q_i x_i}{M}\leqslant a, i = 1,2,\cdots,n, \\  
\sum_{i=0}^{n} (1 + p_i)x_i = M, \\  
x_i \geqslant 0, i = 0,1,\cdots,n.  
\end{cases}
\end{aligned}~\Rightarrow~
\begin{aligned}
&amp;\min\sum\limits_{i=0}^{n}(p_i - r_i)x_i\\
&amp;\text{s.t.}\begin{cases}  
\frac{q_i x_i}{M}\leqslant a, i=1,2,\cdots,n, \\  
\sum\limits_{i=0}^{n}(1 + p_i)x_i=M,\\  
x_i\geqslant0,i=0,1,\cdots,n.  
\end{cases}
\end{aligned}\]</span></p>
<ul>
<li>目标函数同乘“-”号化为标准形式，约束条件满足标准形式，无需处理</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center;"><span
class="math inline">\(s_i\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(r_i(\%)\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(q_i(\%)\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(p_i(\%)\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(u_i\)</span>(元)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span
class="math inline">\(s_1\)</span></td>
<td style="text-align: center;">28</td>
<td style="text-align: center;">2.5</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">103</td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(s_2\)</span></td>
<td style="text-align: center;">21</td>
<td style="text-align: center;">1.5</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">198</td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(s_3\)</span></td>
<td style="text-align: center;">23</td>
<td style="text-align: center;">5.5</td>
<td style="text-align: center;">4.5</td>
<td style="text-align: center;">52</td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(s_4\)</span></td>
<td style="text-align: center;">25</td>
<td style="text-align: center;">2.6</td>
<td style="text-align: center;">6.5</td>
<td style="text-align: center;">40</td>
</tr>
</tbody>
</table>
<p><span class="math display">\[\begin{aligned}
&amp;\min f = [-0.05, -0.27, -0.19, -0.185, -0.185] \cdot [x_0, x_1,
x_2, x_3, x_4]^T\\
&amp;\text{s.t.}\begin{cases}  
x_0 + 1.01x_1 + 1.02x_2 + 1.045x_3 + 1.065x_4 = M, \\  
0.025x_1 \leqslant aM, \\  
0.015x_2 \leqslant aM, \\  
0.055x_3 \leqslant aM, \\  
0.026x_4 \leqslant aM, \\  
x_i \geqslant 0 (i = 0,1,\cdots, 4).  
\end{cases}
\end{aligned}\]</span></p>
<ul>
<li>这里不妨取 <span class="math inline">\(M=1\)</span> 万元<br />
</li>
<li>由于 <span class="math inline">\(a\)</span>
是任意给定的风险度，到底怎样没有一个准则，不同的投资者有不同的风险度。我们从
<span class="math inline">\(a=0\)</span> 开始，以步长 <span
class="math inline">\(\Delta a=0.001\)</span> 进行循环搜索，搜索至 <span
class="math inline">\(a=5\%\)</span>（低风险者能够接受的风险）</li>
<li>下面是代码详解<br />
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line"><span class="comment">% a矩阵的元素是不同风险率，从0到0.05等差取值，相邻两个数相差0.001  </span></span><br><span class="line">a = (<span class="number">0</span>:<span class="number">0.001</span>:<span class="number">0.05</span>);  </span><br><span class="line">f = [<span class="number">-0.05</span>,<span class="number">-0.27</span>,<span class="number">-0.19</span>,<span class="number">-0.185</span>,<span class="number">-0.185</span>]; <span class="comment">% 目标函数的系数向量  </span></span><br><span class="line"><span class="comment">% 用zeros(4,1)先构造4行一列的全是0的矩阵，也就是对x_0无约束；  </span></span><br><span class="line"><span class="comment">% 再构造对角矩阵diag([0.025, 0.015, 0.055, 0.026]), 对角线上元素为约束条件中变量的系数  </span></span><br><span class="line">A = [<span class="built_in">zeros</span>(<span class="number">4</span>,<span class="number">1</span>), <span class="built_in">diag</span>([<span class="number">0.025</span>, <span class="number">0.015</span>, <span class="number">0.055</span>, <span class="number">0.026</span>])];  </span><br><span class="line">Aeq = [<span class="number">1</span>,<span class="number">1.01</span>,<span class="number">1.02</span>,<span class="number">1.045</span>,<span class="number">1.065</span>]; <span class="comment">% 等式约束的系数矩阵，也就是所有资产投资  </span></span><br><span class="line">beq = <span class="number">1</span>;  </span><br><span class="line">lb = <span class="built_in">zeros</span>(<span class="number">5</span>,<span class="number">1</span>);  </span><br><span class="line">Q = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(a)); <span class="comment">% 初始化保存最优解的矩阵0，因为现在还没求出最优解，元素全设为0  </span></span><br><span class="line">XX = []; <span class="comment">% 定义个空矩阵，用来表示不同风险率下的最优解  </span></span><br><span class="line"><span class="comment">% 利用矩阵0存储风险率a(i)下最大的收益；for循环中i在变化，风险率a(i)不同，求出对应的最优解存在矩阵0内  </span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(a) <span class="comment">% length求出矩阵a的元素个数，有多少个元素，就循环多少次</span></span><br><span class="line">    b = a(<span class="built_in">i</span>)*<span class="built_in">ones</span>(<span class="number">4</span>,<span class="number">1</span>); <span class="comment">% b是约束条件的常数项矩阵,4行1列，每个元素值都是常数a(i) </span></span><br><span class="line">    [x,y] = linprog(f,A,b,Aeq,beq,lb); <span class="comment">% 调用linprog函数</span></span><br><span class="line">    Q(<span class="built_in">i</span>) = -y; <span class="comment">% 负负得正，就是所需求的最大值了</span></span><br><span class="line">    XX = [XX,x&#x27;]</span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="built_in">plot</span>(a,Q,<span class="string">&#x27;*r&#x27;</span>); <span class="comment">% 以风险率为横轴，收益为纵轴，绘制不同风险率下的最优收益  </span></span><br><span class="line">xlabel(<span class="string">&#x27;风险率&#x27;</span>); <span class="comment">% x和y轴分别附上标签  </span></span><br><span class="line">ylabel(<span class="string">&#x27;最大收益&#x27;</span>);  </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="结果分析">结果分析</h2>
<ul>
<li><p>风险 <span class="math inline">\(a\)</span> 与收益 <span
class="math inline">\(Q\)</span> 之间的关系见图。从图中可以看出：</p>
<p>1）风险不超过 2.5% 时，风险大，收益也大。</p>
<p>2）在 <span class="math inline">\(a = 0.006\)</span>
附近有一个转折点，在这一点左边，风险增加很小时，利润增长很快。在这一点右边，风险增加很大时，利润增长很缓慢，所以对于风险和收益没有特殊偏好的投资者来说，应该选择由线的转折点作为最优投资组合，大约是
<span class="math inline">\(a=0.6\%\)</span>，<span
class="math inline">\(Q = 2000\)</span>，所对应投资方案为：</p>
<p>风险度 <span class="math inline">\(a = 0.006\)</span>，收益 <span
class="math inline">\(Q=2019\)</span> 元；<span
class="math inline">\(x_0=0\)</span> 元，<span
class="math inline">\(x_1=2400\)</span> 元，<span
class="math inline">\(x_2 = 4000\)</span> 元，<span
class="math inline">\(x_3 = 1091\)</span> 元，<span
class="math inline">\(x_4=2212\)</span> 元。</p></li>
<li><p>本题中做了很多模型假设，理论上来说不做也可以求解，且考虑更全面，但数据比赛时间很紧张，合理的假设也很重要。<br />
</p></li>
<li><p>除了固定风险来简化模型，也可以固定收益，或者赋予风险收益相应的权重，来权衡二者的取舍。</p></li>
</ul>
<h1 id="线性规划python代码求解">线性规划——python代码求解</h1>
<h2 id="python-linprog函数">python linprog函数</h2>
<p><span class="math display">\[\begin{aligned}  
&amp;\min_{x}c^T x,\\  
&amp;\text{s.t.} \begin{cases}
A_{ub}\cdot x\leqslant b_{ub},\\  
A_{eq}\cdot x=b_{eq},\\  
x\in bounds.
\end{cases}
\end{aligned}\]</span></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scipy.optimize.linprog(</span><br><span class="line">    c, </span><br><span class="line">    A_ub=<span class="literal">None</span>, </span><br><span class="line">    b_ub=<span class="literal">None</span>, </span><br><span class="line">    A_eq=<span class="literal">None</span>, </span><br><span class="line">    b_eq=<span class="literal">None</span>, </span><br><span class="line">    bounds=<span class="literal">None</span>, </span><br><span class="line">    method=<span class="string">&#x27;highs&#x27;</span>, </span><br><span class="line">    options=<span class="literal">None</span>, </span><br><span class="line">    x0=<span class="literal">None</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="参数详解"><strong>参数详解</strong></h3>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 23%" />
<col style="width: 23%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>c</code></strong></td>
<td>一维数组</td>
<td>目标函数的系数向量（需最小化 ( c^T x )）</td>
<td>必填</td>
</tr>
<tr>
<td><strong><code>A_ub</code></strong></td>
<td>二维数组</td>
<td>不等式约束矩阵（( A_{ub} x b_{ub} )）</td>
<td><code>None</code></td>
</tr>
<tr>
<td><strong><code>b_ub</code></strong></td>
<td>一维数组</td>
<td>不等式约束右侧值（( b_{ub} )）</td>
<td><code>None</code></td>
</tr>
<tr>
<td><strong><code>A_eq</code></strong></td>
<td>二维数组</td>
<td>等式约束矩阵（( A_{eq} x = b_{eq} )）</td>
<td><code>None</code></td>
</tr>
<tr>
<td><strong><code>b_eq</code></strong></td>
<td>一维数组</td>
<td>等式约束右侧值（( b_{eq} )）</td>
<td><code>None</code></td>
</tr>
<tr>
<td><strong><code>bounds</code></strong></td>
<td>元组列表</td>
<td>变量边界（<code>(min, max)</code>，<code>None</code>表示无限制）</td>
<td><code>(0, None)</code>（非负）</td>
</tr>
<tr>
<td><strong><code>method</code></strong></td>
<td>字符串</td>
<td>求解算法：<br>- <code>'highs'</code>（推荐）<br>-
<code>'interior-point'</code><br>- <code>'revised simplex'</code></td>
<td><code>'highs'</code></td>
</tr>
<tr>
<td><strong><code>options</code></strong></td>
<td>字典</td>
<td>求解器选项（如 <code>maxiter</code>, <code>tol</code> 等）</td>
<td><code>None</code></td>
</tr>
<tr>
<td><strong><code>x0</code></strong></td>
<td>一维数组</td>
<td>初始猜测解（仅部分方法支持）</td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
<hr />
<h3 id="返回值"><strong>返回值</strong></h3>
<p>返回一个 <code>OptimizeResult</code> 对象，包含以下关键属性： -
<strong><code>x</code></strong>：最优解向量（若存在）。 -
<strong><code>fun</code></strong>：目标函数的最小值。 -
<strong><code>success</code></strong>：布尔值，表示是否求解成功。 -
<strong><code>status</code></strong>：状态码（<code>0</code>
表示成功，其他值为错误类型）。 -
<strong><code>message</code></strong>：求解状态的描述信息。 -
<strong><code>slack</code></strong>：不等式约束的松弛变量（正值表示约束未激活）。
-
<strong><code>con</code></strong>：等式约束的残差（接近0表示满足约束）。</p>
<p><span class="math display">\[\begin{aligned}  
&amp;\min_{x}c^T x,\\  
&amp;\text{s.t.} \begin{cases}
A\cdot x\leqslant b,\\  
Aeq\cdot x=beq,\\  
lb\leqslant x\leqslant ub.
\end{cases}
\end{aligned}\]</span></p>
<p><strong>注意：</strong></p>
<p>要调用 linprog
函数，必须是标准形式，即目标函数是求最小值，约束条件都是小于等于号或等号.
如果不满足标准形式，我们可以用同乘“-”变号来继续求解。</p>
<h2 id="求解某同学游戏升级的问题-1">求解某同学游戏升级的问题</h2>
<p><span class="math display">\[\begin{aligned}  
&amp;\max~y = 20x_1 + 30x_2 + 45x_3, \\  
&amp;\text{s.t.}\begin{cases}
4x_1 + 8x_2 + 15x_3 \leqslant 100, \\  
x_1 + x_2 + x_3 \leqslant 20, \\  
x_1, x_2, x_3 \geqslant 0.
\end{cases}
\end{aligned}~\Rightarrow~\begin{aligned}  
&amp;\min~-y=-20x_1-30x_2-45x_3,\\
&amp;\text{s.t.}\begin{cases}
4x_1+8x_2+15x_3\leqslant100,\\  
\quad x_1 + x_2 + x_3 \leqslant 20, \\  
x_1, x_2, x_3 \geqslant 0.
\end{cases}
\end{aligned}\]</span><br />
result = linprog (c, A_ub, b_ub, A_eq, b_eq, bounds, method) <span
class="math display">\[\begin{aligned}
&amp;\min~c^T x,\\
&amp;\text{s.t.}\begin{cases}
A_{ub}\cdot x\leqslant b_{ub},\\
A_{eq}\cdot x=b_{eq},\\
x\in bounds.
\end{cases}~\Rightarrow~
\begin{cases}
c=[-20, -30, -45]^T,\\
A_{ub}=\begin{bmatrix}4&amp;8&amp;15\\1&amp;1&amp;1\end{bmatrix},\\
b_{ub}=[100, 20]^T,\\
x_1,x_2,x_3\in[0, +\infty）.
\end{cases}
\end{aligned}\]</span></p>
<ul>
<li>Python代码<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog</span><br><span class="line">c = [-<span class="number">20</span>,-<span class="number">30</span>,-<span class="number">45</span>]</span><br><span class="line">A_ub = [[<span class="number">4</span>, <span class="number">8</span>, <span class="number">15</span>],</span><br><span class="line">        [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">b_ub = [<span class="number">100</span>,<span class="number">20</span>]</span><br><span class="line">bounds = [[<span class="number">0</span>,<span class="literal">None</span>],[<span class="number">0</span>,<span class="literal">None</span>],[<span class="number">0</span>,<span class="literal">None</span>]]</span><br><span class="line">result=linprog(c,A_ub,b_ub,bounds=bounds)  <span class="comment">#没有等号约束</span></span><br><span class="line"><span class="comment">#或写成result = linprog(c,A_ub=A_ub,b_ub=b_ub,bounds=bounds,method=&#x27;highs&#x27;)</span></span><br><span class="line">y = -result.fun  <span class="comment">#目标函数为最大化</span></span><br><span class="line"><span class="built_in">print</span>(result)    <span class="comment">#此行可以不要</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;A、B、C三图分别通关的次数为：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result.x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最终获得的经验为：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>A、B、C三图分别通关的次数为：<br />
15.0000<br />
5.0000<br />
0</p>
<p>最终获得的经验为：<br />
450</p>
<p><strong>注意</strong>：这个题目其实是整数线性规划，并不适用这个函数，这里求出整数解是巧合！</p>
<h2 id="求解投资收益问题-1">求解投资收益问题</h2>
<p><span class="math display">\[\begin{aligned}
&amp;\max\sum\limits_{i=0}^{n}(r_i-p_i)x_i\\  
&amp;\text{s.t.}\begin{cases}  
\frac{q_i x_i}{M}\leqslant a, i = 1,2,\cdots,n, \\  
\sum_{i=0}^{n} (1 + p_i)x_i = M, \\  
x_i \geqslant 0, i = 0,1,\cdots,n.  
\end{cases}
\end{aligned}~\Rightarrow~
\begin{aligned}
&amp;\min\sum\limits_{i=0}^{n}(p_i - r_i)x_i\\
&amp;\text{s.t.}\begin{cases}  
\frac{q_i x_i}{M}\leqslant a, i=1,2,\cdots,n, \\  
\sum\limits_{i=0}^{n}(1 + p_i)x_i=M,\\  
x_i\geqslant0,i=0,1,\cdots,n.  
\end{cases}
\end{aligned}\]</span></p>
<ul>
<li>目标函数同乘“-”号化为标准形式，约束条件满足标准形式，无需处理</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center;"><span
class="math inline">\(s_i\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(r_i(\%)\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(q_i(\%)\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(p_i(\%)\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(u_i\)</span>(元)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span
class="math inline">\(s_1\)</span></td>
<td style="text-align: center;">28</td>
<td style="text-align: center;">2.5</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">103</td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(s_2\)</span></td>
<td style="text-align: center;">21</td>
<td style="text-align: center;">1.5</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">198</td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(s_3\)</span></td>
<td style="text-align: center;">23</td>
<td style="text-align: center;">5.5</td>
<td style="text-align: center;">4.5</td>
<td style="text-align: center;">52</td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(s_4\)</span></td>
<td style="text-align: center;">25</td>
<td style="text-align: center;">2.6</td>
<td style="text-align: center;">6.5</td>
<td style="text-align: center;">40</td>
</tr>
</tbody>
</table>
<p><span class="math display">\[\begin{aligned}
&amp;\min f = [-0.05, -0.27, -0.19, -0.185, -0.185] \cdot [x_0, x_1,
x_2, x_3, x_4]^T\\
&amp;\text{s.t.}\begin{cases}  
x_0 + 1.01x_1 + 1.02x_2 + 1.045x_3 + 1.065x_4 = M, \\  
0.025x_1 \leqslant aM, \\  
0.015x_2 \leqslant aM, \\  
0.055x_3 \leqslant aM, \\  
0.026x_4 \leqslant aM, \\  
x_i \geqslant 0 (i = 0,1,\cdots, 4).  
\end{cases}
\end{aligned}\]</span></p>
<ul>
<li>这里不妨取 <span class="math inline">\(M=1\)</span> 万元<br />
</li>
<li>由于 <span class="math inline">\(a\)</span>
是任意给定的风险度，到底怎样没有一个准则，不同的投资者有不同的风险度。我们从
<span class="math inline">\(a=0\)</span> 开始，以步长 <span
class="math inline">\(\Delta a=0.001\)</span> 进行循环搜索，搜索至 <span
class="math inline">\(a=5\%\)</span>（低风险者能够接受的风险）</li>
<li>下面是python代码详解<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 导入必要的库</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt <span class="comment"># 用于绘图</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> ones, diag, c_, zeros <span class="comment"># 用于创建和操作数组</span></span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog <span class="comment"># 用于执行线性规划</span></span><br><span class="line"><span class="comment"># 设置matplotlib的参数使其支持LaTeX文本和字体大小</span></span><br><span class="line">plt.rc(<span class="string">&#x27;text&#x27;</span>, usetex=<span class="literal">True</span>)</span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>, size=<span class="number">16</span>)</span><br><span class="line"><span class="comment"># 线性规划问题的目标函数系数</span></span><br><span class="line">c = [-<span class="number">0.05</span>, -<span class="number">0.27</span>, -<span class="number">0.19</span>, -<span class="number">0.185</span>, -<span class="number">0.185</span>]</span><br><span class="line"><span class="comment"># 线性不等式约束的系数矩阵（A * x &lt;= b）</span></span><br><span class="line"><span class="comment"># 使用c_来合并数组，zeros创建一个全0的数组作为第一列，</span></span><br><span class="line"><span class="comment"># diag创建一个对角阵</span></span><br><span class="line">A = c_[zeros(<span class="number">4</span>), diag([<span class="number">0.025</span>, <span class="number">0.015</span>, <span class="number">0.055</span>, <span class="number">0.026</span>])]</span><br><span class="line"><span class="comment"># 线性等式约束的系数矩阵和右侧的值（Acq * x = bcq）</span></span><br><span class="line">Aeq = [[<span class="number">1</span>, <span class="number">1.01</span>, <span class="number">1.02</span>, <span class="number">1.045</span>, <span class="number">1.065</span>]]</span><br><span class="line">beq = [<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 初始化参数a，以及两个用于存储结果的空列表</span></span><br><span class="line">a = <span class="number">0</span></span><br><span class="line">aa = []</span><br><span class="line">ss = []</span><br><span class="line"><span class="comment"># 循环，a的值从0开始，以0.001的步长增加，直到0.05</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> a &lt; <span class="number">0.05</span>:</span><br><span class="line">    <span class="comment"># 创建线性不等式约束的右侧值（b）</span></span><br><span class="line">    b = ones(<span class="number">4</span>) * a</span><br><span class="line">    <span class="comment"># 执行线性规划，得到最优解</span></span><br><span class="line">    res = linprog(c, A, b, Aeq, beq,bounds=[(<span class="number">0</span>, <span class="literal">None</span>), (<span class="number">0</span>, <span class="literal">None</span>), (<span class="number">0</span>, <span class="literal">None</span>), (<span class="number">0</span>, <span class="literal">None</span>), (<span class="number">0</span>, <span class="literal">None</span>)])</span><br><span class="line">    <span class="comment"># 提取线性规划的解向量x和最优值Q</span></span><br><span class="line">    x = res.x</span><br><span class="line">    Q = -res.fun</span><br><span class="line">    <span class="comment"># 将当前的a值和对应的最优值Q存入列表</span></span><br><span class="line">    aa.append(a)</span><br><span class="line">    ss.append(Q)</span><br><span class="line">    <span class="comment"># a增加0.001</span></span><br><span class="line">    a = a + <span class="number">0.001</span></span><br><span class="line"><span class="comment"># 绘制结果，a值与最优值Q之间的关系图</span></span><br><span class="line">plt.plot(aa, ss, <span class="string">&#x27;r*&#x27;</span>) <span class="comment"># 使用红色星号标记数据点</span></span><br><span class="line"><span class="comment"># 设置坐标轴标签，其中a和Q将使用LaTeX格式显示</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;$a$&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;$Q$&#x27;</span>, rotation=<span class="number">90</span>)</span><br><span class="line"><span class="comment"># 保存绘制的图像到文件中，分辨率为500dpi</span></span><br><span class="line">plt.savefig(<span class="string">&#x27;figure-LP2.png&#x27;</span>, dpi=<span class="number">500</span>)</span><br><span class="line"><span class="comment"># 显示图形</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/14/Maze/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/14/Maze/" class="post-title-link" itemprop="url">迷宫程序及其中用到的函数逐一解析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-14 11:05:36" itemprop="dateCreated datePublished" datetime="2025-05-14T11:05:36+08:00">2025-05-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-05-23 19:13:34" itemprop="dateModified" datetime="2025-05-23T19:13:34+08:00">2025-05-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="bfs函数逐行详细解释">BFS函数逐行详细解释</h1>
<p>这个函数实现了广度优先搜索(BFS)算法来寻找从起点到终点的路径。下面是逐行解释：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">BFS</span>(<span class="params">start, end, pixels</span>):</span><br></pre></td></tr></table></figure>
<ul>
<li>定义BFS函数，接收三个参数：
<ul>
<li><code>start</code>: 起点坐标 (x, y)</li>
<li><code>end</code>: 终点坐标 (x, y)</li>
<li><code>pixels</code>: 图像的像素数据，用于判断每个位置是否可通行</li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">came_from = &#123;start: start&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化<code>came_from</code>字典，用于记录每个位置是从哪个位置访问来的</li>
<li>初始时，起点的前驱位置是它自己（这是回溯路径时的终止条件）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue = deque([start])</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化双端队列，并将起点加入队列</li>
<li>BFS使用队列来管理待探索的位置（先进先出）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visited = <span class="built_in">set</span>([start])</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化已访问集合，记录已经探索过的位置</li>
<li>初始时将起点标记为已访问，避免重复处理</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br></pre></td></tr></table></figure>
<ul>
<li>开始BFS主循环，当队列不为空时继续搜索</li>
<li>队列为空表示已经探索完所有可达位置</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cell = queue.popleft()</span><br></pre></td></tr></table></figure>
<ul>
<li>从队列左侧取出一个位置（先进先出）</li>
<li>这是BFS的核心特性：先探索距离起点更近的位置</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> adjacent <span class="keyword">in</span> getadjacent(cell):</span><br></pre></td></tr></table></figure>
<ul>
<li>遍历当前单元格的四个相邻位置（上、下、左、右）</li>
<li><code>getadjacent(cell)</code>返回这些相邻位置的坐标</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x, y = adjacent</span><br></pre></td></tr></table></figure>
<ul>
<li>解包相邻位置的坐标为x和y变量</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> adjacent <span class="keyword">not</span> <span class="keyword">in</span> visited <span class="keyword">and</span> iswhite(pixels[x, y]):</span><br></pre></td></tr></table></figure>
<ul>
<li>检查两个条件：
<ul>
<li>相邻位置未被访问过（不在visited集合中）</li>
<li>相邻位置的像素是白色（可通行，由<code>iswhite</code>函数判断）</li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">came_from[adjacent] = cell</span><br></pre></td></tr></table></figure>
<ul>
<li>如果满足条件，记录这个相邻位置是从当前单元格访问来的</li>
<li>这是为了之后能回溯出完整路径</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue.append(adjacent)</span><br></pre></td></tr></table></figure>
<ul>
<li>将这个相邻位置加入队列，等待后续探索</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visited.add(adjacent)</span><br></pre></td></tr></table></figure>
<ul>
<li>将这个相邻位置标记为已访问</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path = [end]</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化路径列表，从终点开始回溯</li>
<li>此时BFS已经完成，开始构建从终点到起点的路径</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v = end</span><br></pre></td></tr></table></figure>
<ul>
<li>设置当前回溯位置v为终点</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> v != start:</span><br></pre></td></tr></table></figure>
<ul>
<li>开始回溯循环，直到回溯到起点为止</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v = came_from[v]</span><br></pre></td></tr></table></figure>
<ul>
<li>将v设置为它的前驱位置（即从哪个位置来到v的）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.append(v)</span><br></pre></td></tr></table></figure>
<ul>
<li>将前驱位置加入路径列表</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> path</span><br></pre></td></tr></table></figure>
<ul>
<li>返回找到的路径（注意这个路径是从终点到起点的顺序）</li>
</ul>
<h2 id="关键点说明">关键点说明</h2>
<ol type="1">
<li><p><strong>BFS特性</strong>：这个算法会先探索距离起点最近的所有位置，然后逐步向外扩展，因此找到的路径一定是最短路径之一。</p></li>
<li><p><strong>路径回溯</strong>：使用<code>came_from</code>字典记录每个位置的来源，使得我们能在找到终点后反向追溯出完整路径。</p></li>
<li><p><strong>访问控制</strong>：<code>visited</code>集合确保每个位置只被处理一次，防止无限循环。</p></li>
<li><p><strong>可通行判断</strong>：<code>iswhite(pixels[x, y])</code>确保只走白色像素（迷宫中的通路）。</p></li>
<li><p><strong>路径顺序</strong>：最终返回的路径是从终点到起点的顺序，如果需要起点到终点的顺序，可以反转这个列表。</p></li>
</ol>
<h1 id="came_from">came_from</h1>
<p><code>came_from = &#123;start: start&#125;</code> 是 Python 中的
<strong>字典（Dictionary）</strong> 初始化语法，表示创建一个字典并将键
<code>start</code> 映射到值 <code>start</code>。</p>
<h2 id="详细解释">详细解释：</h2>
<ul>
<li><strong>字典（Dictionary）</strong> 是 Python
的一种数据结构，用于存储 <strong>键-值对（Key-Value
Pairs）</strong>，格式为
<code>&#123;key1: value1, key2: value2, ...&#125;</code>。</li>
<li>在 <code>came_from = &#123;start: start&#125;</code> 中：
<ul>
<li><strong>第一个 <code>start</code></strong> 是
<strong>键（Key）</strong>，表示某个位置的坐标（如
<code>(400, 984)</code>）。</li>
<li><strong>第二个 <code>start</code></strong> 是
<strong>值（Value）</strong>，表示该位置是从哪个位置访问来的。</li>
<li>这里初始化时，<code>start</code>
的前驱（来源）是它自己，表示它是路径的起点。</li>
</ul></li>
</ul>
<h2 id="为什么这样初始化">为什么这样初始化？</h2>
<ul>
<li><code>came_from</code> 的作用是
<strong>记录每个位置是从哪个位置访问来的</strong>，用于后续回溯路径。</li>
<li>初始时，<code>start</code>
是路径的起点，没有前驱位置，所以它的前驱设为它自己（作为终止条件）。</li>
<li>例如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start = (<span class="number">400</span>, <span class="number">984</span>)</span><br><span class="line">came_from = &#123;start: start&#125;  <span class="comment"># &#123;(400, 984): (400, 984)&#125;</span></span><br></pre></td></tr></table></figure>
<p>表示 <code>(400, 984)</code> 是从 <code>(400, 984)</code>
来的（即它是起点）。</p>
<h2 id="类似用法">类似用法：</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化时，每个位置的前驱设为 None（另一种常见写法）</span></span><br><span class="line">came_from = &#123;start: <span class="literal">None</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回溯路径时，判断是否到达起点：</span></span><br><span class="line"><span class="keyword">while</span> v <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 而不是 while v != start:</span></span><br><span class="line">    v = came_from[v]</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结：</h2>
<ul>
<li><code>&#123;start: start&#125;</code> 是字典初始化，表示
<strong><code>start</code> 的前驱是
<code>start</code></strong>（即它是起点）。</li>
<li>在 BFS 中，这样初始化是为了 <strong>方便回溯路径</strong>，当
<code>v == came_from[v]</code> 时，说明回溯到了起点，终止循环。</li>
</ul>
<h1 id="python-中-deque-的用法详解">Python 中 <code>deque</code>
的用法详解</h1>
<p><code>deque</code>（双端队列，发音为"deck"）是 Python 标准库
<code>collections</code>
模块中的一个高效数据结构，特别适合用作队列（FIFO：First in, First
out）或栈（LIFO：Last in, First out）。在 BFS 算法中，<code>deque</code>
是最常用的队列实现方式。</p>
<h2 id="基本用法">基本用法</h2>
<h3 id="导入-deque">导入 deque</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br></pre></td></tr></table></figure>
<h3 id="创建-deque">创建 deque</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = deque()  <span class="comment"># 创建空双端队列</span></span><br><span class="line">d = deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment"># 从可迭代对象创建</span></span><br></pre></td></tr></table></figure>
<h2 id="核心操作方法">核心操作方法</h2>
<h3 id="作为队列使用fifo">作为队列使用（FIFO）</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 入队（添加到右端）</span></span><br><span class="line">d.append(<span class="number">4</span>)  <span class="comment"># deque([1, 2, 3, 4])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 出队（从左端移除）</span></span><br><span class="line">item = d.popleft()  <span class="comment"># 返回1，deque变为([2, 3, 4])</span></span><br></pre></td></tr></table></figure>
<h3 id="作为栈使用lifo">作为栈使用（LIFO）</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压栈（添加到右端）</span></span><br><span class="line">d.append(<span class="number">5</span>)  <span class="comment"># deque([2, 3, 4, 5])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 弹栈（从右端移除）</span></span><br><span class="line">item = d.pop()  <span class="comment"># 返回5，deque变为([2, 3, 4])</span></span><br></pre></td></tr></table></figure>
<h3 id="双端操作">双端操作</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从左端添加</span></span><br><span class="line">d.appendleft(<span class="number">0</span>)  <span class="comment"># deque([0, 2, 3, 4])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从右端移除</span></span><br><span class="line">item = d.pop()  <span class="comment"># 返回4，deque变为([0, 2, 3])</span></span><br></pre></td></tr></table></figure>
<h2 id="为什么在-bfs-中使用-deque">为什么在 BFS 中使用 deque？</h2>
<h3 id="高效性">高效性</h3>
<ul>
<li><p><code>popleft()</code> 和 <code>append()</code> 操作都是 O(1)
时间复杂度</p></li>
<li><p>相比列表的 <code>pop(0)</code> 是 O(n) 操作，<code>deque</code>
更适合队列操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>list</th>
<th>deque</th>
</tr>
</thead>
<tbody>
<tr>
<td>append</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>appendleft</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>pop</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>popleft</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table></li>
</ul>
<h3 id="线程安全">线程安全</h3>
<ul>
<li><code>deque</code> 的 <code>append()</code> 和
<code>popleft()</code> 是原子操作</li>
</ul>
<h3 id="灵活性">灵活性</h3>
<ul>
<li>可以方便地在两端进行操作</li>
</ul>
<h1 id="python-中-len-函数的用法详解">Python 中 <code>len()</code>
函数的用法详解</h1>
<p><code>len()</code> 是 Python
内置函数，用于返回对象的长度（元素个数）。它是 Python
中最基础和常用的函数之一。</p>
<h2 id="基本语法">基本语法</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(<span class="built_in">object</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>参数
<code>object</code>：可以是序列（如字符串、列表、元组等）或集合（如字典、集合等）</li>
<li>返回值：对象的长度（整数）</li>
</ul>
<h2 id="支持的数据类型">支持的数据类型</h2>
<h3 id="字符串string">字符串（String）</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s))  <span class="comment"># 输出：5（字符数）</span></span><br></pre></td></tr></table></figure>
<h3 id="列表list">列表（List）</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(lst))  <span class="comment"># 输出：4（元素个数）</span></span><br></pre></td></tr></table></figure>
<h3 id="元组tuple">元组（Tuple）</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(t))  <span class="comment"># 输出：3</span></span><br></pre></td></tr></table></figure>
<h3 id="字典dictionary">字典（Dictionary）</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(d))  <span class="comment"># 输出：2（键值对数量）</span></span><br></pre></td></tr></table></figure>
<h3 id="集合set">集合（Set）</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s))  <span class="comment"># 输出：4</span></span><br></pre></td></tr></table></figure>
<h3 id="其他可迭代对象">其他可迭代对象</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">d = deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(d))  <span class="comment"># 输出：3</span></span><br></pre></td></tr></table></figure>
<h2 id="注意事项">注意事项</h2>
<h3 id="不支持没有长度的对象">不支持没有长度的对象</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(<span class="number">42</span>)  <span class="comment"># TypeError: object of type &#x27;int&#x27; has no len()</span></span><br></pre></td></tr></table></figure>
<h3 id="计算的是顶层元素">计算的是顶层元素</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lst = [[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(lst))  <span class="comment"># 输出2（不是4）</span></span><br></pre></td></tr></table></figure>
<h1 id="python-中-set-的用法详解">Python 中 <code>set()</code>
的用法详解</h1>
<p><code>set()</code> 是 Python 的内置函数，用于创建
<strong>集合(set)</strong>
数据结构。集合是一种无序、不重复元素的容器，非常适合用于成员关系测试和去重操作。</p>
<h2 id="基本用法-1">基本用法</h2>
<h3 id="创建集合">创建集合</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建空集合（必须使用set()，不能用&#123;&#125;）</span></span><br><span class="line">empty_set = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建带初始元素的集合</span></span><br><span class="line">fruits = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>&#125; <span class="comment"># 使用花括号</span></span><br><span class="line">numbers = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])            <span class="comment"># 从列表转换</span></span><br><span class="line">chars = <span class="built_in">set</span>(<span class="string">&quot;hello&quot;</span>)                   <span class="comment"># 从字符串创建，结果为 &#123;&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;o&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="集合特性">集合特性</h3>
<ul>
<li><strong>无序</strong>：元素没有固定顺序</li>
<li><strong>唯一</strong>：自动去除重复元素</li>
<li><strong>可变</strong>：可以增删元素</li>
<li><strong>可哈希（Hashable）</strong>：元素必须是不可变类型（数字、字符串、元组等）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>&#125;  <span class="comment"># 自动去重，结果为 &#123;1, 2, 3&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="常用操作">常用操作</h2>
<h3 id="添加元素">添加元素</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">s.add(<span class="number">3</span>)       <span class="comment"># 添加单个元素 → &#123;1, 2, 3&#125;</span></span><br><span class="line">s.update([<span class="number">4</span>, <span class="number">5</span>])  <span class="comment"># 添加多个元素 → &#123;1, 2, 3, 4, 5&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="删除元素">删除元素</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">s.remove(<span class="number">3</span>)    <span class="comment"># 移除元素，不存在则报错 → &#123;1, 2, 4&#125;</span></span><br><span class="line">s.discard(<span class="number">2</span>)   <span class="comment"># 移除元素，不存在不报错 → &#123;1, 4&#125;</span></span><br><span class="line">s.pop()        <span class="comment"># 随机移除并返回一个元素</span></span><br><span class="line">s.clear()      <span class="comment"># 清空集合 → set()</span></span><br></pre></td></tr></table></figure>
<h3 id="集合运算">集合运算</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并集</span></span><br><span class="line">a | b  <span class="comment"># 或 a.union(b) → &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 交集</span></span><br><span class="line">a &amp; b  <span class="comment"># 或 a.intersection(b) → &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 差集</span></span><br><span class="line">a - b  <span class="comment"># 或 a.difference(b) → &#123;1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对称差集（仅存在于一个集合中的元素）</span></span><br><span class="line">a ^ b  <span class="comment"># 或 a.symmetric_difference(b) → &#123;1, 4&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="成员测试非常高效o1复杂度">成员测试（非常高效，O(1)复杂度）</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> <span class="keyword">in</span> s)    <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span> <span class="keyword">not</span> <span class="keyword">in</span> s) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<h2 id="在bfs算法中的应用">在BFS算法中的应用</h2>
<p>在您提供的BFS代码中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visited = <span class="built_in">set</span>([start])</span><br></pre></td></tr></table></figure>
<p>这样使用集合是因为：</p>
<ol type="1">
<li><strong>快速查找</strong>：检查节点是否已访问（<code>if adjacent not in visited</code>）非常高效</li>
<li><strong>自动去重</strong>：防止同一节点被多次处理</li>
<li><strong>内存效率</strong>：比列表更适合存储大量唯一元素</li>
</ol>
<h2 id="集合与列表的对比">集合与列表的对比</h2>
<table>
<thead>
<tr>
<th>操作</th>
<th>列表(list)</th>
<th>集合(set)</th>
</tr>
</thead>
<tbody>
<tr>
<td>查找元素是否存在</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>插入元素</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>删除元素</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>内存占用</td>
<td>较少</td>
<td>较多</td>
</tr>
<tr>
<td>保持顺序</td>
<td>是</td>
<td>否</td>
</tr>
</tbody>
</table>
<h2 id="使用场景建议">使用场景建议</h2>
<p>使用 <code>set()</code> 当您需要：</p>
<ul>
<li>快速成员关系测试</li>
<li>去除重复元素</li>
<li>执行集合运算（并集、交集等）</li>
</ul>
<p>使用 <code>list</code> 当您需要：</p>
<ul>
<li>保持元素顺序</li>
<li>允许重复元素</li>
<li>通过索引访问元素</li>
</ul>
<h2 id="冻结集合不可变集合">冻结集合（不可变集合）</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frozen = <span class="built_in">frozenset</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment"># 创建不可变集合</span></span><br><span class="line"><span class="comment"># 不能添加/删除元素，但可以用于集合运算</span></span><br></pre></td></tr></table></figure>
<h1 id="附迷宫程序">附：迷宫程序</h1>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">start = (<span class="number">400</span>, <span class="number">984</span>)</span><br><span class="line">end = (<span class="number">398</span>, <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">iswhite</span>(<span class="params">value</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">all</span>(x &gt; <span class="number">200</span> <span class="keyword">for</span> x <span class="keyword">in</span> value):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getadjacent</span>(<span class="params">n</span>):</span><br><span class="line">    x, y = n</span><br><span class="line">    <span class="keyword">return</span> [(x - <span class="number">1</span>, y), (x, y - <span class="number">1</span>), (x + <span class="number">1</span>, y), (x, y + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">BFS</span>(<span class="params">start, end, pixels</span>):</span><br><span class="line">    came_from = &#123;start: start&#125;  </span><br><span class="line">    queue = deque([start])</span><br><span class="line">    visited = <span class="built_in">set</span>([start])</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">        current = queue.popleft()</span><br><span class="line">        <span class="keyword">for</span> adjacent <span class="keyword">in</span> getadjacent(current):</span><br><span class="line">            x, y = adjacent</span><br><span class="line">            <span class="keyword">if</span> adjacent <span class="keyword">not</span> <span class="keyword">in</span> visited <span class="keyword">and</span> iswhite(pixels[x, y]):</span><br><span class="line">                came_from[adjacent] = current</span><br><span class="line">                queue.append(adjacent)</span><br><span class="line">                visited.add(adjacent)</span><br><span class="line"></span><br><span class="line">    path = [end]</span><br><span class="line">    v = end</span><br><span class="line">    <span class="keyword">while</span> v != start:</span><br><span class="line">        v = came_from[v]</span><br><span class="line">        path.append(v)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">&quot;maze.jpg&quot;</span>).convert(<span class="string">&quot;RGB&quot;</span>)</span><br><span class="line">pixels = img.load()</span><br><span class="line">path = BFS(start, end, pixels)</span><br><span class="line"><span class="keyword">for</span> position <span class="keyword">in</span> path:</span><br><span class="line">    x, y = position</span><br><span class="line">    pixels[x, y] = (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>)  <span class="comment"># red</span></span><br><span class="line"></span><br><span class="line">img.save(<span class="string">&quot;maze_path.jpg&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="代码逐行解释">代码逐行解释</h1>
<p>这段代码实现了一个广度优先搜索(BFS)算法来解决迷宫问题，并在找到路径后将路径标记为红色。下面是逐行解释：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cllections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br></pre></td></tr></table></figure>
<ul>
<li>导入双端队列(deque)数据结构，用于实现BFS算法</li>
<li>导入PIL库的Image模块，用于处理图像</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start = (<span class="number">400</span>, <span class="number">984</span>)</span><br><span class="line">end = (<span class="number">398</span>, <span class="number">25</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>定义迷宫的起点坐标(400, 984)</li>
<li>定义迷宫的终点坐标(398, 25)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">iswhite</span>(<span class="params">value</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">all</span>(x &gt; <span class="number">200</span> <span class="keyword">for</span> x <span class="keyword">in</span> value):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定义判断像素是否为白色的函数</li>
<li>如果RGB三个通道的值都大于200，则认为是白色(可通行区域)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getadjacent</span>(<span class="params">n</span>):</span><br><span class="line">    x, y = n</span><br><span class="line">    <span class="keyword">return</span> [(x - <span class="number">1</span>, y), (x, y - <span class="number">1</span>), (x + <span class="number">1</span>, y), (x, y + <span class="number">1</span>)]</span><br></pre></td></tr></table></figure>
<ul>
<li>定义获取相邻像素坐标的函数</li>
<li>返回当前像素的上、下、左、右四个相邻像素的坐标</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">BFS</span>(<span class="params">start, end, pixels</span>):</span><br><span class="line">    came_from = &#123;start: start&#125;  </span><br><span class="line">    queue = deque([start])</span><br><span class="line">    visited = <span class="built_in">set</span>([start])</span><br></pre></td></tr></table></figure>
<ul>
<li>定义BFS函数，参数为起点、终点和像素数据</li>
<li><code>came_from</code>字典记录每个位置是从哪个位置访问来的(用于回溯路径)</li>
<li>初始化队列，加入起点</li>
<li><code>visited</code>集合记录已访问过的位置</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">    current = queue.popleft()</span><br><span class="line">    <span class="keyword">for</span> adjacent <span class="keyword">in</span> getadjacent(current):</span><br><span class="line">        x, y = adjacent</span><br><span class="line">        <span class="keyword">if</span> adjacent <span class="keyword">not</span> <span class="keyword">in</span> visited <span class="keyword">and</span> iswhite(pixels[x, y]):</span><br><span class="line">            came_from[adjacent] = current</span><br><span class="line">            queue.append(adjacent)</span><br><span class="line">            visited.add(adjacent)</span><br></pre></td></tr></table></figure>
<ul>
<li>BFS主循环，当队列不为空时继续</li>
<li>从队列左侧取出一个位置</li>
<li>遍历该位置的四个相邻位置</li>
<li>检查相邻位置是否未被访问过且是白色(可通行)</li>
<li>如果满足条件，记录该相邻位置的前驱位置，加入队列和已访问集合</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">path = [end]</span><br><span class="line">v = end</span><br><span class="line"><span class="keyword">while</span> v != start:</span><br><span class="line">    v = came_from[v]</span><br><span class="line">    path.append(v)</span><br></pre></td></tr></table></figure>
<ul>
<li>从终点开始回溯路径</li>
<li>沿着<code>came_from</code>字典从终点回溯到起点</li>
<li>将路径上的所有位置加入path列表</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> path</span><br></pre></td></tr></table></figure>
<ul>
<li>返回找到的路径(从终点到起点的顺序)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">&quot;maze.jpg&quot;</span>).convert(<span class="string">&quot;RGB&quot;</span>)</span><br><span class="line">pixels = img.load()</span><br></pre></td></tr></table></figure>
<ul>
<li>打开名为"maze.jpg"的迷宫图像并转换为RGB模式</li>
<li>加载像素数据以便访问和修改</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path = BFS(start, end, pixels)</span><br></pre></td></tr></table></figure>
<ul>
<li>调用BFS函数寻找从起点到终点的路径</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> position <span class="keyword">in</span> path:</span><br><span class="line">    x, y = position</span><br><span class="line">    pixels[x, y] = (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>)  <span class="comment"># red</span></span><br></pre></td></tr></table></figure>
<ul>
<li>遍历路径上的所有位置</li>
<li>将路径上的像素设为红色(RGB值为255,0,0)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img.save(<span class="string">&quot;maze_path.jpg&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>将修改后的图像(带有红色路径)保存为"maze_path.jpg"</li>
</ul>
<p>这段代码的核心是通过BFS算法在迷宫中寻找从起点到终点的路径，其中白色像素表示可通行的区域，其他颜色表示墙壁或障碍物。找到路径后，将路径标记为红色并保存图像。</p>
<p><img src="/images/maze/maze_path.jpg" alt="图Koch3-xuehua" style="width: 100%;"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">John Doe</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
